
SQL*Plus: Release 12.1.0.1.0 Production on Thu Jul 12 11:17:25 2018

Copyright (c) 1982, 2013, Oracle.  All rights reserved.

Connected to an idle instance.
ORACLE instance started.

Total System Global Area 1,7103E+10 bytes
Fixed Size		    2773936 bytes
Variable Size		 2449476688 bytes
Database Buffers	 1,4630E+10 bytes
Redo Buffers		   21180416 bytes
Database mounted.
Database opened.

Pluggable database created.


Session altered.

SQL> SET SERVEROUTPUT ON
SQL> SET FEEDBACK 1
SQL> SET NUMWIDTH 10
SQL> SET LINESIZE 80
SQL> SET TRIMSPOOL ON
SQL> SET TAB OFF
SQL> SET PAGESIZE 100
SQL> 
SQL> WHENEVER SQLERROR EXIT;
SQL> 
SQL> DOC
DOC>#######################################################################
DOC>#######################################################################
DOC>   The following statement will cause an "ORA-01403: no data found"
DOC>   error if we're not in a PDB.
DOC>   This script is intended to be run right after plugin of a PDB,
DOC>   while inside the PDB.
DOC>#######################################################################
DOC>#######################################################################
DOC>#
SQL> 
SQL> VARIABLE cdbname VARCHAR2(128)
SQL> VARIABLE pdbname VARCHAR2(128)
SQL> BEGIN
  2    SELECT sys_context('USERENV', 'CDB_NAME')
  3      INTO :cdbname
  4      FROM dual
  5      WHERE sys_context('USERENV', 'CDB_NAME') is not null;
  6    SELECT sys_context('USERENV', 'CON_NAME')
  7      INTO :pdbname
  8      FROM dual
  9      WHERE sys_context('USERENV', 'CON_NAME') <> 'CDB$ROOT';
 10  END;
 11  /

PL/SQL procedure successfully completed.

SQL> 
SQL> COLUMN pdbname NEW_VALUE pdbname
SQL> COLUMN pdbid NEW_VALUE pdbid
SQL> 
SQL> select :pdbname pdbname from dual;

PDBNAME
--------------------------------------------------------------------------------
TSTDB

1 row selected.

SQL> 
SQL> select TO_CHAR(con_id) pdbid from v$pdbs where name='&pdbname';
old   1: select TO_CHAR(con_id) pdbid from v$pdbs where name='&pdbname'
new   1: select TO_CHAR(con_id) pdbid from v$pdbs where name='TSTDB'

PDBID
----------------------------------------
4

1 row selected.

SQL> 
SQL> -- save pluggable database open mode
SQL> COLUMN open_state_col NEW_VALUE open_sql;
SQL> COLUMN restricted_col NEW_VALUE restricted_state;
SQL> SELECT decode(open_mode,
  2                'READ ONLY', 'ALTER PLUGGABLE DATABASE &pdbname OPEN READ ONLY',
  3                'READ WRITE', 'ALTER PLUGGABLE DATABASE &pdbname OPEN', '')
  4           open_state_col,
  5         decode(restricted, 'YES', 'RESTRICTED', '')
  6           restricted_col
  7         from v$pdbs where name='&pdbname';
old   2:               'READ ONLY', 'ALTER PLUGGABLE DATABASE &pdbname OPEN READ ONLY',
new   2:               'READ ONLY', 'ALTER PLUGGABLE DATABASE TSTDB OPEN READ ONLY',
old   3:               'READ WRITE', 'ALTER PLUGGABLE DATABASE &pdbname OPEN', '')
new   3:               'READ WRITE', 'ALTER PLUGGABLE DATABASE TSTDB OPEN', '')
old   7:        from v$pdbs where name='&pdbname'
new   7:        from v$pdbs where name='TSTDB'

OPEN_STATE_COL                                RESTRICTED
--------------------------------------------- ----------


1 row selected.

SQL> 
SQL> -- save value for _system_trig_enabled parameter
SQL> COLUMN sys_trig NEW_VALUE sys_trig_enabled  NOPRINT;
SQL> SELECT parm_values.ksppstvl as sys_trig
  2     FROM sys.x$ksppi parms, sys.x$ksppsv parm_values
  3     WHERE parms.ksppinm = '_system_trig_enabled' AND
  4           parms.inst_id = USERENV('Instance') AND
  5           parms.indx = parm_values.indx;




1 row selected.

SQL> 
SQL> -- if pdb was already closed, don't exit on error
SQL> WHENEVER SQLERROR CONTINUE;
SQL> 
SQL> alter pluggable database "&pdbname" close;
old   1: alter pluggable database "&pdbname" close
new   1: alter pluggable database "TSTDB" close
alter pluggable database "TSTDB" close
*
ERROR at line 1:
ORA-65020: pluggable database TSTDB already closed


SQL> 
SQL> WHENEVER SQLERROR EXIT;
SQL> 
SQL> alter session set container = CDB$ROOT;

Session altered.

SQL> alter system flush shared_pool;

System altered.

SQL> /

System altered.

SQL> /

System altered.

SQL> alter session set container = "&pdbname";
old   1: alter session set container = "&pdbname"
new   1: alter session set container = "TSTDB"

Session altered.

SQL> 
SQL> alter pluggable database "&pdbname" open restricted;
old   1: alter pluggable database "&pdbname" open restricted
new   1: alter pluggable database "TSTDB" open restricted

Warning: PDB altered with errors.

SQL> 
SQL> -- initial setup before beginning the script
SQL> alter session set "_ORACLE_SCRIPT"=true;

Session altered.

SQL> alter session set "_NONCDB_TO_PDB"=true;

Session altered.

SQL> ALTER SESSION SET NLS_LENGTH_SEMANTICS=BYTE;

Session altered.

SQL> ALTER SYSTEM SET "_system_trig_enabled"=FALSE SCOPE=MEMORY;

System altered.

SQL> exec dbms_pdb.noncdb_to_pdb(1);

PL/SQL procedure successfully completed.

SQL> 
SQL> -- if we're plugging in a database that had been upgraded, we need to:
SQL> -- 1) generate signatures for common tables
SQL> -- 2) patch up tables that with column order differences. This can happen due
SQL> --    to db creation scripts adding columns to the middle of a table vs
SQL> --    upgrade scripts adding to the end via ALTER TABLE ADD
SQL> 
SQL> alter session set container=CDB$ROOT;

Session altered.

SQL> 
SQL> -- create temporary object-linked view to get list of objects marked as common
SQL> -- in CDB$ROOT
SQL> create or replace view sys.cdb$common_root_objects&pdbid sharing=object as
  2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
  3         o.subname object_subname, o.signature object_sig,
  4         decode(bitand(o.flags, 65536), 65536, 'MDL', 'OBL') sharing
  5    from sys.obj$ o, sys.user$ u where
  6    o.owner#=u.user# and bitand(o.flags, 196608) <> 0;
old   1: create or replace view sys.cdb$common_root_objects&pdbid sharing=object as
new   1: create or replace view sys.cdb$common_root_objects4 sharing=object as

View created.

SQL> 
SQL> -- object-linked view for list of common users
SQL> create or replace view sys.cdb$common_users&pdbid sharing=object as
  2  select name from sys.user$ where bitand(spare1, 128) <> 0;
old   1: create or replace view sys.cdb$common_users&pdbid sharing=object as
new   1: create or replace view sys.cdb$common_users4 sharing=object as

View created.

SQL> 
SQL> -- object-linked view for accessing dependency$
SQL> create or replace view sys.cdb$rootdeps&pdbid sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#;
old   1: create or replace view sys.cdb$rootdeps&pdbid sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#
new   1: create or replace view sys.cdb$rootdeps4 sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#

View created.

SQL> 
SQL> -- switch into PDB
SQL> alter session set container="&pdbname";
old   1: alter session set container="&pdbname"
new   1: alter session set container="TSTDB"

Session altered.

SQL> 
SQL> create or replace view sys.cdb$common_root_objects&pdbid sharing=object as
  2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
  3         o.subname object_subname, o.signature object_sig,
  4         decode(bitand(o.flags, 65536), 65536, 'MDL', 'OBL') sharing
  5    from sys.obj$ o, sys.user$ u where
  6    o.owner#=u.user# and bitand(o.flags, 196608) <> 0;
old   1: create or replace view sys.cdb$common_root_objects&pdbid sharing=object as
new   1: create or replace view sys.cdb$common_root_objects4 sharing=object as

View created.

SQL> 
SQL> create or replace view sys.cdb$common_users&pdbid sharing=object as
  2  select name from sys.user$ where bitand(spare1, 128) <> 0;
old   1: create or replace view sys.cdb$common_users&pdbid sharing=object as
new   1: create or replace view sys.cdb$common_users4 sharing=object as

View created.

SQL> 
SQL> create or replace view sys.cdb$rootdeps&pdbid sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#;
old   1: create or replace view sys.cdb$rootdeps&pdbid sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#
new   1: create or replace view sys.cdb$rootdeps4 sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#

View created.

SQL> 
SQL> create or replace view sys.cdb$objects&pdbid sharing=none as
  2  select u.name owner, o.name object_name, o.signature object_sig, o.namespace nsp,
  3         o.subname object_subname, o.obj# object_id, o.type# object_type, o.flags flags
  4    from sys.obj$ o, sys.user$ u
  5    where o.owner#=u.user#;
old   1: create or replace view sys.cdb$objects&pdbid sharing=none as
new   1: create or replace view sys.cdb$objects4 sharing=none as

View created.

SQL> 
SQL> create or replace view sys.cdb$tables&pdbid sharing=none as
  2  select * from sys.cdb$objects&pdbid where object_type=2;
old   1: create or replace view sys.cdb$tables&pdbid sharing=none as
new   1: create or replace view sys.cdb$tables4 sharing=none as
old   2: select * from sys.cdb$objects&pdbid where object_type=2
new   2: select * from sys.cdb$objects4 where object_type=2

View created.

SQL> 
SQL> 
SQL> ---------------------------------------------------------------------------
SQL> -- PRE-SCRIPT CHECKS GO HERE:
SQL> 
SQL> set serveroutput on
SQL> 
SQL> -- Check that we have no invalid table data
SQL> DOC
DOC>#######################################################################
DOC>#######################################################################
DOC>
DOC>     The following statement will cause an "ORA-01722: invalid number"
DOC>     error, if the database contains invalid data as a result of type
DOC>     evolution which was performed without the data being converted.
DOC>
DOC>     To resolve this specific "ORA-01722: invalid number" error:
DOC>       Perform the data conversion (details below) in the pluggable database.
DOC>
DOC>     Please refer to Oracle Database Object-Relational Developer's Guide
DOC>     for more information about type evolution.
DOC>
DOC>     Data in columns of evolved types must be converted before the
DOC>     database can be converted.
DOC>
DOC>     The following commands, run inside the PDB, will perform the data
DOC>     conversion for Oracle supplied data:
DOC>
DOC>     @?/rdbms/admin/utluppkg.sql
DOC>     SET SERVEROUTPUT ON;
DOC>     exec dbms_preup.run_fixup_and_report('INVALID_SYS_TABLEDATA');
DOC>     SET SERVEROUTPUT OFF;
DOC>
DOC>     You should then confirm that any non-Oracle supplied data is also
DOC>     converted.  You should review the data and determine if it needs
DOC>     to be converted or removed.
DOC>
DOC>     To view the data that is affected by type evolution, execute the
DOC>     following inside the PDB:
DOC>
DOC>     SELECT rpad(u.name,128) TABLENAME, rpad(o.name,128) OWNER,
DOC>       rpad(c.name,128) COLNAME FROM SYS.OBJ$ o, SYS.COL$ c, SYS.COLTYPE$ t,
DOC>         SYS.USER$ u
DOC>         WHERE o.OBJ# = t.OBJ# AND c.OBJ# = t.OBJ# AND c.COL# = t.COL#
DOC>           AND t.INTCOL# = c.INTCOL# AND BITAND(t.FLAGS, 256) = 256
DOC>           AND o.OWNER# = u.USER# AND o.OWNER# NOT IN
DOC>            (SELECT UNIQUE (d.USER_ID) FROM SYS.DBA_USERS d, SYS.REGISTRY$ r
DOC>               WHERE d.USER_ID = r.SCHEMA# and r.NAMESPACE='SERVER');
DOC>
DOC>     Once the data is confirmed, the following commands, run inside the PDB,
DOC>     will convert the data returned by the above query.
DOC>
DOC>     @?/rdbms/admin/utluppkg.sql
DOC>     SET SERVEROUTPUT ON;
DOC>     exec dbms_preup.run_fixup_and_report('INVALID_USR_TABLEDATA');
DOC>     SET SERVEROUTPUT OFF;
DOC>
DOC>     Depending on the amount of data involved, converting the evolved type
DOC>     data can take a significant amount of time.
DOC>
DOC>     After this is complete, please rerun noncdb_to_pdb.sql.
DOC>
DOC>#######################################################################
DOC>#######################################################################
DOC>#
SQL> 
SQL> @$ORACLE_HOME/rdbms/admin/utluppkg.sql
SQL> Rem $Header: rdbms/admin/utluppkg.sql /st_rdbms_12.1.0.1/8 2013/04/02 21:44:49 jibyun Exp $
SQL> Rem
SQL> Rem utluppkg.sql
SQL> Rem
SQL> Rem Copyright (c) 2011, 2013, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      utluppkg.sql - Pre Upgrade Utility Package
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Procedures and functions used to perform checks on a database which
SQL> Rem      is getting ready to be upgrade.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      This file contains both the package body and defintion.
SQL> Rem
SQL> Rem      The package has test types:
SQL> Rem         - initparams
SQL> Rem         - components
SQL> Rem         - resources
SQL> Rem         - pre-upgrade checks
SQL> Rem
SQL> Rem      which may or may not be requested by the user.
SQL> Rem      The output_<test-type> procedure will verify that the
SQL> Rem      init_<test-type> procedure has been called.
SQL> Rem
SQL> Rem      Any global variables will be initialized by
SQL> Rem      the init_package procedure.
SQL> Rem
SQL> Rem      When using 'TEXT' output without an output file,
SQL> Rem      the caller must turn off SERVER OUTPUT prior to calling
SQL> Rem      the _output routines.
SQL> Rem          SET SERVEROUTPUT ON FORMAT WRAPPED;
SQL> Rem          SET ECHO OFF FEEDBACK OFF PAGESIZE 0 LINESIZE 5000;
SQL> Rem
SQL> Rem      Variable that begin with "c_" are constants for the package
SQL> Rem
SQL> REM BEGIN SQL_FILE_METADATA
SQL> REM SQL_SOURCE_FILE: rdbms/admin/utluppkg.sql
SQL> REM SQL_SHIPPED_FILE: rdbms/admin/utluppkg.sql
SQL> REM SQL_PHASE: UTLUPPKG
SQL> REM SQL_STARTUP_MODE: NORMAL
SQL> REM SQL_IGNORABLE_ERRORS: NONE
SQL> REM SQL_CALLING_FILE: rdbms/admin/catproc.sql
SQL> REM END SQL_FILE_METADATA
SQL> REM
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    jibyun      03/28/13 - Bug 16567861: warn if the following users/roles
SQL> Rem                           already exist: SYSBACKUP, SYSDG, SYSKM,
SQL> Rem                           CAPTURE_ADMIN
SQL> Rem    yiru        03/28/13 - Bug 16561033: Add functions to check the existence
SQL> Rem                           of RAS reserved roles
SQL> Rem    cmlim       03/28/13 - XbranchMerge cmlim_bug-16191893 from main
SQL> Rem    cmlim       03/22/13 - bug 16191893 - error/warning/informational msg
SQL> Rem                           count (in summary output) are not reset on reruns
SQL> Rem    cmlim       01/25/13 - update INVALID_SYS_TABLEDATA_gethelp to include
SQL> Rem                           PDB (for bug 16223659)
SQL> Rem    cmlim       01/08/13 - bug 16085743: extra: change WARNING to ERROR
SQL> Rem                           for invalid user table data
SQL> Rem    bmccarth    01/07/13 - tabledata fix for DBUA
SQL> Rem    bmccarth    01/03/13 - fix several sql statements
SQL> Rem    bmccarth    12/20/12 - bug 15899139 - rul/exf fix
SQL> Rem    bmccarth    12/01/12 - INVALID_SYS_TABLEDATA/INVALID_USR_TABLEDATA
SQL> Rem                         - rename sqlcode variable/params
SQL> Rem                         - Add condition_exists function.
SQL> Rem                         - Add sql file metadata as this will be loaded
SQL> Rem                           during db create.
SQL> Rem                         - Fix AMD check
SQL> Rem                         - Fix in-place check, if DB was never
SQL> Rem                           upgraded, tool reported 'unsupported', also
SQL> Rem                           added several comments around that block of code
SQL> Rem                         - Unused variables removed
SQL> Rem    jerrede     11/08/12 - Make tz_fixup public
SQL> Rem    mfallen     09/23/12 - bug 14390165: check if AWR will need cleanup
SQL> Rem    bmccarth    09/27/12 - job_queue_processes check
SQL> Rem                         - remove un-used variables
SQL> Rem                         - move routine def/decl into alpha order
SQL> Rem    bmccarth    09/27/12 - bug 14684128 - protect writes when logs fail to
SQL> Rem                           open
SQL> Rem    amunnoli    09/07/12 - Bug 14560783: Raise an error if user or role
SQL> Rem                           named AUDSYS,AUDIT_ADMIN,AUDIT_VIEWER already
SQL> Rem                           exists in the source DB to be upgraded to 12.1
SQL> Rem    bmccarth    09/12/12 - bug 14608684 - ultrasearch txt
SQL> Rem                         - bug 14619362 - DMSYS text change
SQL> Rem                         - bug 14635610 - re-init resource value each
SQL> Rem                           time through
SQL> Rem    amunnoli    09/07/12 - Bug 14560783: Raise an error if user or role
SQL> Rem                           named AUDSYS,AUDIT_ADMIN,AUDIT_VIEWER already
SQL> Rem                           exists in the source DB to be upgraded to 12.1
SQL> Rem    cmlim       09/04/12 - bug 14551710 - tablespace sizing for apex need to
SQL> Rem                           be updated for latest apex version 4.2.0
SQL> Rem                         - extra: increment archivelog and
SQL> Rem                           flashbacklog experimental numbers by 1.1
SQL> Rem                         - extra: sysaux size should not be less than 500M
SQL> Rem                         - extra: minimum tablespace incremental size is 50M
SQL> Rem                         - extra: update description to OLS_SYS_MOVE
SQL> Rem                         - extra: prefixed 'DUAL' with 'SYS.'
SQL> Rem    bmccarth    08/17/12 - remove refreshes exist check
SQL> Rem    bmccarth    08/08/12 - bug 14469506 - rework output
SQL> Rem                         - MAX_PROCESS becomes default_process
SQL> Rem                         - bug 14619157 error count not matching
SQL> Rem                           so clear check record run info in run_check
SQL> Rem    bmccarth    08/17/12 - remove view in progress check
SQL> Rem    bmccarth    08/07/12 - em check is incorrect
SQL> Rem    bmccarth    07/10/12 - tz to 18
SQL> Rem    bmccarth    07/09/12 - merge in cmlim archivemode size
SQL> Rem                         - Add diag info to XML doc when requested
SQL> Rem                         - sec_case_sensitive_logon gone for 12.1
SQL> Rem    bmccarth    05/09/12 - give DBUA all tablespaces
SQL> Rem                         - stop output tablespace for unsupported upgrades
SQL> Rem                         - Update error/warning text after
SQL> Rem                           documention review
SQL> Rem                         - min process up to 300 - bug 14067986 (and
SQL> Rem                           add manual output)
SQL> Rem                         - deprecated becomes desupported (text only change)
SQL> Rem                         - change DisplayLine so it works from
SQL> Rem                           init procedures
SQL> Rem                         - Move tablespace debug output
SQL> Rem                         - compat recommend becomes an actual check
SQL> Rem                         - alphabetize check functions
SQL> Rem                         - add ols_sys_move check
SQL> Rem                         - all checks are no preceeded by ERROR or
SQL> Rem                           WARNING should they fail (allow easy
SQL> Rem                           searching for issues in log files)
SQL> Rem                         - prior code review comments: use constants for
SQL> Rem                           return values
SQL> Rem                         - AL24UTFFSS and NCHAR_TYPE checks removed
SQL> Rem    bmccarth    04/12/12 - merge in size changes
SQL> Rem                         - Updated buffer size for utl_file
SQL> Rem                         - Ultrasearch and enableD_indexes_tbl detail are
SQL> Rem                           now text, not sql
SQL> Rem    cdilling    04/10/12 - change type_sql to type_text -bug 13946411
SQL> Rem    awesley     04/02/12 - deprecate cwm, remove AMD
SQL> Rem    bmccarth    03/07/12 - network acl check
SQL> Rem                         - Audit_Trail param changes - bug 13885449
SQL> Rem                         - Fix java cleanup from failing on mulitple loads
SQL> Rem                         - Cleanup/add comments around processing
SQL> Rem                           special params.
SQL> Rem                         - EM warning changed
SQL> Rem                         - buffer sizes for output increase
SQL> Rem                         - remove 'IN' from  result_text of _check routines
SQL> Rem                         - db_name to 256
SQL> Rem                         - rename a few package level variables
SQL> Rem                         - remove genFixup_info (duplicate of genFixup
SQL> Rem                           after rework of package in last rev)
SQL> Rem                         - OCM and APPQOSSYS User check is only for 102
SQL> Rem                           upgrades
SQL> Rem                         - bug 13819259 - refreshes_exist check was wrong
SQL> Rem                         - bug 12536056 - add params around _ event
SQL> Rem                           check clause
SQL> Rem    bmccarth    01/19/12 - bug 13601349 - handle directory object failures
SQL> Rem                         - bug 13616875 - missing htmlentities call
SQL> Rem                         - bug 13628060 - quotes wrong for fixup of
SQL> Rem                           displaying events
SQL> Rem                         - files_need_recovery is a manual fix (not auto)
SQL> Rem                         - When set_output_file is called with location,
SQL> Rem                           set the validated bit so the code actually does
SQL> Rem                           something.
SQL> Rem                         - Fix ocm/qos checks
SQL> Rem                         - Add missing rollback seg output back in
SQL> Rem                         - Moved recommendations into check_table for
SQL> Rem                           consistancy
SQL> Rem                         - Remove grants from script
SQL> Rem                         - Add missing compatability check
SQL> Rem                         - remove script_location variable (use
SQL> Rem                           output_location for all output)
SQL> Rem                         - ensure package level output variables are cleared
SQL> Rem                         - present better errors if directory does not
SQL> Rem                           exist (including if directory object
SQL> Rem                           already exists)
SQL> Rem                         - Add debug procedures to force failures
SQL> Rem    bmccarth    12/28/11 - protect drop directory from errors
SQL> Rem    bmccarthy   12/15/11 - Add recommendation section
SQL> Rem    bmccarth    11/15/11 - continue adding features
SQL> Rem    bmccarth    11/09/11 - Added htmlentities so DBUA had valid xml when
SQL> Rem                           a SQL command included certain characters
SQL> Rem                         - removed ; from end of sql commands
SQL> Rem    bmccarth    09/13/11 - Merge in DBUA changes continue to add checks
SQL> Rem    bmccarth    08/17/11 - Pre Upgrade Utility Package, framework
SQL> Rem                         - testing puiu$data removed
SQL> Rem    bmccarth    08/17/11 - Created
SQL> Rem
SQL> 
SQL> 
SQL> CREATE OR REPLACE PACKAGE dbms_preup AS
  2  --
  3  -- preupgrd.sql will look at the version to
  4  -- make sure things match up.
  5  --
  6  c_version     CONSTANT VARCHAR2(30)    := '12.1.0.1';
  7  
  8  c_patchset    CONSTANT VARCHAR2(2)     := '.0';
  9  c_build       CONSTANT VARCHAR2(30)    := '006';
 10  c_supported_versions
 11                CONSTANT VARCHAR(50)     := '10.2.0.5, 11.1.0.7, 11.2.0.2, 11.2.0.3, 11.2.0.4';
 12  c_tz_version  CONSTANT NUMBER          := 18;
 13  c_max_processes CONSTANT NUMBER        := 300;
 14  
 15  --
 16  -- what we require for min compat, in numeric and
 17  -- text form
 18  --
 19  c_compat_min_num CONSTANT NUMBER       := 11;
 20  c_compat_min  CONSTANT VARCHAR(30)     := '11.0.0';
 21  
 22  c_dir_obj        CONSTANT VARCHAR2(30) := 'PREUPGRADE_DIR';  -- Default dir obj
 23  c_output_fn      CONSTANT VARCHAR2(30) := 'preupgrade.log';  -- Default log fn
 24  c_pre_script_fn  CONSTANT VARCHAR2(30) := 'preupgrade_fixups.sql';
 25  c_post_script_fn CONSTANT VARCHAR2(30) := 'postupgrade_fixups.sql';
 26  
 27  --
 28  -- What kind of output are we doing?
 29  --
 30  c_output_text     CONSTANT NUMBER := 1;
 31  c_output_xml      CONSTANT NUMBER := 2;
 32  
 33  --
 34  -- Used to keep track of pre-upgrade checks
 35  --
 36  --
 37  TYPE check_record_t IS RECORD (
 38    name             VARCHAR2(30),   -- Name of check (and used for function
 39                                     -- names also (if not too long))
 40    type             NUMBER,         -- see type constants for values
 41                      -- c_type_check = standard check for both xdb/manual
 42                      -- c_type_check_interactive_only = Standard check, but manual only
 43                      -- c_type_recommend_pre = pre-up recommendation (manual)
 44                      -- c_type_recommend_post = post-up recommendation (manual)
 45                      --
 46    descript         VARCHAR2(100),  -- Short description of the check
 47    f_name_prefix    VARCHAR2(30),   -- If name is too long to add
 48                                     -- "_gethelp" and create a valid
 49                                     -- function name, this is set to a
 50                                     -- shorten name to be used when accessing
 51                                     -- a check's functions.
 52    level            NUMBER,         -- Check level (c_check_level_....)
 53    fix_type         NUMBER,         -- fix_type (by_fixup, manual)
 54    executed         BOOLEAN,        -- Has the test been run?
 55    execute_failed   BOOLEAN,        -- If the check takes an exception.
 56    passed           BOOLEAN,        -- Did the check pass?
 57    skipped          BOOLEAN,        -- Skipped, check not valid for this version
 58    fixup_executed   BOOLEAN,        -- Was a fixup attempted ?
 59    fixup_failed     BOOLEAN,        -- Did the fixup execute fail?
 60    fixup_status     NUMBER,         -- c_fixup_status... value
 61    always_fail      BOOLEAN,        -- Debug the check's failure path (generate a fixup)
 62    valid_versions   VARCHAR(100),   -- What versions is this check valid for?
 63    result_text      VARCHAR2(1500), -- result of fixup/check
 64    sqlcode          NUMBER          -- The sqlcode should an error occur.
 65  );
 66  TYPE check_table_t is TABLE of check_record_t INDEX BY BINARY_INTEGER;
 67  
 68  --
 69  -- This record is to index the check_table by name
 70  --
 71  TYPE check_record_name_t IS RECORD (
 72    idx            NUMBER               -- Index into check_table
 73  );
 74  
 75  TYPE check_names_table_t is TABLE of check_record_name_t INDEX BY VARCHAR2(30);
 76  
 77  --
 78  -- dbms_preup.check_table contains
 79  -- a list of all of the checks this package (once inited)
 80  -- has performed on the database.
 81  --
 82  -- Although check_table could have been indexed by name, doing so would have
 83  -- changed the order when looping through as new checks were added or old
 84  -- checks removed.
 85  --
 86  check_table       check_table_t;
 87  
 88  --
 89  -- Index by name
 90  --
 91  check_names       check_names_table_t;
 92  
 93  
 94  pCheckCount        NUMBER := 0;  -- Total number of checks we have available.
 95  pCheckErrorCount   NUMBER;
 96  pCheckWarningCount NUMBER;
 97  pCheckInfoCount    NUMBER;
 98  
 99  --
100  -- How the fix can be fixed
101  --
102  c_fix_source_manual      CONSTANT NUMBER := 0;
103  c_fix_source_auto        CONSTANT NUMBER := 1;  -- pre-upgrade
104  c_fix_target_auto_pre    CONSTANT NUMBER := 2;  -- targetpre - only new timezone
105  c_fix_target_auto_post   CONSTANT NUMBER := 3;  -- after upgrade process is done
106  c_fix_target_manual_pre  CONSTANT NUMBER := 4;  -- manual, before
107  c_fix_target_manual_post CONSTANT NUMBER := 5; -- manual after upgrade
108  --
109  -- Type of Check
110  --
111  c_type_check                   CONSTANT NUMBER := 1;
112  c_type_check_interactive_only  CONSTANT NUMBER := 2;
113  c_type_recommend_pre           CONSTANT NUMBER := 3;
114  c_type_recommend_post          CONSTANT NUMBER := 4;
115  
116  --
117  -- What gethelp returns
118  --
119  c_help_overview       CONSTANT NUMBER := 1;
120  c_help_fixup          CONSTANT NUMBER := 2;
121  
122  --
123  -- What a Fixup routine could return
124  --
125  c_fixup_status_failure CONSTANT NUMBER := 0;
126  c_fixup_status_success CONSTANT NUMBER := 1;
127  c_fixup_status_info    CONSTANT NUMBER := 2;
128  
129  --
130  -- What Check/help routine could return
131  --
132  c_status_failure                 CONSTANT NUMBER := 0;
133  c_status_success                 CONSTANT NUMBER := 1;
134  c_status_passed                  CONSTANT NUMBER := 1;
135  c_status_not_for_this_version    CONSTANT NUMBER := 2;
136  
137  -- Functions
138  
139  FUNCTION  get_version    RETURN VARCHAR2;
140  FUNCTION  run_all_checks RETURN NUMBER;
141  
142  FUNCTION  run_check (check_name IN VARCHAR2) RETURN check_record_t;
143  FUNCTION  run_check_simple (check_name IN VARCHAR2) RETURN check_record_t;
144  FUNCTION  condition_exists (check_name IN VARCHAR2) RETURN BOOLEAN;
145  PROCEDURE run_check (check_name IN VARCHAR2);
146  FUNCTION  run_fixup (check_name IN VARCHAR2) RETURN check_record_t;
147  PROCEDURE run_fixup_and_report (check_name VARCHAR2);
148  PROCEDURE run_fixup_info (check_name VARCHAR2);
149  PROCEDURE display_check_text (check_record check_record_t );
150  PROCEDURE fixup_summary (preup BOOLEAN);
151  PROCEDURE clear_run_flag (preup BOOLEAN);
152  
153  FUNCTION  run_recommend (check_name IN VARCHAR2) RETURN check_record_t;
154  PROCEDURE run_all_recommend (whatType NUMBER);
155  
156  PROCEDURE DisplayLine (line IN VARCHAR2);
157  PROCEDURE DisplayLine (uft UTL_FILE.FILE_TYPE, line IN VARCHAR2);
158  PROCEDURE DisplayDiagLine (line IN VARCHAR2);
159  
160  PROCEDURE start_xml_document;
161  PROCEDURE end_xml_document;
162  
163  PROCEDURE output_summary;
164  PROCEDURE output_components;
165  PROCEDURE output_flashback;
166  PROCEDURE output_initparams;
167  PROCEDURE output_preup_checks;
168  PROCEDURE output_prolog;
169  PROCEDURE output_check_summary;
170  PROCEDURE output_recommendations;
171  PROCEDURE output_resources;
172  PROCEDURE output_tablespaces;
173  PROCEDURE output_rollback_segs;
174  
175  --
176  -- Call these to debug a certain check,
177  -- debug all checks, or debug tablespace resources
178  --
179  PROCEDURE dbg_check (check_name IN VARCHAR2);
180  PROCEDURE dbg_all_checks;
181  PROCEDURE dbg_all_resources (onoff BOOLEAN);
182  PROCEDURE dbg_space_resources (onoff BOOLEAN);
183  PROCEDURE time_zone_check;
184  PROCEDURE tz_fixup (call_init BOOLEAN);
185  
186  --
187  -- Set the output type to either Text or XML
188  --
189  -- If XML is chosen, a call to  start_xml_document
190  -- and close_xml_docuement must be
191  -- made to ensure correct syntax of the XML output.
192  --
193  -- Output type default to TEXT
194  --
195  PROCEDURE  set_output_type (p_type VARCHAR2);
196  
197  --
198  -- If the diag output is going to a file, use these
199  -- proceduress to set, and close that output file.
200  --
201  -- The package uses utl_file, and if there is an
202  -- error opening the file, the package will throw
203  -- an error.
204  --
205  PROCEDURE  set_output_file (p_on_off BOOLEAN);
206  PROCEDURE  set_output_file (p_fn   VARCHAR2);
207  PROCEDURE  set_output_file (p_location VARCHAR2, p_fn VARCHAR2);
208  
209  PROCEDURE  close_file;
210  
211  PROCEDURE  reset_init_package;
212  
213  --
214  -- Turn generating scripts on/off
215  --
216  PROCEDURE  set_scripts (p_on_off BOOLEAN);
217  
218  --
219  -- Function to get path of directory used to output log/script
220  --
221  FUNCTION get_output_path RETURN VARCHAR2;
222  
223  --
224  -- Display a single check record fields
225  --
226  PROCEDURE  dump_check_rec   (p_check_rec check_record_t);
227  
228  --
229  -- Specific Check/fixup Functions
230  --
231  FUNCTION  amd_exists_check (result_txt OUT VARCHAR2) RETURN number;
232  PROCEDURE amd_exists_fixup;
233  FUNCTION  amd_exists_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
234  FUNCTION  amd_exists_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
235  
236  FUNCTION  aar_present_check (result_txt OUT VARCHAR2) RETURN number;
237  PROCEDURE aar_present_fixup;
238  FUNCTION  aar_present_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
239  FUNCTION  aar_present_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
240  
241  FUNCTION  appqossys_user_present_check (result_txt OUT VARCHAR2) RETURN number;
242  PROCEDURE appqossys_user_present_fixup;
243  FUNCTION  appqossys_user_present_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
244  FUNCTION  appqossys_user_present_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
245  
246  FUNCTION  audsys_user_present_check (result_txt OUT VARCHAR2) RETURN number;
247  PROCEDURE audsys_user_present_fixup;
248  FUNCTION  audsys_user_present_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
249  FUNCTION  audsys_user_present_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
250  
251  FUNCTION  audit_viewer_check (result_txt OUT VARCHAR2) RETURN number;
252  PROCEDURE audit_viewer_fixup;
253  FUNCTION  audit_viewer_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
254  FUNCTION  audit_viewer_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
255  
256  FUNCTION SYSBACKUP_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number;
257  FUNCTION SYSBACKUP_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
258  PROCEDURE SYSBACKUP_USER_PRESENT_fixup;
259  FUNCTION SYSBACKUP_USER_PRESENT_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
260  
261  FUNCTION SYSDG_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number;
262  FUNCTION SYSDG_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
263  PROCEDURE SYSDG_USER_PRESENT_fixup;
264  FUNCTION SYSDG_USER_PRESENT_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
265  
266  FUNCTION SYSKM_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number;
267  FUNCTION SYSKM_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
268  PROCEDURE SYSKM_USER_PRESENT_fixup;
269  FUNCTION SYSKM_USER_PRESENT_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
270  
271  FUNCTION CAPT_ADM_ROLE_PRESENT_check (result_txt OUT VARCHAR2) RETURN number;
272  FUNCTION CAPT_ADM_ROLE_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
273  PROCEDURE CAPT_ADM_ROLE_PRESENT_fixup;
274  FUNCTION CAPT_ADM_ROLE_PRESENT_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
275  
276  
277  
278  FUNCTION  awr_dbids_present_check (result_txt OUT VARCHAR2) RETURN number;
279  PROCEDURE awr_dbids_present_fixup;
280  FUNCTION  awr_dbids_present_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
281  FUNCTION  awr_dbids_present_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
282  
283  FUNCTION  compatible_parameter_check (result_txt OUT VARCHAR2) RETURN number;
284  PROCEDURE compatible_parameter_fixup;
285  FUNCTION  compatible_parameter_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
286  FUNCTION  compatible_parameter_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
287  
288  FUNCTION  dbms_ldap_dep_exist_check (result_txt OUT VARCHAR2) RETURN number;
289  PROCEDURE dbms_ldap_dep_exist_fixup;
290  FUNCTION  dbms_ldap_dep_exist_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
291  FUNCTION  dbms_ldap_dep_exist_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
292  
293  FUNCTION  default_process_count_check (result_txt OUT VARCHAR2) RETURN number;
294  PROCEDURE default_process_count_fixup;
295  FUNCTION  default_process_count_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
296  FUNCTION  default_process_count_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
297  
298  FUNCTION  dv_enabled_check (result_txt OUT VARCHAR2) RETURN number;
299  PROCEDURE dv_enabled_fixup;
300  FUNCTION  dv_enabled_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
301  FUNCTION  dv_enabled_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
302  
303  FUNCTION  em_present_check (result_txt OUT VARCHAR2) RETURN number;
304  PROCEDURE em_present_fixup;
305  FUNCTION  em_present_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
306  FUNCTION  em_present_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
307  
308  FUNCTION  enabled_indexes_tbl_check (result_txt OUT VARCHAR2) RETURN number;
309  PROCEDURE enabled_indexes_tbl_fixup;
310  FUNCTION  enabled_indexes_tbl_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
311  FUNCTION  enabled_indexes_tbl_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
312  
313  FUNCTION  exf_rul_exists_check (result_txt OUT VARCHAR2) RETURN number;
314  PROCEDURE exf_rul_exists_fixup;
315  FUNCTION  exf_rul_exists_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
316  FUNCTION  exf_rul_exists_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
317  
318  FUNCTION  files_need_recovery_check (result_txt OUT VARCHAR2) RETURN number;
319  PROCEDURE files_need_recovery_fixup;
320  FUNCTION  files_need_recovery_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
321  FUNCTION  files_need_recovery_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
322  
323  FUNCTION  files_backup_mode_check (result_txt OUT VARCHAR2) RETURN number;
324  PROCEDURE files_backup_mode_fixup;
325  FUNCTION  files_backup_mode_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
326  FUNCTION  files_backup_mode_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
327  
328  FUNCTION  invalid_laf_check (result_txt OUT VARCHAR2) RETURN number;
329  PROCEDURE invalid_laf_fixup;
330  FUNCTION  invalid_laf_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
331  FUNCTION  invalid_laf_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
332  
333  FUNCTION  invalid_obj_exist_check (result_txt OUT VARCHAR2) RETURN number;
334  PROCEDURE invalid_obj_exist_fixup;
335  FUNCTION  invalid_obj_exist_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
336  FUNCTION  invalid_obj_exist_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
337  FUNCTION  invalid_obj_exclude RETURN VARCHAR2;
338  
339  FUNCTION  invalid_sys_tabledata_check (result_txt OUT VARCHAR2) RETURN number;
340  PROCEDURE invalid_sys_tabledata_fixup;
341  FUNCTION  invalid_sys_tabledata_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
342  FUNCTION  invalid_sys_tabledata_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
343  
344  FUNCTION  invalid_usr_tabledata_check (result_txt OUT VARCHAR2) RETURN number;
345  PROCEDURE invalid_usr_tabledata_fixup;
346  FUNCTION  invalid_usr_tabledata_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
347  FUNCTION  invalid_usr_tabledata_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
348  
349  FUNCTION  job_queue_process_check (result_txt OUT VARCHAR2) RETURN number;
350  PROCEDURE job_queue_process_fixup;
351  FUNCTION  job_queue_process_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
352  FUNCTION  job_queue_process_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
353  
354  FUNCTION  nacl_objects_exist_check (result_txt OUT VARCHAR2) RETURN number;
355  PROCEDURE nacl_objects_exist_fixup;
356  FUNCTION  nacl_objects_exist_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
357  FUNCTION  nacl_objects_exist_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
358  
359  FUNCTION  new_time_zones_exist_check (result_txt OUT VARCHAR2) RETURN number;
360  PROCEDURE new_time_zones_exist_fixup;
361  FUNCTION  new_time_zones_exist_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
362  FUNCTION  new_time_zones_exist_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
363  
364  FUNCTION  ocm_user_present_check (result_txt OUT VARCHAR2) RETURN number;
365  PROCEDURE ocm_user_present_fixup;
366  FUNCTION  ocm_user_present_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
367  FUNCTION  ocm_user_present_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
368  
369  FUNCTION  old_time_zones_exist_check  (result_txt OUT VARCHAR2) RETURN number;
370  PROCEDURE old_time_zones_exist_fixup;
371  FUNCTION  old_time_zones_exist_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
372  FUNCTION  old_time_zones_exist_fixup  (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
373  
374  FUNCTION  ols_sys_move_check (result_txt OUT VARCHAR2) RETURN number;
375  PROCEDURE ols_sys_move_fixup;
376  FUNCTION  ols_sys_move_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
377  FUNCTION  ols_sys_move_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
378  
379  FUNCTION  ordimageindex_check (result_txt OUT VARCHAR2) RETURN number;
380  PROCEDURE ordimageindex_fixup;
381  FUNCTION  ordimageindex_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
382  FUNCTION  ordimageindex_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
383  
384  FUNCTION  pending_2pc_txn_check (result_txt OUT VARCHAR2) RETURN number;
385  PROCEDURE pending_2pc_txn_fixup;
386  FUNCTION  pending_2pc_txn_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
387  FUNCTION  pending_2pc_txn_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
388  
389  FUNCTION  purge_recyclebin_check (result_txt OUT VARCHAR2) RETURN number;
390  PROCEDURE purge_recyclebin_fixup;
391  FUNCTION  purge_recyclebin_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
392  FUNCTION  purge_recyclebin_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
393  
394  FUNCTION  remove_dmsys_check (result_txt OUT VARCHAR2) RETURN number;
395  PROCEDURE remove_dmsys_fixup;
396  FUNCTION  remove_dmsys_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
397  FUNCTION  remove_dmsys_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
398  
399  FUNCTION  remote_redo_check (result_txt OUT VARCHAR2) RETURN number;
400  PROCEDURE remote_redo_fixup;
401  FUNCTION  remote_redo_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
402  FUNCTION  remote_redo_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
403  
404  FUNCTION  sync_standby_db_check (result_txt OUT VARCHAR2) RETURN number;
405  PROCEDURE sync_standby_db_fixup;
406  FUNCTION  sync_standby_db_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
407  FUNCTION  sync_standby_db_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
408  
409  FUNCTION  sys_def_tablespace_check (result_txt OUT VARCHAR2) RETURN number;
410  PROCEDURE sys_def_tablespace_fixup;
411  FUNCTION  sys_def_tablespace_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
412  FUNCTION  sys_def_tablespace_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
413  
414  FUNCTION  ultrasearch_data_check (result_txt OUT VARCHAR2) RETURN number;
415  PROCEDURE ultrasearch_data_fixup;
416  FUNCTION  ultrasearch_data_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
417  FUNCTION  ultrasearch_data_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
418  
419  FUNCTION  unsupported_version_check (result_txt OUT VARCHAR2) RETURN number;
420  PROCEDURE unsupported_version_fixup;
421  FUNCTION  unsupported_version_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
422  FUNCTION  unsupported_version_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
423  
424  FUNCTION  provisioner_present_check (result_txt OUT VARCHAR2) RETURN number;
425  PROCEDURE provisioner_present_fixup;
426  FUNCTION  provisioner_present_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
427  FUNCTION  provisioner_present_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
428  
429  FUNCTION  xs_resource_present_check (result_txt OUT VARCHAR2) RETURN number;
430  PROCEDURE xs_resource_present_fixup;
431  FUNCTION  xs_resource_present_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
432  FUNCTION  xs_resource_present_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
433  
434  FUNCTION  xs_session_admin_check (result_txt OUT VARCHAR2) RETURN number;
435  PROCEDURE xs_session_admin_fixup;
436  FUNCTION  xs_session_admin_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
437  FUNCTION  xs_session_admin_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
438  
439  FUNCTION  xs_namespace_admin_check (result_txt OUT VARCHAR2) RETURN number;
440  PROCEDURE xs_namespace_admin_fixup;
441  FUNCTION  xs_namespace_admin_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
442  FUNCTION  xs_namespace_admin_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
443  
444  FUNCTION  xs_cache_admin_check (result_txt OUT VARCHAR2) RETURN number;
445  PROCEDURE xs_cache_admin_fixup;
446  FUNCTION  xs_cache_admin_gethelp (HelpType IN NUMBER) RETURN VARCHAR2;
447  FUNCTION  xs_cache_admin_fixup (result_txt IN OUT VARCHAR2, pSqlcode IN OUT NUMBER) RETURN number;
448  --
449  -- The recommendation procedures
450  --
451  PROCEDURE dictionary_stats_recommend;
452  PROCEDURE hidden_params_recommend;
453  PROCEDURE underscore_events_recommend;
454  PROCEDURE audit_records_recommend;
455  PROCEDURE fixed_objects_recommend;
456  
457  END dbms_preup;
458  /

Package created.

SQL> 
SQL> -- ***********************************************************************
SQL> --                         Package Body
SQL> -- ***********************************************************************
SQL> CREATE OR REPLACE PACKAGE BODY dbms_preup AS
  2  
  3  c_output_terminal        CONSTANT NUMBER := 0;
  4  c_output_file            CONSTANT NUMBER := 1;
  5  
  6  --
  7  -- Values for 'level' field
  8  --
  9  c_check_level_success    CONSTANT NUMBER := 1;
 10  c_check_level_info       CONSTANT NUMBER := 3;
 11  c_check_level_warning    CONSTANT NUMBER := 2;
 12  c_check_level_error      CONSTANT NUMBER := 4;
 13  c_check_level_recommend  CONSTANT NUMBER := 5;
 14  
 15  c_check_level_warning_txt   CONSTANT VARCHAR2(7)  := 'WARNING';
 16  c_check_level_error_txt     CONSTANT VARCHAR2(5)  := 'ERROR';
 17  c_check_level_info_txt      CONSTANT VARCHAR2(4)  := 'INFO';
 18  c_check_level_success_txt   CONSTANT VARCHAR2(7)  := 'SUCCESS';
 19  c_check_level_recommend_txt CONSTANT VARCHAR2(16) := 'RECOMMENDATION';
 20  
 21  
 22  c_dbua_detail_type_sql   CONSTANT VARCHAR2(3) := 'SQL';
 23  c_dbua_detail_type_text  CONSTANT VARCHAR2(4) := 'TEXT';
 24  
 25  c_dbua_fixup_type_auto   CONSTANT VARCHAR2(4) := 'AUTO';
 26  c_dbua_fixup_type_manual CONSTANT VARCHAR2(6) := 'MANUAL';
 27  c_dbua_fixup_stage_pre   CONSTANT VARCHAR2(11):= 'PRE_UPGRADE';
 28  c_dbua_fixup_stage_post  CONSTANT VARCHAR2(12):= 'POST_UPGRADE';
 29  c_dbua_fixup_stage_validation   CONSTANT VARCHAR2(11):= 'VALIDATION';
 30  
 31  --
 32  -- Can't used this for declaring strings but can for length
 33  -- checks
 34  --
 35  c_str_max                CONSTANT NUMBER := 4000;
 36  
 37  --
 38  -- Record types
 39  --
 40  
 41  TYPE cursor_t  IS REF CURSOR;
 42  
 43  TYPE minvalue_record_t IS RECORD (
 44    name     VARCHAR2(80),
 45    minvalue NUMBER,
 46    oldvalue NUMBER,
 47    newvalue NUMBER,
 48    display  BOOLEAN,
 49    diff     NUMBER  -- the positive diff of 'oldvalue - minvalue' if
 50                     -- sga_target or memory_target is used
 51  );
 52  
 53  TYPE minvalue_table_t IS TABLE of minvalue_record_t
 54     INDEX BY BINARY_INTEGER;
 55  
 56  minvp_db32   minvalue_table_t;
 57  minvp_db64   minvalue_table_t;
 58  max_minvp    BINARY_INTEGER;
 59  
 60  --
 61  -- These are all indexes into the
 62  -- minvp arrays for the given pools
 63  --
 64  sp_idx BINARY_INTEGER;  -- shared_pool_size
 65  jv_idx BINARY_INTEGER;  -- java_pool_size
 66  tg_idx BINARY_INTEGER;  -- sga_target
 67  cs_idx BINARY_INTEGER;  -- cache_size
 68  pg_idx BINARY_INTEGER;  -- pga_aggreate_target
 69  mt_idx BINARY_INTEGER;  -- memory_target
 70  lp_idx BINARY_INTEGER;  -- large_pool_size
 71  str_idx BINARY_INTEGER; -- streams_pool_size
 72  
 73  TYPE comp_record_t IS RECORD (
 74    cid            VARCHAR2(30), -- component id
 75    cname          VARCHAR2(45), -- component name
 76    version        VARCHAR2(30), -- version
 77    status         VARCHAR2(15), -- component status
 78    schema         VARCHAR2(30), -- owner of component
 79    def_ts         VARCHAR2(30), -- name of default tablespace
 80    script         VARCHAR2(128), -- upgrade script name
 81    processed      BOOLEAN,       -- TRUE IF in the registry AND is not
 82                                  -- status REMOVING/REMOVED, OR
 83                                  -- TRUE IF will be in the registry because
 84                                  -- because cmp_info().install is TRUE
 85    install        BOOLEAN, -- TRUE if component to be installed in upgrade
 86    sys_kbytes     NUMBER,  -- upgrade size needed in system tablespace
 87    sysaux_kbytes  NUMBER,  -- upgrade size needed in sysaux tablespace
 88    def_ts_kbytes  NUMBER,  -- upgrade size needed in 'other' tablespace
 89    ins_sys_kbytes NUMBER,  -- install size needed in system tablespace
 90    ins_def_kbytes NUMBER,  -- install size needed in 'other' tablespace
 91    archivelog_kbytes   NUMBER, -- minimum archive log space per component
 92    flashbacklog_kbytes NUMBER  -- minimum flashback log size per component
 93  );
 94  TYPE comp_table_t IS TABLE of comp_record_t INDEX BY BINARY_INTEGER;
 95  cmp_info comp_table_t;      -- Table of component information
 96  
 97  
 98  -- index values for components (order as in upgrade script)
 99  catalog CONSTANT BINARY_INTEGER:=1;
100  catproc CONSTANT BINARY_INTEGER:=2;
101  javavm  CONSTANT BINARY_INTEGER:=3;
102  xml     CONSTANT BINARY_INTEGER:=4;
103  rac     CONSTANT BINARY_INTEGER:=5;
104  owm     CONSTANT BINARY_INTEGER:=6;
105  mgw     CONSTANT BINARY_INTEGER:=7;
106  aps     CONSTANT BINARY_INTEGER:=8;
107  ols     CONSTANT BINARY_INTEGER:=9;
108  dv      CONSTANT BINARY_INTEGER:=10;
109  em      CONSTANT BINARY_INTEGER:=11;
110  context CONSTANT BINARY_INTEGER:=12;
111  xdb     CONSTANT BINARY_INTEGER:=13;
112  catjava CONSTANT BINARY_INTEGER:=14;
113  ordim   CONSTANT BINARY_INTEGER:=15;
114  sdo     CONSTANT BINARY_INTEGER:=16;
115  odm     CONSTANT BINARY_INTEGER:=17;
116  wk      CONSTANT BINARY_INTEGER:=18;
117  exf     CONSTANT BINARY_INTEGER:=19;
118  rul     CONSTANT BINARY_INTEGER:=20;
119  apex    CONSTANT BINARY_INTEGER:=21;
120  xoq     CONSTANT BINARY_INTEGER:=22;
121  misc    CONSTANT BINARY_INTEGER:=23;
122  
123  max_comps      CONSTANT BINARY_INTEGER := 23;-- include components + 'misc'
124                                               -- for space calculations
125  max_components CONSTANT BINARY_INTEGER := 22;
126  
127  c_kb           CONSTANT BINARY_INTEGER := 1024;       -- 1 KB
128  c_mb           CONSTANT BINARY_INTEGER := 1048576;    -- 1 MB
129  c_gb           CONSTANT BINARY_INTEGER := 1073741824; -- 1 GB
130  
131  -- minimum size constants for tablespace sizing, in units of Kbytes and Mbytes
132  -- c_sysaux_minsz_kb : (500*1024)Kb = 500Mb -- minimum size for sysaux
133  -- c_undo_minsz_kb : (400*1024)Kb = 400Mb   -- minimum size for undo
134  -- c_incby_minsz_mb : 50Mb                  -- minimum size to increase by
135  c_sysaux_minsz_kb CONSTANT BINARY_INTEGER := 500 * c_kb;  -- (500*1024)kb =500M
136  c_undo_minsz_kb   CONSTANT BINARY_INTEGER := 400 * c_kb;  -- (400*1024)kb =400M
137  c_incby_minsz_mb  CONSTANT BINARY_INTEGER :=  50;         --  50Mb
138  
139  TYPE obsolete_record_t IS RECORD (
140    name VARCHAR2(80),
141    version  VARCHAR2(20),  -- version where is was obsolete/deprecated
142    deprecated BOOLEAN,    -- Has become Depreciated
143    db_match BOOLEAN
144  );
145  
146  TYPE obsolete_table_t IS TABLE of obsolete_record_t
147    INDEX BY BINARY_INTEGER;
148  
149  op     obsolete_table_t;
150  max_op BINARY_INTEGER;
151  
152  TYPE renamed_record_t IS RECORD (
153    oldname VARCHAR2(80),
154    newname VARCHAR2(80),
155    db_match BOOLEAN
156  );
157  
158  TYPE renamed_table_t IS TABLE of renamed_record_t
159    INDEX BY BINARY_INTEGER;
160  
161  rp      renamed_table_t;
162  max_rp  BINARY_INTEGER;
163  
164  TYPE special_record_t IS RECORD (
165    oldname      VARCHAR2(80),
166    oldvalue     VARCHAR2(80),
167    newname      VARCHAR2(80),
168    newvalue     VARCHAR2(80),
169    dbua_OutInUpdate BOOLEAN,
170    db_match     BOOLEAN
171  );
172  
173  TYPE special_table_t IS TABLE of special_record_t
174    INDEX BY BINARY_INTEGER;
175  
176  sp      special_table_t;
177  max_sp  BINARY_INTEGER;
178  
179  TYPE required_record_t IS RECORD (
180    name     VARCHAR2(80),
181    newnumbervalue NUMBER,
182    newstringvalue VARCHAR2(4000),
183    type NUMBER,
184    db_match BOOLEAN
185  );
186  
187  TYPE required_table_t IS TABLE of required_record_t
188    INDEX BY BINARY_INTEGER;
189  
190  reqp      required_table_t;
191  max_reqp  BINARY_INTEGER;
192  
193  TYPE tablespace_record_t IS RECORD (
194    name    VARCHAR2(128), -- tablespace name
195    inuse   NUMBER,        -- kbytes inuse in tablespace
196    alloc   NUMBER,        -- kbytes allocated to tbs
197    auto    NUMBER,        -- autoextend kbytes available
198    avail   NUMBER,        -- total kbytes available
199    delta   NUMBER,        -- kbytes required for upgrade
200    inc_by  NUMBER,        -- kbytes to increase tablespace by
201    min     NUMBER,        -- minimum required kbytes to perform upgrade
202    addl    NUMBER,        -- additional space allocated during upgrade
203    fname   VARCHAR2(513), -- filename in tablespace
204    fauto   BOOLEAN,       -- TRUE if there is a file to increase autoextend
205    temporary BOOLEAN,     -- TRUE if Temporary tablespace
206    localmanaged BOOLEAN   -- TRUE if locally managed temporary tablespace
207                           -- FALSE if dictionary managed temp tablespace
208  );
209  
210  TYPE tablespace_table_t IS TABLE OF tablespace_record_t
211     INDEX BY BINARY_INTEGER;
212  
213  ts_info tablespace_table_t; -- Tablespace information
214  max_ts  BINARY_INTEGER; -- Total number of relevant tablespaces
215  
216  
217  TYPE rollback_record_t IS RECORD (
218    tbs_name VARCHAR2(30), -- tablespace name
219    seg_name VARCHAR2(30), -- segment name
220    status   VARCHAR(30),  -- online or offline
221    inuse    NUMBER, -- kbytes in use
222    next     NUMBER, -- kbytes in NEXT
223    max_ext  NUMBER, -- max extents
224    auto     NUMBER  -- autoextend available for tablespace
225  );
226  
227  TYPE rollback_table_t IS TABLE of rollback_record_t
228    INDEX BY BINARY_INTEGER;
229  
230  rs_info    rollback_table_t;  -- Rollback segment information
231  max_rs     BINARY_INTEGER; -- Total number of public rollback segs
232  
233  TYPE fb_record_t IS RECORD (
234    active         BOOLEAN,       -- ON or OFF
235    file_dest      VARCHAR2(1000), -- db_recovery_file_dest
236    dsize          NUMBER,        -- db_recovery_file_dest_size
237    name           VARCHAR2(513), -- name
238    limit          NUMBER,        -- space limit
239    used           NUMBER,        -- Used
240    reclaimable    NUMBER,
241    files          NUMBER         -- number of files
242  );
243  flashback_info fb_record_t;
244  
245  --
246  -- Have we initialized the package?
247  --
248  p_package_inited   BOOLEAN := FALSE;
249  
250  --
251  -- Specifics about the DB being checked
252  --
253  
254  db_name             VARCHAR2(256);
255  db_compat           VARCHAR2(30);
256  db_version          VARCHAR2(30);     -- Complete version
257  db_major_vers       VARCHAR2(12);    -- Major vers xx.n.n
258  db_patch_vers       VARCHAR2(12);    -- include patch
259  db_n_version        BINARY_INTEGER;  -- Numeric version of db_version
260  db_compat_majorver  NUMBER;
261  
262  db_is_XE            BOOLEAN  := FALSE;
263  db_VLM_enabled      BOOLEAN  := FALSE;
264  
265  db_64bit            BOOLEAN := FALSE;
266  db_platform         VARCHAR2(128);
267  db_platform_id      NUMBER;
268  db_block_size       NUMBER;
269  db_undo             VARCHAR(128);
270  db_undo_tbs         VARCHAR(128);
271  db_flashback_on     BOOLEAN := FALSE;
272  db_log_mode         VARCHAR2(30);
273  db_memory_target    BOOLEAN := FALSE;
274  db_inplace_upgrade  BOOLEAN := FALSE;
275  db_invalid_state    BOOLEAN := FALSE;  -- If the DB is not in OPEN state
276  db_readonly         BOOLEAN := FALSE;
277  db_tz_version       NUMBER := 0;
278  
279  db_cpus             NUMBER;     -- Number of CPUs
280  db_cpu_threads      NUMBER;     -- Threads per CPU
281  --
282  -- A few stand-along values that we report
283  --
284  pMinFlashbackLogGen  NUMBER;
285  pminArchiveLogGen    NUMBER;
286  
287  --
288  -- Setup in init_package depending on platform
289  --
290  crlf            VARCHAR(2);
291  --
292  -- Header, centered, with "*" in it, setup in
293  -- init routine.
294  --
295  pStarHeader      VARCHAR2(80);
296  pActionRequired  VARCHAR2(40) := '^^^ MANUAL ACTION REQUIRED ^^^';
297  pActionSuggested VARCHAR2(40) := '^^^ MANUAL ACTION SUGGESTED ^^^';
298  --
299  -- If we want a check routine to ONLY do a check and
300  -- not generate any script /log output
301  --
302  pCheckOnly          BOOLEAN;
303  --
304  -- Make this a package variable so some of the
305  -- resources are disabled should the package be
306  -- run on an unsupported release
307  --
308  pUnsupportedUpgrade BOOLEAN;
309  
310  --
311  -- If we are debugging the FAILURE sitiuations
312  --
313  pDBGFailCheck    BOOLEAN;  -- For specific defined _check procedures
314  pDBGFailAll      BOOLEAN;  -- For checks that are not 'formal checks'
315  pDBGAllResources BOOLEAN;  -- Dump out all the resources as failures
316  pDBGSizeResources  BOOLEAN;  -- For Tablespace resource info
317  
318  pOutputType      NUMBER := c_output_text;
319  pOutputDest      NUMBER := c_output_terminal;
320  
321  --
322  -- Used when outputting to file
323  --
324  pOutputUFT       UTL_FILE.FILE_TYPE;     -- UTL_FILE File Type
325  pOutputFName     VARCHAR2(512) := NULL;
326  pOutputLocation  VARCHAR2(512) := NULL;  -- directory object
327  pOutputVerified  BOOLEAN;
328  
329  --
330  -- Used for outputting sql scripts
331  --
332  pPreScriptUFT     UTL_FILE.FILE_TYPE;
333  pPostScriptUFT    UTL_FILE.FILE_TYPE;
334  pPreScriptFname  VARCHAR2(512) := c_pre_script_fn;
335  pPostScriptFname VARCHAR2(512) := c_post_script_fn;
336  
337  pOutputtingScripts BOOLEAN       := FALSE;
338  
339  pCreatedDirObj   BOOLEAN       := TRUE;  -- Assume we will be creating/cleaning up
340  
341  --
342  -- Declares of local functions/procedures
343  --
344  --
345  -- Init all the checks and package variables,
346  -- If not called before a 'check' routine, will be
347  -- called automaticlly.
348  --
349  PROCEDURE init_package;
350  PROCEDURE init_preupchecks;
351  PROCEDURE init_preuprecommend;
352  PROCEDURE init_initparams;
353  PROCEDURE init_params;
354  PROCEDURE init_components;
355  PROCEDURE init_resources;
356  
357  PROCEDURE define_check (
358          idx IN OUT NUMBER,
359          name VARCHAR2,
360          check_level NUMBER,
361          descript VARCHAR2);
362  
363  FUNCTION getHelp (
364          name     IN VARCHAR2,
365          helpType IN  NUMBER) RETURN VARCHAR2;
366  
367  --
368  -- Used to generate  a valid dbua tag for a pre-up check
369  --
370  FUNCTION genDBUAXMLCheck (name VARCHAR2,
371       eseverity  NUMBER,
372       etext      VARCHAR2,
373       ecause     VARCHAR2,
374       action     VARCHAR2,
375       detailtype VARCHAR2,
376       detailinfo VARCHAR2,
377       fixuptype  VARCHAR2,
378       fixupstage VARCHAR2 ) RETURN VARCHAR2;
379  
380  PROCEDURE verifyDefaultDirObj;
381  
382  PROCEDURE store_comp (i       BINARY_INTEGER,
383                        schema  VARCHAR2,
384                        version VARCHAR2,
385                        status  NUMBER);
386  PROCEDURE store_minval_dbbit  (dbbit  NUMBER,
387                                 i      IN OUT BINARY_INTEGER,
388                                 name   VARCHAR2,
389                                 minv   NUMBER);
390  PROCEDURE store_minvalue (i     BINARY_INTEGER,
391                            name  VARCHAR2,
392                            minv  NUMBER,
393                            minvp IN OUT MINVALUE_TABLE_T);
394  PROCEDURE store_oldval (minvp  IN OUT MINVALUE_TABLE_T);
395  PROCEDURE store_renamed (i   IN OUT BINARY_INTEGER,
396                           old VARCHAR2,
397                           new VARCHAR2);
398  PROCEDURE store_removed (i IN OUT BINARY_INTEGER,
399                           name       VARCHAR2,
400                           version    VARCHAR2,
401                           deprecated BOOLEAN);
402  PROCEDURE store_special (i    IN OUT BINARY_INTEGER,
403                           old  VARCHAR2,
404                           oldv VARCHAR2,
405                           new  VARCHAR2,
406                           newv VARCHAR2);
407  PROCEDURE store_required (i    IN OUT BINARY_INTEGER,
408                           name  VARCHAR2,
409                           newvn NUMBER,
410                           newvs VARCHAR2,
411                           dtype NUMBER);
412  FUNCTION pvalue_to_number (value_string VARCHAR2) RETURN NUMBER;
413  FUNCTION is_comp_tablespace (tsname VARCHAR2) RETURN BOOLEAN;
414  FUNCTION ts_is_SYS_temporary (tsname VARCHAR2) RETURN BOOLEAN;
415  FUNCTION ts_has_queues (tsname VARCHAR2) RETURN BOOLEAN;
416  PROCEDURE find_newval (minvp  IN OUT MINVALUE_TABLE_T,
417                         dbbit  NUMBER);
418  PROCEDURE find_sga_mem_values (minvp  IN OUT MINVALUE_TABLE_T,
419                                 dbbit  NUMBER);
420  
421  FUNCTION CenterLine (line IN VARCHAR2) RETURN VARCHAR2;
422  FUNCTION htmlentities (intxt varchar2) RETURN VARCHAR2;
423  
424  
425  -- ****************************************************************
426  --         Start of Code
427  -- ****************************************************************
428  
429  --
430  -- Used to execute a sql statement (for a fixup)
431  -- Errors are returned in sqlerrtxt and sqlerrcode
432  --
433  FUNCTION execute_sql_statement (
434             statement VARCHAR2,
435             sqlerrtxt IN OUT VARCHAR2,
436             sqlerrcode IN OUT NUMBER) RETURN NUMBER
437  IS
438  ret_val NUMBER := c_fixup_status_success;
439  
440  BEGIN
441    BEGIN
442      EXECUTE IMMEDIATE statement;
443      EXCEPTION WHEN OTHERS THEN
444         sqlerrtxt := SQLERRM;
445         sqlerrcode := SQLCODE;
446         ret_val := c_fixup_status_failure;
447    END;
448    RETURN (ret_val);
449  END execute_sql_statement;
450  
451  FUNCTION get_version RETURN VARCHAR2
452  IS
453  BEGIN
454    return(dbms_preup.c_version);
455  END get_version;
456  
457  FUNCTION run_all_checks RETURN NUMBER
458  IS
459    checks_run NUMBER := 0;
460  BEGIN
461    init_package;
462  
463    FOR i IN 1..pCheckCount LOOP
464      IF check_table(i).type = c_type_check OR
465         check_table(i).type = c_type_check_interactive_only THEN
466        --
467        -- Only non-recommended checks
468        --
469        check_table(i) := run_check (check_table(i).name);
470        checks_run := checks_run + 1;
471  
472        IF (check_table(i).passed = FALSE) THEN
473          IF (check_table(i).level = c_check_level_error) THEN
474            pCheckErrorCount := pCheckErrorCount + 1;
475          ELSIF (check_table(i).level = c_check_level_warning) THEN
476            pCheckWarningCount := pCheckWarningCount + 1;
477          ELSIF (check_table(i).level = c_check_level_info) THEN
478            pCheckInfoCount := pCheckInfoCount + 1;
479          -- There can be 'success' status, no count of those is needed.
480          END IF;
481        END IF;
482      END IF;
483    END LOOP;
484    return (checks_run);
485  END run_all_checks;
486  
487  PROCEDURE run_all_recommend (whatType NUMBER)
488  IS
489  BEGIN
490    init_package;
491  
492    FOR i IN 1..pCheckCount LOOP
493      IF check_table(i).type = whatType THEN
494        -- Only run the recommend checks
495        check_table(i) := run_recommend (check_table(i).name);
496      END IF;
497    END LOOP;
498  END run_all_recommend;
499  
500  FUNCTION run_recommend (check_name VARCHAR2) RETURN check_record_t
501  IS
502    execute_failed BOOLEAN := FALSE;
503    idx            NUMBER;
504    retval         NUMBER;
505    check_stmt     VARCHAR2(100);
506    r_text         VARCHAR2(1000);
507  
508  BEGIN
509    init_package;
510  
511    IF check_names.EXISTS(check_name) = FALSE
512    THEN
513      EXECUTE IMMEDIATE 'BEGIN
514        RAISE_APPLICATION_ERROR (-20000,
515              ''Pre-Upgrade Package Requested Check does not exist''); END;';
516        return (NULL);
517    END IF;
518    idx := check_names(check_name).idx;
519  
520    IF check_table(idx).always_fail THEN
521      --
522      -- We want to fail this check, set the global
523      -- so the package checks know to fail
524      --
525      pDBGFailCheck := TRUE;
526    END IF;
527  
528    --
529    -- This executes the check procedure
530    -- An example would be
531    --
532    --  BEGIN dictionary_stats_recommend; END;
533    --
534  
535    check_stmt := 'BEGIN dbms_preup.'
536       || dbms_assert.simple_sql_name(check_table(idx).f_name_prefix)
537       ||  '_recommend; END;';
538  
539    BEGIN
540      EXECUTE IMMEDIATE check_stmt;
541      EXCEPTION WHEN OTHERS THEN
542        execute_failed := TRUE;
543    END;
544  
545    --
546    -- Save away the results of the check
547    --
548    check_table(idx).executed := TRUE;
549  
550    if execute_failed = TRUE
551    THEN
552      check_table(idx).execute_failed := TRUE;
553    ELSE
554      check_table(idx).passed := TRUE;
555    END IF;
556    --
557    -- Always turn this off
558    --
559    pDBGFailCheck := FALSE;
560    return (check_table(idx));
561  END run_recommend;
562  
563  -------------------------------  boolval  -------------------------------------
564  FUNCTION boolval (p boolean,
565                    trueval VARCHAR2,
566                    falseval VARCHAR2) return varchar2
567  IS
568  --
569  -- Return truval if the bool is TRUE otherwise return falseval
570  -- Usage: boolval(somebool, 'Yes', 'No')
571  --        boolval(somebool, 'On', 'Off')
572  --        boolval(somebool, 'True', 'False')
573  BEGIN
574     if p = TRUE THEN
575        return trueval;
576     ELSE
577        return falseval;
578     END IF;
579  END boolval;
580  
581  PROCEDURE dump_check_rec (p_check_rec check_record_t)
582  IS
583  BEGIN
584    DisplayLine ('-------- CHECK RECORD ------');
585    DisplayLine ('Name:          ' || p_check_rec.name);
586    DisplayLine ('Description:   ' || p_check_rec.descript);
587    DisplayLine ('Name Prefix:   ' || p_check_rec.f_name_prefix);
588    IF    (p_check_rec.type = c_type_check) THEN
589      DisplayLine ('Type:          ' || 'Normal');
590    ELSIF (p_check_rec.type = c_type_check_interactive_only) THEN
591      DisplayLine ('Type:          ' || 'Manual Only');
592    ELSIF (p_check_rec.type = c_type_recommend_pre) THEN
593      DisplayLine ('Type:          ' || 'Pre Upgrade Recommend');
594    ELSIF (p_check_rec.type = c_type_recommend_post) THEN
595      DisplayLine ('Type:          ' || 'Post Upgrade Recommend');
596    ELSE
597      DisplayLine ('Type:          ' || 'UNKNOWN: ' || p_check_rec.type);
598    END IF;
599    DisplayLine ('Passed:        ' || boolval(p_check_rec.passed, 'Yes', 'No'));
600    DisplayLine ('Skipped:       ' || boolval(p_check_rec.skipped, 'Yes', 'No'));
601    DisplayLine ('Fix Type:      ' || p_check_rec.fix_type);
602    DisplayLine ('Executed:      ' || boolval(p_check_rec.executed, 'Yes', 'No'));
603  
604    if p_check_rec.fixup_executed AND p_check_rec.fixup_failed THEN
605      DisplayLine ('Execute Fail:  -- Fixup Attempted --');
606    ELSE
607      DisplayLine ('Execute Fail:  ' || boolval(p_check_rec.execute_failed, 'Yes', 'No'));
608    END IF;
609    DisplayLine ('Versions:      ' || p_check_rec.valid_versions);
610    DisplayLine ('Fixup Executed:' || boolval(p_check_rec.fixup_executed, 'Yes', 'No'));
611    DisplayLine ('Fixup Fail:    ' || boolval(p_check_rec.execute_failed, 'Yes', 'No'));
612    DisplayLine ('Text:          ' || p_check_rec.result_text);
613    DisplayLine ('SQLCODE:       ' || TO_CHAR(p_check_rec.sqlcode));
614    DisplayLine ('----------------------------');
615  
616  END dump_check_rec;
617  
618  FUNCTION getHelp (
619          name     IN VARCHAR2,
620          helpType IN  NUMBER) RETURN VARCHAR2
621  IS
622  --
623  -- Use this to get back the help text (English only)
624  -- for a specific check.  The helpType is either
625  -- c_help_overview for an overview of what the check does or
626  -- c_help_fixup which describes what the fixup would do
627  --
628    idx         NUMBER;
629    rhelp       VARCHAR2(2000);
630    estatement  VARCHAR2(200);
631  BEGIN
632    IF check_names.EXISTS(name) = FALSE THEN
633      return 'WARNING - CHECK ' || name || ' does not exist';
634    END IF;
635    idx := check_names(name).idx;
636    estatement := 'BEGIN :r1 := dbms_preup.'
637             || dbms_assert.simple_sql_name(check_table(idx).f_name_prefix)
638             || '_gethelp (:helpType); END;';
639    EXECUTE IMMEDIATE estatement
640      USING OUT rhelp, IN helpType;
641    return rhelp;
642  END getHelp;
643  
644  PROCEDURE define_check (
645          idx IN OUT NUMBER,
646          name VARCHAR2,
647          check_level NUMBER,
648          descript VARCHAR2)
649  IS
650  BEGIN
651    --
652    -- Setup the check_name array
653    --
654    check_names(name).idx           := idx;
655  
656    check_table(idx).name           := name;
657    check_table(idx).descript       := descript;
658    -- Default values
659    check_table(idx).type           := c_type_check;
660    check_table(idx).f_name_prefix  := name;
661    check_table(idx).valid_versions := 'ALL';
662    check_table(idx).level          := check_level;
663    -- Assume all fixable on source side, auto
664    check_table(idx).fix_type       := c_fix_source_auto;
665    check_table(idx).passed         := FALSE;
666    check_table(idx).skipped        := FALSE;
667    check_table(idx).executed       := FALSE;
668    check_table(idx).execute_failed := FALSE;
669    check_table(idx).fixup_executed := FALSE;
670    check_table(idx).fixup_failed   := FALSE;
671    check_table(idx).always_fail    := FALSE;
672    idx := idx + 1;
673  END define_check;
674  
675  
676  -- *******************************************************************
677  --    Init package variables used throughout the package
678  -- *******************************************************************
679  PROCEDURE init_package
680  IS
681    tmp_bool        BOOLEAN;
682    c_value         VARCHAR2(80);
683    t_db_prev_vers  VARCHAR2(30);
684    t_db_dict_vers  VARCHAR2(30);
685    tmp_varchar1    VARCHAR2(512);
686    tmp_varchar4    VARCHAR2(4000);   -- Max from any query we do
687    p_count         INTEGER;
688  
689  BEGIN
690  
691    IF p_package_inited THEN
692      RETURN;
693    END IF;
694  
695    pCheckOnly      := FALSE;
696    pDBGFailCheck   := FALSE;
697    pDBGFailAll     := FALSE;
698  
699    pDBGSizeResources := FALSE;
700    pCheckErrorCount   := 0;
701    pCheckWarningCount := 0;
702    pCheckInfoCount    := 0;
703    --
704    -- Used all over the place for output
705    --
706    pStarHeader := CenterLine ('*****************************************');
707  
708    -- Check for SYSDBA
709    SELECT USER INTO tmp_varchar1 FROM SYS.DUAL;
710    IF tmp_varchar1 != 'SYS' THEN
711      EXECUTE IMMEDIATE 'BEGIN
712         RAISE_APPLICATION_ERROR (-20000,
713            ''These functions must be run AS SYSDBA''); END;';
714    END IF;
715  
716    EXECUTE IMMEDIATE 'SELECT name    FROM v$database' INTO db_name;
717    EXECUTE IMMEDIATE 'SELECT version FROM v$instance' INTO db_version;
718  
719    EXECUTE IMMEDIATE 'SELECT value   FROM v$parameter WHERE name = ''compatible'''
720       INTO db_compat;
721  
722    EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE name = ''db_block_size'''
723       INTO db_block_size;
724    EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE name = ''undo_management'''
725         INTO db_undo;
726    EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE name = ''undo_tablespace'''
727         INTO db_undo_tbs;
728    --
729    -- Flashback on can have several 'on' states, but only one 'off' so check
730    -- for NO.
731    -- Put inside begin/end to catch execution on pre 10.x DB's where undo_tablespace
732    -- is not defined yet.
733    --
734    p_count := 0;
735    BEGIN
736      EXECUTE IMMEDIATE 'SELECT count(*) FROM v$database  WHERE flashback_on = ''NO'''
737        INTO p_count;
738      EXCEPTION WHEN OTHERS THEN NULL;
739    END;
740  
741    IF p_count <= 0 THEN
742      db_flashback_on := TRUE;
743    END IF;
744  
745    EXECUTE IMMEDIATE 'SELECT LOG_MODE from v$database'
746       INTO db_log_mode;
747  
748    IF db_undo != 'AUTO' OR db_undo_tbs IS NULL THEN
749      db_undo_tbs := 'NO UNDO TBS';  -- undo tbs is not in use
750    END IF;
751  
752    EXECUTE IMMEDIATE 'SELECT platform_id, platform_name
753             FROM v$database'
754    INTO db_platform_id, db_platform;
755    IF db_platform_id NOT IN (1,7,10,15,16,17) THEN
756      db_64bit := TRUE;
757    END IF;
758  
759    db_major_vers := SUBSTR (db_version, 1,6); -- First three digits
760    db_patch_vers := SUBSTR (db_version, 1,8); -- Include 4th digit
761  
762    db_compat_majorver := TO_NUMBER(SUBSTR(db_compat,1,2));
763  
764    IF db_major_vers = '10.2.0'    THEN
765      db_n_version := 102;
766    ELSIF db_major_vers = '11.1.0' THEN
767      db_n_version := 111;
768    ELSIF db_major_vers = '11.2.0' THEN
769      db_n_version := 112;
770    ELSIF db_major_vers = '12.1.0' THEN
771      db_n_version := 121;
772    END IF;
773  
774  
775    IF ( (instr (c_supported_versions, db_patch_vers) = 0) OR
776           (db_major_vers = SUBSTR (c_version, 1,6))) THEN
777      --
778      -- Didn't find this DB's version in the supported list
779      -- However, if the major version matches the c_version
780      -- for this script, this may be a re-run etc so let the tool run.
781      -- Note using substr, instead of hard-coding '121' avoids
782      -- errors while versions are updated.
783      --
784      pUnsupportedUpgrade := TRUE;
785    ELSE
786      pUnsupportedUpgrade := FALSE;
787    END IF;
788  
789    EXECUTE IMMEDIATE 'SELECT open_mode FROM sys.v$database' INTO tmp_varchar1;
790    IF tmp_varchar1 = 'READ ONLY' THEN
791      db_readonly := TRUE;
792    END IF;
793  
794    EXECUTE IMMEDIATE 'SELECT value FROM sys.v$parameter WHERE name = ''cpu_count'''
795          INTO tmp_varchar1;
796    db_cpus := to_number (tmp_varchar1);
797  
798    EXECUTE IMMEDIATE
799       'SELECT value FROM v$parameter WHERE name = ''parallel_threads_per_cpu'''
800    INTO tmp_varchar1;
801    db_cpu_threads := pvalue_to_number(tmp_varchar1);
802  
803    BEGIN
804      EXECUTE IMMEDIATE
805         'SELECT edition FROM sys.registry$ WHERE cid=''CATPROC'''
806         INTO tmp_varchar1;
807        IF tmp_varchar1 = 'XE' THEN
808           db_is_XE := TRUE;
809        END IF; -- XE edition
810    EXCEPTION
811        WHEN OTHERS THEN NULL;  -- no edition column
812    END;
813  
814    EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE name = ''use_indirect_data_buffers'''
815         INTO tmp_varchar1;
816    IF tmp_varchar1 = 'TRUE'
817    THEN
818      db_VLM_enabled := TRUE;
819    END IF;
820  
821    --
822    -- Make sure we are in OPEN state
823  
824    EXECUTE IMMEDIATE 'SELECT status FROM V$INSTANCE'
825    INTO tmp_varchar1;
826    IF tmp_varchar1 NOT IN ('OPEN', 'OPEN MIGRATE') THEN
827      db_invalid_state := TRUE;
828    END IF;
829  
830    --
831    -- Time zone data
832    --
833    EXECUTE IMMEDIATE 'SELECT version from v$timezone_file'
834      INTO db_tz_version;
835  
836    --
837    -- Call procedure to fixup timezone info (if needed)
838    --
839  
840    tz_fixup (FALSE);
841  
842    IF db_patch_vers = c_version THEN
843      --
844      -- This block will reset db_major_vers to the value
845      -- in prv_version from registry$ - this allows the
846      -- comparision checks to behave correctly.
847      --
848      BEGIN
849        EXECUTE IMMEDIATE 'SELECT version, prv_version FROM sys.registry$
850                 WHERE cid = ''CATPROC'''
851        INTO t_db_dict_vers, t_db_prev_vers;
852  
853        IF t_db_dict_vers = db_version THEN
854          IF t_db_prev_vers != '' THEN
855            --
856            -- If prev vers is '', the DB
857            -- was never upgraded, so not really a re-run
858            --
859            db_major_vers := substr(t_db_prev_vers,1,6);   -- use prev catproc version
860          END IF;
861        ELSE
862          db_inplace_upgrade := TRUE;
863          db_major_vers  := substr(t_db_dict_vers,1,6);   -- use CATPROC version
864          db_version := t_db_dict_vers;
865        END IF;
866  
867      EXCEPTION
868         WHEN NO_DATA_FOUND THEN NULL; -- registry$ exists, but no CATPROC entry
869      END;
870    END IF;
871  
872    --
873    -- Set the newline depending on platform
874    --
875    IF INSTR(db_platform, 'WINDOWS') != 0 THEN
876      crlf := CHR(13) || CHR(10);       -- Windows gets the \r and \n
877    ELSE
878      crlf := CHR (10);                 -- Just \n for the rest of the world
879    END IF;
880  
881    init_initparams;
882    init_components;
883  
884    init_params;  -- Named params, not init params
885  
886    -- Process required data
887  
888    FOR i IN 1..max_reqp LOOP
889      BEGIN
890        EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE name =
891                :1 AND isdefault = ''TRUE'''
892           INTO c_value
893        USING reqp(i).name;
894        IF reqp(i).name = 'undo_management' THEN
895          --
896          -- Starting in 11.1, undo_management default is changed
897          -- from MANUAL to AUTO.
898          --
899          IF db_n_version = 102 THEN
900            reqp(i).db_match := TRUE;
901          END IF;
902        END IF;
903      EXCEPTION WHEN NO_DATA_FOUND THEN
904         reqp(i).db_match := FALSE;
905      END;
906    END LOOP;
907  
908    -- Find values for initialization parameters with minimum values
909    -- Convert to numeric values
910    store_oldval(minvp_db32);
911    store_oldval(minvp_db64);
912  
913    -- determine new values for initialization parameters with minimum values
914    find_newval(minvp_db32, 32);
915    find_newval(minvp_db64, 64);
916  
917    init_resources;
918  
919    init_preupchecks;
920  
921    init_preuprecommend;
922  
923    p_package_inited := TRUE;
924  
925  END init_package;
926  
927  PROCEDURE init_preupchecks
928  IS
929    i NUMBER := 1;
930  
931  BEGIN
932    -- ********************************************************
933    -- Define the pre-up checks
934    -- The order in which they are defined is the order in
935    -- which they will be executed.
936    -- ********************************************************
937  
938    define_check (i, 'UNSUPPORTED_VERSION', c_check_level_error,
939                  'Make sure we support a direct upgrade from this version');
940    check_table(check_names('UNSUPPORTED_VERSION').idx).fix_type := c_fix_source_manual;
941    -- DBUA does their own.
942    check_table(check_names('UNSUPPORTED_VERSION').idx).type    := c_type_check_interactive_only;
943  
944    define_check (i, 'DEFAULT_PROCESS_COUNT', c_check_level_warning,
945                  'Verify min process count is not too low');
946    check_table(i-1).fix_type := c_fix_source_manual;
947    -- DBUA does their own.
948    check_table(i-1).type    := c_type_check_interactive_only;
949  
950    define_check (i, 'COMPATIBLE_PARAMETER', c_check_level_error,
951                  'Verify compatible parameter value is valid');
952    check_table(i-1).fix_type := c_fix_source_manual;
953    check_table(i-1).type    := c_type_check_interactive_only;
954  
955    define_check (i, 'OLS_SYS_MOVE', c_check_level_error,
956                  'Check if SYSTEM.AUD$ needs to move to SYS.AUD$ before upgrade');
957    check_table(i-1).fix_type := c_fix_source_manual;
958  
959    define_check (i, 'OCM_USER_PRESENT', c_check_level_warning,
960                  'Check for OCM schema');
961    define_check (i, 'APPQOSSYS_USER_PRESENT', c_check_level_warning,
962                  'Check for APPQOSSYS schema');
963  
964    define_check (i, 'AUDSYS_USER_PRESENT', c_check_level_error,
965                  'Verify if a user or role with the name AUDSYS exists');
966    check_table(i-1).valid_versions := '102,111,112';
967    check_table(i-1).fix_type := c_fix_source_manual;
968  
969    define_check (i, 'AUDIT_ADMIN_ROLE_PRESENT', c_check_level_error,
970                  'Verify if a user or role with the name AUDIT_ADMIN exists');
971    check_table(i-1).f_name_prefix := 'AAR_PRESENT';
972    check_table(i-1).valid_versions := '102,111,112';
973    check_table(i-1).fix_type := c_fix_source_manual;
974  
975    define_check (i, 'AUDIT_VIEWER', c_check_level_error,
976                  'Verify if a user or role with the name AUDIT_VIEWER exists');
977    check_table(i-1).valid_versions := '102,111,112';
978    check_table(i-1).fix_type := c_fix_source_manual;
979  
980    define_check (i, 'SYSBACKUP_USER_PRESENT', c_check_level_error,
981                  'Verify if a user or role with the name SYSBACKUP exists');
982    check_table(i-1).valid_versions := '102,111,112';
983    check_table(i-1).fix_type := c_fix_source_manual;
984  
985    define_check (i, 'SYSDG_USER_PRESENT', c_check_level_error,
986                  'Verify if a user or role with the name SYSDG exists');
987    check_table(i-1).valid_versions := '102,111,112';
988    check_table(i-1).fix_type := c_fix_source_manual;
989  
990    define_check (i, 'SYSKM_USER_PRESENT', c_check_level_error,
991                  'Verify if a user or role with the name SYSKM exists');
992    check_table(i-1).valid_versions := '102,111,112';
993    check_table(i-1).fix_type := c_fix_source_manual;
994  
995    define_check (i, 'CAPT_ADM_ROLE_PRESENT', c_check_level_error,
996                  'Verify if a user or role with the name CAPTURE_ADMIN exists');
997    check_table(i-1).valid_versions := '102,111,112';
998    check_table(i-1).fix_type := c_fix_source_manual;
999  
1000    define_check (i, 'AWR_DBIDS_PRESENT', c_check_level_warning,
1001                  'Verify if AWR contains inactive DBIDs');
1002    check_table(i-1).fix_type := c_fix_target_manual_post;
1003  
1004    define_check (i, 'DV_ENABLED', c_check_level_warning,
1005                  'Check if Database Vault is enabled');
1006    check_table(i-1).fix_type := c_fix_source_manual;
1007  
1008    define_check (i, 'EM_PRESENT', c_check_level_warning,
1009                  'Check if Enterprise Manager is present');
1010  
1011    define_check (i, 'FILES_NEED_RECOVERY', c_check_level_error,
1012                  'Check for any pending file recoveries');
1013    check_table(i-1).fix_type := c_fix_source_manual;
1014  
1015    define_check (i, 'FILES_BACKUP_MODE', c_check_level_error,
1016                  'Check for files in backup mode');
1017    check_table(i-1).fix_type := c_fix_source_manual;
1018  
1019    define_check (i, '2PC_TXN_EXIST', c_check_level_error,
1020                  'Check for unresolved distributed transactions');
1021    check_table(i-1).fix_type := c_fix_source_manual;
1022    check_table(i-1).f_name_prefix := 'pending_2pc_txn';
1023  
1024    define_check (i, 'SYNC_STANDBY_DB', c_check_level_warning,
1025                  'Check for unsynced database');
1026    check_table(i-1).fix_type := c_fix_source_manual;
1027  
1028    define_check (i, 'ULTRASEARCH_DATA', c_check_level_warning,
1029                  'Check for any UltraSearch data');
1030    check_table(i-1).fix_type := c_fix_source_manual;
1031  
1032    define_check (i, 'REMOTE_REDO', c_check_level_error,
1033                  'Check for invalid values for log_archive_dest_1');
1034    check_table(i-1).fix_type := c_fix_source_manual;
1035    check_table(i-1).valid_versions := '102, 111';
1036  
1037    define_check (i, 'SYS_DEFAULT_TABLESPACE', c_check_level_warning,
1038                  'Check that SYS/SYSTEM default tablespace is SYSTEM');
1039    check_table(i-1).f_name_prefix := 'SYS_DEF_TABLESPACE';
1040  
1041    define_check (i, 'INVALID_LOG_ARCHIVE_FORMAT', c_check_level_error,
1042                  'Check log_archive_format settings');
1043    check_table(i-1).fix_type := c_fix_source_manual;
1044    check_table(i-1).f_name_prefix := 'INVALID_LAF';
1045  
1046    define_check (i, 'INVALID_USR_TABLEDATA', c_check_level_error,
1047                  'Check for invalid (not converted) user table data');
1048    check_table(check_names('INVALID_USR_TABLEDATA').idx).fix_type :=
1049          c_fix_source_manual;
1050  
1051    define_check (i, 'INVALID_SYS_TABLEDATA', c_check_level_error,
1052                  'Check for invalid (not converted) table data');
1053    check_table(check_names('INVALID_SYS_TABLEDATA').idx).fix_type :=
1054          c_fix_source_manual;
1055  
1056    define_check (i, 'ENABLED_INDEXES_TBL', c_check_level_warning,
1057                  'Check for existance of sys.enabled$indexes table');
1058    define_check (i, 'ORDIMAGEINDEX', c_check_level_warning,
1059                  'Check for use of Oracle Multimedia image domain index');
1060    check_table(i-1).fix_type := c_fix_source_manual;
1061  
1062    define_check (i, 'DBMS_LDAP_DEPENDENCIES_EXIST', c_check_level_warning,
1063                  'Check for dependency on DBMS_LDAP package');
1064    check_table(i-1).f_name_prefix := 'DBMS_LDAP_DEP_EXIST';
1065    check_table(i-1).fix_type := c_fix_source_manual;
1066  
1067    define_check (i, 'REMOVE_DMSYS', c_check_level_warning,
1068                  'Check for existance of DMSYS schema');
1069    check_table(i-1).valid_versions := '102,111,112,121';
1070  
1071    define_check (i, 'INVALID_OBJECTS_EXIST', c_check_level_warning,
1072                  'Check for invalid objects');
1073    check_table(i-1).f_name_prefix := 'INVALID_OBJ_EXIST';
1074    check_table(i-1).fix_type := c_fix_target_manual_post;
1075  
1076    define_check (i, 'AMD_EXISTS', c_check_level_info,
1077                  'Check to see if AMD is present in the database');
1078    check_table(i-1).fix_type := c_fix_target_manual_pre;
1079    -- DBUA does their own.
1080    check_table(i-1).type    := c_type_check_interactive_only;
1081  
1082    define_check (i, 'EXF_RUL_EXISTS', c_check_level_info,
1083                  'Check to see if EXF/RUL are present in the database');
1084    check_table(i-1).fix_type := c_fix_target_manual_pre;
1085  
1086    define_check (i, 'NEW_TIME_ZONES_EXIST', c_check_level_error,
1087                  'Check for use of newer timezone data file');
1088    check_table(i-1).fix_type := c_fix_target_manual_pre;
1089  
1090    define_check (i, 'OLD_TIME_ZONES_EXIST', c_check_level_info,
1091                  'Check for use of older timezone data file');
1092    check_table(i-1).fix_type := c_fix_target_manual_post;
1093  
1094    define_check (i, 'PURGE_RECYCLEBIN', c_check_level_error,
1095                  'Check that recycle bin is empty prior to upgrade');
1096  
1097    define_check (i, 'NACL_OBJECTS_EXIST', c_check_level_warning,
1098                  'Check for Network ACL Objects in use');
1099    check_table(i-1).fix_type := c_fix_source_manual;
1100  
1101    define_check (i, 'JOB_QUEUE_PROCESS', c_check_level_warning,
1102                  'Check JOB_QUEUE_PROCESSES value');
1103    -- This check may get changed to error in the _check routine
1104    check_table(i-1).fix_type := c_fix_source_manual;
1105  
1106    -- Define RAS related pre-up checks
1107    define_check (i, 'PROVISIONER_PRESENT', c_check_level_error,
1108                  'Verify if a user or role with the name PROVISIONER exists');
1109    check_table(i-1).valid_versions := '102,111,112';
1110    check_table(i-1).fix_type := c_fix_source_manual;
1111  
1112    define_check (i, 'XS_RESOURCE_PRESENT', c_check_level_error,
1113                  'Verify if a user or role with the name XS_RESOURCE exists');
1114    check_table(i-1).valid_versions := '102,111,112';
1115    check_table(i-1).fix_type := c_fix_source_manual;
1116  
1117    define_check (i, 'XS_SESSION_ADMIN', c_check_level_error,
1118                  'Verify if a user or role with the name XS_SESSION_ADMIN exists');
1119    check_table(i-1).valid_versions := '102,111,112';
1120    check_table(i-1).fix_type := c_fix_source_manual;
1121  
1122    define_check (i, 'XS_NAMESPACE_ADMIN', c_check_level_error,
1123                  'Verify if a user or role with the name XS_NAMESPACE_ADMIN exists');
1124    check_table(i-1).valid_versions := '102,111,112';
1125    check_table(i-1).fix_type := c_fix_source_manual;
1126  
1127    define_check (i, 'XS_CACHE_ADMIN', c_check_level_error,
1128                  'Verify if a user or role with the name XS_CACHE_ADMIN exists');
1129    check_table(i-1).valid_versions := '102,111,112';
1130    check_table(i-1).fix_type := c_fix_source_manual;
1131  
1132    pCheckCount := i -1;
1133  
1134  END init_preupchecks;
1135  
1136  
1137  PROCEDURE init_preuprecommend
1138  IS
1139    --
1140    -- Always start with the existing pCheckCount
1141    --
1142    i NUMBER := pCheckCount + 1;
1143  
1144  BEGIN
1145  
1146    -- ********************************************************
1147    -- Define the pre-up recommendations
1148    -- ********************************************************
1149    define_check (i, 'DICTIONARY_STATS', c_check_level_recommend,
1150                  'Gather Dictionary Stats prior to upgrade');
1151    check_table(i-1).type := c_type_recommend_pre;
1152    define_check (i, 'HIDDEN_PARAMS',  c_check_level_recommend,
1153                  'Check for any hidden params defined');
1154    check_table(i-1).type := c_type_recommend_pre;
1155    define_check (i, 'UNDERSCORE_EVENTS',  c_check_level_recommend,
1156                  'Check for any underscore events that are defined');
1157    check_table(i-1).type := c_type_recommend_pre;
1158    define_check (i, 'AUDIT_RECORDS',  c_check_level_recommend,
1159                  'Recommend purging audit records');
1160    check_table(i-1).type := c_type_recommend_pre;
1161    define_check (i, 'FIXED_OBJECTS',  c_check_level_recommend,
1162                  'Recommend running stats on fixed objects');
1163    check_table(i-1).type := c_type_recommend_post;
1164    pCheckCount := i -1;
1165  
1166  END init_preuprecommend;
1167  
1168  
1169  PROCEDURE init_initparams
1170  IS
1171    t_null          CHAR(1);
1172    idx             BINARY_INTEGER;
1173  BEGIN
1174  
1175    -- determine if memory_target value is set
1176    BEGIN
1177      EXECUTE IMMEDIATE 'SELECT NULL FROM v$parameter WHERE name=''memory_target'''
1178        INTO t_null;
1179         db_memory_target := TRUE;
1180    EXCEPTION
1181       WHEN NO_DATA_FOUND THEN NULL;  -- memory_target value not set
1182     END;
1183  
1184    --
1185    -- Initialize parameters with minimum values
1186    --
1187    -- the loop sets values that differ for a 32-bit db versus a 64-bit db
1188  
1189    FOR i IN 1..2 LOOP
1190  
1191      idx := 0;
1192  
1193      -- 32-bit: up sga_target 336M to 528M. up memory_target 436M to 628M.
1194      -- 64-bit: up sga_target 672M to 744M. up memory_target 836M to 844M.
1195  
1196      IF i = 1 THEN
1197        IF db_memory_target THEN
1198          store_minval_dbbit(32, idx,'memory_target', 628*c_mb); --  628 MB
1199        END IF;
1200        mt_idx := idx;
1201  
1202        -- sga_target = cs + jv + sp + lp + strp + extra :
1203        -- (12*4 + 64 + 180 + (12*2*2)*.5 + 0 + 8+32+56) -- 412MB
1204        -- (32*4 + 64 + 180 + (32*2*2)*.5 + 0 + 8+32+56) -- 532MB
1205        -- (64*4 + 64 + 180 + (64*2*2)*.5 + 0 + 8+32+56) -- 724MB
1206        store_minval_dbbit(32, idx,'sga_target',
1207             (32*4 + 64 + 180 + (32*2*2)*.5 + 0 + 8+32+56) * (c_mb)); -- 532MB
1208        tg_idx := idx;
1209  
1210        store_minval_dbbit(32, idx,'shared_pool_size',236*c_mb); -- 236 MB
1211        sp_idx := idx;
1212  
1213        store_minval_dbbit(32, idx,'java_pool_size',   64*c_mb); -- 64 MB
1214        jv_idx := idx;
1215  
1216      ELSE  -- Second case...
1217        --
1218        -- Now for 64 bit
1219  
1220        IF db_memory_target THEN
1221          store_minval_dbbit(64,idx,'memory_target', 844*c_mb); --  844 MB
1222        END IF;
1223        mt_idx := idx;
1224  
1225        -- sga_target = cs + jv + sp + lp + strp + extra :
1226        -- (12*4 + 100 + 280 + (12*2*2)*.5 + 0 + 8*2+32*2+28+20+16) -- 596M
1227        -- (32*4 + 100 + 280 + (32*2*2)*.5 + 0 + 8*2+32*2+28+20+16) -- 716M
1228        -- (64*4 + 100 + 280 + (64*2*2)*.5 + 0 + 8*2+32*2+28+20+16) -- 908M
1229        store_minval_dbbit(64, idx,'sga_target',
1230           (32*4 + 100 + 280 + 32*2 + 0 + 16+64+28+20+16) * c_mb); --716MB
1231        tg_idx := idx;
1232  
1233        store_minval_dbbit(64,idx,'shared_pool_size',472*c_mb); -- 472 MB
1234        sp_idx := idx;
1235  
1236        store_minval_dbbit(64,idx,'java_pool_size',  128*c_mb); -- 128 MB
1237        jv_idx := idx;
1238  
1239        store_minval_dbbit(0,idx,'db_cache_size',    48*c_mb); --  48 MB
1240        cs_idx := idx;
1241  
1242        store_minval_dbbit(0,idx,'pga_aggregate_target', 24*c_mb); --  24 MB
1243        pg_idx := idx;
1244  
1245        -- Added large_pool_size and streams_pool_size so that we can include these
1246        -- user-specified values (if set) for sga_target minimum caculation.
1247        -- Note that we're not making minimum recommendations for these 2 pools at
1248        -- at this time.
1249      END IF;
1250    END LOOP;
1251  
1252    store_minval_dbbit(0,idx,'large_pool_size', 0);
1253    lp_idx := idx;
1254    store_minval_dbbit(0,idx,'streams_pool_size', 0);
1255    str_idx := idx;
1256    --
1257    -- For manual mode, there is a complete preup-check for
1258    -- this.
1259    --
1260    store_minval_dbbit(0, idx,'processes', c_max_processes);
1261    max_minvp := idx;
1262  
1263  END init_initparams;
1264  
1265  PROCEDURE init_params
1266  IS
1267    i        NUMBER;
1268    tmp_num2 NUMBER;
1269    tmp_num3 NUMBER;
1270    t_null   CHAR(1);
1271    c_value  VARCHAR2(80);
1272    idx      BINARY_INTEGER;
1273  
1274  BEGIN
1275  
1276  /*
1277     To identify new obsolete and deprecated parameters, use the
1278     following queries and diff with the list from the prior release:
1279  
1280     select name from v$obsolete_parameter order by name;
1281  
1282     select name from v$parameter
1283     where isdeprecated = 'TRUE' order by name;
1284  
1285  */
1286  
1287    -- Load Obsolete and Deprecated parameters
1288  
1289    -- Obsolete initialization parameters in release 8.0 --
1290    idx:=0;
1291    store_removed(idx,'checkpoint_process', '8.0', FALSE);
1292    store_removed(idx,'fast_cache_flush', '8.0', FALSE);
1293    store_removed(idx,'gc_db_locks', '8.0', FALSE);
1294    store_removed(idx,'gc_freelist_groups', '8.0', FALSE);
1295    store_removed(idx,'gc_rollback_segments', '8.0', FALSE);
1296    store_removed(idx,'gc_save_rollback_locks', '8.0', FALSE);
1297    store_removed(idx,'gc_segments', '8.0', FALSE);
1298    store_removed(idx,'gc_tablespaces', '8.0', FALSE);
1299    store_removed(idx,'io_timeout', '8.0', FALSE);
1300    store_removed(idx,'init_sql_files', '8.0', FALSE);
1301    store_removed(idx,'ipq_address', '8.0', FALSE);
1302    store_removed(idx,'ipq_net', '8.0', FALSE);
1303    store_removed(idx,'lm_domains', '8.0', FALSE);
1304    store_removed(idx,'lm_non_fault_tolerant', '8.0', FALSE);
1305    store_removed(idx,'mls_label_format', '8.0', FALSE);
1306    store_removed(idx,'optimizer_parallel_pass', '8.0', FALSE);
1307    store_removed(idx,'parallel_default_max_scans', '8.0', FALSE);
1308    store_removed(idx,'parallel_default_scan_size', '8.0', FALSE);
1309    store_removed(idx,'post_wait_device', '8.0', FALSE);
1310    store_removed(idx,'sequence_cache_hash_buckets', '8.0', FALSE);
1311    store_removed(idx,'unlimited_rollback_segments', '8.0', FALSE);
1312    store_removed(idx,'use_readv', '8.0', FALSE);
1313    store_removed(idx,'use_sigio', '8.0', FALSE);
1314    store_removed(idx,'v733_plans_enabled', '8.0', FALSE);
1315  
1316    -- Obsolete in 8.1
1317    store_removed(idx,'allow_partial_sn_results', '8.1', FALSE);
1318    store_removed(idx,'arch_io_slaves', '8.1', FALSE);
1319    store_removed(idx,'b_tree_bitmap_plans', '8.1', FALSE);
1320    store_removed(idx,'backup_disk_io_slaves', '8.1', FALSE);
1321    store_removed(idx,'cache_size_threshold', '8.1', FALSE);
1322    store_removed(idx,'cleanup_rollback_entries', '8.1', FALSE);
1323    store_removed(idx,'close_cached_open_cursors', '8.1', FALSE);
1324    store_removed(idx,'complex_view_merging', '8.1', FALSE);
1325    store_removed(idx,'db_block_checkpoint_batch', '8.1', FALSE);
1326    store_removed(idx,'db_block_lru_extended_statistics', '8.1', FALSE);
1327    store_removed(idx,'db_block_lru_statistics', '8.1', FALSE);
1328    store_removed(idx,'db_file_simultaneous_writes', '8.1', FALSE);
1329    store_removed(idx,'delayed_logging_block_cleanouts', '8.1', FALSE);
1330    store_removed(idx,'discrete_transactions_enabled', '8.1', FALSE);
1331    store_removed(idx,'distributed_recovery_connection_hold_time', '8.1', FALSE);
1332    store_removed(idx,'ent_domain_name', '8.1', FALSE);
1333    store_removed(idx,'fast_full_scan_enabled', '8.1', FALSE);
1334    store_removed(idx,'freeze_DB_for_fast_instance_recovery', '8.1', FALSE);
1335    store_removed(idx,'gc_latches', '8.1', FALSE);
1336    store_removed(idx,'gc_lck_procs', '8.1', FALSE);
1337    store_removed(idx,'job_queue_keep_connections', '8.1', FALSE);
1338    store_removed(idx,'large_pool_min_alloc', '8.1', FALSE);
1339    store_removed(idx,'lgwr_io_slaves', '8.1', FALSE);
1340    store_removed(idx,'lm_locks', '8.1', FALSE);
1341    store_removed(idx,'lm_procs', '8.1', FALSE);
1342    store_removed(idx,'lm_ress', '8.1', FALSE);
1343    store_removed(idx,'lock_sga_areas', '8.1', FALSE);
1344    store_removed(idx,'log_archive_buffer_size', '8.1', FALSE);
1345    store_removed(idx,'log_archive_buffers', '8.1', FALSE);
1346    store_removed(idx,'log_block_checksum', '8.1', FALSE);
1347    store_removed(idx,'log_files', '8.1', FALSE);
1348    store_removed(idx,'log_simultaneous_copies', '8.1', FALSE);
1349    store_removed(idx,'log_small_entry_max_size', '8.1', FALSE);
1350    store_removed(idx,'mts_rate_log_size', '8.1', FALSE);
1351    store_removed(idx,'mts_rate_scale', '8.1', FALSE);
1352    store_removed(idx,'ogms_home', '8.1', FALSE);
1353    store_removed(idx,'ops_admin_group', '8.1', FALSE);
1354    store_removed(idx,'optimizer_search_limit', '8.1', FALSE);
1355    store_removed(idx,'parallel_default_max_instances', '8.1', FALSE);
1356    store_removed(idx,'parallel_min_message_pool', '8.1', FALSE);
1357    store_removed(idx,'parallel_server_idle_time', '8.1', FALSE);
1358    store_removed(idx,'parallel_transaction_resource_timeout', '8.1', FALSE);
1359    store_removed(idx,'push_join_predicate', '8.1', FALSE);
1360    store_removed(idx,'reduce_alarm', '8.1', FALSE);
1361    store_removed(idx,'row_cache_cursors', '8.1', FALSE);
1362    store_removed(idx,'sequence_cache_entries', '8.1', FALSE);
1363    store_removed(idx,'sequence_cache_hash_buckets', '8.1', FALSE);
1364    store_removed(idx,'shared_pool_reserved_min_alloc', '8.1', FALSE);
1365    store_removed(idx,'snapshot_refresh_interval', '8.1', FALSE);
1366    store_removed(idx,'snapshot_refresh_keep_connections', '8.1', FALSE);
1367    store_removed(idx,'snapshot_refresh_processes', '8.1', FALSE);
1368    store_removed(idx,'sort_direct_writes', '8.1', FALSE);
1369    store_removed(idx,'sort_read_fac', '8.1', FALSE);
1370    store_removed(idx,'sort_spacemap_size', '8.1', FALSE);
1371    store_removed(idx,'sort_write_buffer_size', '8.1', FALSE);
1372    store_removed(idx,'sort_write_buffers', '8.1', FALSE);
1373    store_removed(idx,'spin_count', '8.1', FALSE);
1374    store_removed(idx,'temporary_table_locks', '8.1', FALSE);
1375    store_removed(idx,'use_ism', '8.1', FALSE);
1376  
1377    -- Obsolete in 9.0.1
1378    store_removed(idx,'always_anti_join', '9.0.1', FALSE);
1379    store_removed(idx,'always_semi_join', '9.0.1', FALSE);
1380    store_removed(idx,'db_block_lru_latches', '9.0.1', FALSE);
1381    store_removed(idx,'db_block_max_dirty_target', '9.0.1', FALSE);
1382    store_removed(idx,'gc_defer_time', '9.0.1', FALSE);
1383    store_removed(idx,'gc_releasable_locks', '9.0.1', FALSE);
1384    store_removed(idx,'gc_rollback_locks', '9.0.1', FALSE);
1385    store_removed(idx,'hash_multiblock_io_count', '9.0.1', FALSE);
1386    store_removed(idx,'instance_nodeset', '9.0.1', FALSE);
1387    store_removed(idx,'job_queue_interval', '9.0.1', FALSE);
1388    store_removed(idx,'ops_interconnects', '9.0.1', FALSE);
1389    store_removed(idx,'optimizer_percent_parallel', '9.0.1', FALSE);
1390    store_removed(idx,'sort_multiblock_read_count', '9.0.1', FALSE);
1391    store_removed(idx,'text_enable', '9.0.1', FALSE);
1392  
1393    -- Obsolete in 9.2
1394    store_removed(idx,'distributed_transactions', '9.2', FALSE);
1395    store_removed(idx,'max_transaction_branches', '9.2', FALSE);
1396    store_removed(idx,'parallel_broadcast_enabled', '9.2', FALSE);
1397    store_removed(idx,'standby_preserves_names', '9.2', FALSE);
1398  
1399    -- Obsolete in 10.1 (mts_ renames commented out)
1400    store_removed(idx,'dblink_encrypt_login', '10.1', FALSE);
1401    store_removed(idx,'hash_join_enabled', '10.1', FALSE);
1402    store_removed(idx,'log_parallelism', '10.1', FALSE);
1403    store_removed(idx,'max_rollback_segments', '10.1', FALSE);
1404    store_removed(idx,'mts_listener_address', '10.1', FALSE);
1405    store_removed(idx,'mts_multiple_listeners', '10.1', FALSE);
1406    store_removed(idx,'mts_service', '10.1', FALSE);
1407    store_removed(idx,'optimizer_max_permutations', '10.1', FALSE);
1408    store_removed(idx,'oracle_trace_collection_name', '10.1', FALSE);
1409    store_removed(idx,'oracle_trace_collection_path', '10.1', FALSE);
1410    store_removed(idx,'oracle_trace_collection_size', '10.1', FALSE);
1411    store_removed(idx,'oracle_trace_enable', '10.1', FALSE);
1412    store_removed(idx,'oracle_trace_facility_name', '10.1', FALSE);
1413    store_removed(idx,'oracle_trace_facility_path', '10.1', FALSE);
1414    store_removed(idx,'partition_view_enabled', '10.1', FALSE);
1415    store_removed(idx,'plsql_native_c_compiler', '10.1', FALSE);
1416    store_removed(idx,'plsql_native_linker', '10.1', FALSE);
1417    store_removed(idx,'plsql_native_make_file_name', '10.1', FALSE);
1418    store_removed(idx,'plsql_native_make_utility', '10.1', FALSE);
1419    store_removed(idx,'row_locking', '10.1', FALSE);
1420    store_removed(idx,'serializable', '10.1', FALSE);
1421    store_removed(idx,'transaction_auditing', '10.1', FALSE);
1422    store_removed(idx,'undo_suppress_errors', '10.1', FALSE);
1423  
1424    -- Deprecated in 10.1, no new value
1425    store_removed(idx,'global_context_pool_size', '10.1', TRUE);
1426    store_removed(idx,'log_archive_start', '10.1', TRUE);
1427    store_removed(idx,'max_enabled_roles', '10.1', TRUE);
1428    store_removed(idx,'parallel_automatic_tuning', '10.1', TRUE);
1429  
1430    store_removed(idx,'_average_dirties_half_life', '10.1', TRUE);
1431    store_removed(idx,'_compatible_no_recovery', '10.1', TRUE);
1432    store_removed(idx,'_db_no_mount_lock', '10.1', TRUE);
1433    store_removed(idx,'_lm_direct_sends', '10.1', TRUE);
1434    store_removed(idx,'_lm_multiple_receivers', '10.1', TRUE);
1435    store_removed(idx,'_lm_statistics', '10.1', TRUE);
1436    store_removed(idx,'_oracle_trace_events', '10.1', TRUE);
1437    store_removed(idx,'_oracle_trace_facility_version', '10.1', TRUE);
1438    store_removed(idx,'_seq_process_cache_const', '10.1', TRUE);
1439  
1440    -- Obsolete in 10.2
1441    store_removed(idx,'enqueue_resources', '10.2', FALSE);
1442  
1443    -- Deprecated, but not renamed in 10.2
1444    store_removed(idx,'logmnr_max_persistent_sessions', '10.2', TRUE);
1445    store_removed(idx,'max_commit_propagation_delay', '10.2', TRUE);
1446    store_removed(idx,'remote_archive_enable', '10.2', TRUE);
1447    store_removed(idx,'serial_reuse', '10.2', TRUE);
1448    store_removed(idx,'sql_trace', '10.2', TRUE);
1449  
1450    -- Deprecated, but not renamed in 11.1
1451    store_removed(idx,'commit_write', '11.1', TRUE);
1452    store_removed(idx,'cursor_space_for_time', '11.1', TRUE);
1453    store_removed(idx,'instance_groups', '11.1', TRUE);
1454    store_removed(idx,'log_archive_local_first', '11.1', TRUE);
1455    store_removed(idx,'remote_os_authent', '11.1', TRUE);
1456    store_removed(idx,'sql_version', '11.1', TRUE);
1457    store_removed(idx,'standby_archive_dest', '11.1', TRUE);
1458    store_removed(idx,'plsql_v2_compatibility', '11.1', TRUE);
1459  
1460    -- Instead a new parameter diagnostic_dest is
1461    -- replace two (core_dump_dest lives)
1462    store_removed(idx,'background_dump_dest', '11.1', TRUE);
1463    store_removed(idx,'user_dump_dest', '11.1', TRUE);
1464  
1465    -- Obsolete in 11.1
1466  
1467    store_removed(idx,'_log_archive_buffer_size', '11.1', FALSE);
1468    store_removed(idx,'_fast_start_instance_recover_target', '11.1', FALSE);
1469    store_removed(idx,'_lm_rcv_buffer_size', '11.1', FALSE);
1470    store_removed(idx,'ddl_wait_for_locks', '11.1', FALSE);
1471    store_removed(idx,'remote_archive_enable', '11.1', FALSE);
1472  
1473    -- Deprecated in 11.2
1474    store_removed(idx,'active_instance_count', '11.2', TRUE);
1475    store_removed(idx,'cursor_space_for_time', '11.2', TRUE);
1476    store_removed(idx,'fast_start_io_target', '11.2', TRUE);
1477    store_removed(idx,'global_context_pool_size', '11.2', TRUE);
1478    store_removed(idx,'instance_groups', '11.2', TRUE);
1479    store_removed(idx,'lock_name_space', '11.2', TRUE);
1480    store_removed(idx,'log_archive_local_first', '11.2', TRUE);
1481    store_removed(idx,'max_commit_propagation_delay', '11.2', TRUE);
1482    store_removed(idx,'parallel_automatic_tuning', '11.2', TRUE);
1483    store_removed(idx,'parallel_io_cap_enabled', '11.2', TRUE);
1484    store_removed(idx,'resource_manager_cpu_allocation', '11.2', TRUE);
1485    store_removed(idx,'serial_reuse', '11.2', TRUE);
1486  
1487    -- Obsolete in 11.2
1488    store_removed(idx,'drs_start', '11.2', FALSE);
1489    store_removed(idx,'gc_files_to_locks', '11.2', FALSE);
1490    store_removed(idx,'plsql_native_library_dir', '11.2', FALSE);
1491    store_removed(idx,'plsql_native_library_subdir_count', '11.2', FALSE);
1492    store_removed(idx,'sql_version', '11.2', FALSE);
1493    store_removed(idx,'cell_partition_large_extents', '11.2', FALSE);
1494  
1495    -- Sessions removed for XE upgrade only
1496    IF db_is_XE THEN
1497      store_removed(idx,'sessions', '10.1', FALSE);
1498    END IF;
1499  
1500    --
1501    -- Removed for 12.1
1502    --
1503    store_removed(idx,'_lm_validate_resource_type', '12.1', TRUE);
1504    store_removed(idx,'sec_case_sensitive_logon', '12.1', TRUE);
1505    max_op := idx;
1506  
1507    -- Load Renamed parameters
1508  
1509    -- Initialization Parameters Renamed in Release 8.0 --
1510    idx:=0;
1511    store_renamed(idx,'async_read','disk_asynch_io');
1512    store_renamed(idx,'async_write','disk_asynch_io');
1513    store_renamed(idx,'ccf_io_size','db_file_direct_io_count');
1514    store_renamed(idx,'db_file_standby_name_convert','db_file_name_convert');
1515    store_renamed(idx,'db_writers','dbwr_io_slaves');
1516    store_renamed(idx,'log_file_standby_name_convert',
1517                      'log_file_name_convert');
1518    store_renamed(idx,'snapshot_refresh_interval','job_queue_interval');
1519  
1520    -- Initialization Parameters Renamed in Release 8.1.4 --
1521    store_renamed(idx,'mview_rewrite_enabled','query_rewrite_enabled');
1522    store_renamed(idx,'rewrite_integrity','query_rewrite_integrity');
1523  
1524    -- Initialization Parameters Renamed in Release 8.1.5 --
1525    store_renamed(idx,'nls_union_currency','nls_dual_currency');
1526    store_renamed(idx,'parallel_transaction_recovery',
1527                      'fast_start_parallel_rollback');
1528  
1529    -- Initialization Parameters Renamed in Release 9.0.1 --
1530    store_renamed(idx,'fast_start_io_target','fast_start_mttr_target');
1531    store_renamed(idx,'mts_circuits','circuits');
1532    store_renamed(idx,'mts_dispatchers','dispatchers');
1533    store_renamed(idx,'mts_max_dispatchers','max_dispatchers');
1534    store_renamed(idx,'mts_max_servers','max_shared_servers');
1535    store_renamed(idx,'mts_servers','shared_servers');
1536    store_renamed(idx,'mts_sessions','shared_server_sessions');
1537    store_renamed(idx,'parallel_server','cluster_database');
1538    store_renamed(idx,'parallel_server_instances',
1539                      'cluster_database_instances');
1540  
1541    -- Initialization Parameters Renamed in Release 9.2 --
1542    store_renamed(idx,'drs_start','dg_broker_start');
1543  
1544    -- Initialization Parameters Renamed in Release 10.1 --
1545    store_renamed(idx,'lock_name_space','db_unique_name');
1546  
1547    -- Initialization Parameters Renamed in Release 10.2 --
1548    -- none as of 4/1/05
1549  
1550    -- Initialization Parameters Renamed in Release 11.2 --
1551  
1552    store_renamed(idx,'buffer_pool_keep', 'db_keep_cache_size');
1553    store_renamed(idx,'buffer_pool_recycle', 'db_recycle_cache_size');
1554    store_renamed(idx,'commit_write', 'commit_logging,commit_wait');
1555  
1556    max_rp := idx;
1557  
1558    -- Initialize special initialization parameters
1559  
1560    idx := 0;
1561    store_special(idx,'rdbms_server_dn',NULL,'ldap_directory_access','SSL');
1562    store_special(idx,'plsql_compiler_flags','INTERPRETED',
1563                      'plsql_code_type','INTERPRETED');
1564    store_special(idx,'plsql_compiler_flags','NATIVE',
1565                      'plsql_code_type','NATIVE');
1566    store_special(idx,'plsql_debug','TRUE',
1567                      'plsql_optimize_level','1');
1568    store_special(idx,'plsql_compiler_flags','DEBUG',
1569                      'plsql_optimize_level','1');
1570  
1571    --  Only use these special parameters for databases
1572    --  in which Very Large Memory is not enabled
1573  
1574    IF db_VLM_enabled = FALSE THEN
1575      store_special(idx,'db_block_buffers',NULL,
1576                        'db_cache_size',NULL);
1577      store_special(idx,'buffer_pool_recycle',NULL,
1578                        'db_recycle_cache_size',NULL);
1579      store_special(idx,'buffer_pool_keep',NULL,
1580                        'db_keep_cache_size',NULL);
1581    END IF;
1582  
1583    --
1584    -- for 12.1, AUDIT_TRAIL has depreicated several values
1585    -- that were allowed for AUDIT_TRAIL, they have new
1586    -- mappings.
1587    -- Use store_special  - bug  2631483 and set the
1588    -- dbua_outInUpdate flag so output_xml_initparams
1589    -- dumps these out
1590    --
1591    store_special(idx,'audit_trail','FALSE',
1592                      'audit_trail','NONE');
1593    sp(idx).dbua_OutInUpdate := TRUE;
1594    store_special(idx,'audit_trail','TRUE',
1595                      'audit_trail','DB');
1596    sp(idx).dbua_OutInUpdate := TRUE;
1597    store_special(idx,'audit_trail','DB_EXTENDED',
1598                      'audit_trail','DB,EXTENDED');
1599    sp(idx).dbua_OutInUpdate := TRUE;
1600  
1601    max_sp := idx;
1602  
1603    --
1604    -- Min value for db_block_size
1605    --
1606    idx := 0;
1607    store_required (idx, 'db_block_size', 2048, '', 3);
1608  
1609    IF db_n_version = 102 THEN
1610      -- If undo_management is not specified in pre-11g database, then
1611      -- it needs to be specified MANUAL since the default is changing
1612      -- from MANUAL to AUTO starting in 11.1.
1613      store_required(idx, 'undo_management', 0, 'MANUAL', 2);
1614    END IF;
1615    max_reqp := idx;
1616  
1617    --
1618    -- Now run through them and figure out what is
1619    -- or isn't in use.
1620    --
1621    FOR i IN 1..max_rp LOOP
1622      BEGIN
1623        EXECUTE IMMEDIATE 'SELECT NULL FROM v$parameter WHERE name =
1624              LOWER(:1) AND isdefault = ''FALSE'''
1625        INTO t_null
1626        USING rp(i).oldname;
1627        rp(i).db_match := TRUE;
1628      EXCEPTION WHEN NO_DATA_FOUND THEN
1629         rp(i).db_match := FALSE;
1630      END;
1631    END LOOP;
1632  
1633    FOR i IN 1..max_op LOOP
1634      BEGIN
1635        EXECUTE IMMEDIATE 'SELECT NULL FROM v$parameter WHERE name =
1636           LOWER(:1) AND isdefault = ''FALSE'''
1637        INTO t_null
1638        USING op(i).name;
1639        op(i).db_match := TRUE;
1640      EXCEPTION WHEN NO_DATA_FOUND THEN
1641        op(i).db_match := FALSE;
1642      END;
1643    END LOOP;
1644  
1645    --
1646    -- The store_special procedure inits the db_match to
1647    -- field to FALSE, so only when we match do we need to
1648    -- do something.
1649    --
1650    FOR i IN 1..max_sp LOOP
1651      BEGIN
1652        EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE name =
1653                 LOWER(:1) AND isdefault = ''FALSE'''
1654        INTO c_value
1655        USING sp(i).oldname;
1656  
1657        IF sp(i).oldvalue IS NULL OR c_value = sp(i).oldvalue THEN
1658  
1659          sp(i).db_match := TRUE;
1660  
1661          --
1662          -- No old value specified, or oldvalue is what we are
1663          -- looking for
1664          --
1665  
1666          --           db_block_buffers
1667          -- Example:  db_block_buffers = 7000
1668  
1669          IF sp(i).oldname = 'db_block_buffers' THEN
1670            sp(i).newvalue := TO_CHAR(TO_NUMBER(c_value) * db_block_size);
1671  
1672          ELSIF sp(i).oldname = 'buffer_pool_recycle' OR
1673                sp(i).oldname = 'buffer_pool_keep' THEN
1674  
1675            --           buffer_pool_...
1676            -- Examples: buffer_pool_recycle= lru_latches:1, buffers:200
1677            --  buffer_pool_keep= (buffers:100,lru_latches:1)
1678  
1679            IF INSTR(UPPER(c_value),'BUFFERS:') > 0 THEN -- has keyword
1680              IF INSTR(SUBSTR(c_value,INSTR(UPPER(c_value),
1681                      'BUFFERS:')+8),',') > 0  THEN
1682                -- has second keyword after BUFFERS
1683                sp(i).newvalue := TO_CHAR(TO_NUMBER(SUBSTR(c_value,
1684                       INSTR(UPPER(c_value),'BUFFERS:')+8,
1685                       INSTR(c_value,',')-INSTR(UPPER(c_value),'BUFFERS:')-8))
1686                       * db_block_size);
1687              ELSE -- no second keyword
1688                sp(i).newvalue := TO_CHAR(TO_NUMBER(SUBSTR(c_value,
1689                        INSTR(UPPER(c_value),'BUFFERS:')+8)) * db_block_size);
1690              END IF; -- second keyword
1691            ELSIF INSTR(UPPER(c_value),',') > 0 THEN   -- has keyword format #,#
1692              --
1693              -- In the #,# Format the first number before the comma is
1694              -- buffers second number is the lru latches. For the calculation
1695              -- we parse out the the buffer number and multiply
1696              -- by db_block_size.
1697              --
1698              tmp_num2       := INSTR(UPPER(c_value),',');
1699              sp(i).newvalue := TRIM(SUBSTR(c_value, 1, tmp_num2-1));
1700              sp(i).newvalue := TO_CHAR(TO_NUMBER(sp(i).newvalue)
1701                                          * db_block_size);
1702            ELSE -- no keywords, just number
1703              sp(i).newvalue := TO_CHAR(TO_NUMBER(c_value) * db_block_size);
1704            END IF; -- keywords
1705  
1706          END IF; -- params with calculated values
1707  
1708        ELSE
1709          --
1710          -- Oldvalue is not null or queried value isn't
1711          -- the oldvalue in the sp data.
1712          --
1713  
1714          --      plsql_compiler_flags may contain two values
1715          --      in this case we process the list of values
1716  
1717          IF (sp(i).oldname = 'plsql_compiler_flags') AND
1718               (INSTR(c_value,sp(i).oldvalue) > 0) THEN
1719            -- If 'DEBUG' value found in list then make sure
1720            -- it is not finding NON_DEBUG
1721            -- (using premise that DEBUG and NON_DEBUG do not mix)
1722            IF (sp(i).oldvalue='DEBUG' AND
1723                 INSTR(c_value,'NON_DEBUG') = 0) OR
1724                 (sp(i).oldvalue != 'DEBUG') THEN
1725              sp(i).db_match := TRUE;
1726            END IF;
1727        END IF;
1728      END IF;
1729      EXCEPTION WHEN NO_DATA_FOUND THEN NULL;
1730      END;
1731    END LOOP;
1732  
1733  END init_params;
1734  
1735  PROCEDURE init_components
1736  IS
1737    reg_cursor cursor_t;
1738    c_null     CHAR(1);
1739    c_cid      VARCHAR2(128);
1740    c_version  VARCHAR2(128);
1741    c_schema   VARCHAR2(128);
1742    n_schema   NUMBER;
1743    n_status   NUMBER;
1744  
1745  BEGIN
1746    -- Clear all variable component data
1747    FOR i IN 1..max_comps LOOP
1748      cmp_info(i).sys_kbytes:=     2*c_kb;
1749      cmp_info(i).sysaux_kbytes:=  2*c_kb;
1750      cmp_info(i).def_ts_kbytes:=  0;
1751      cmp_info(i).ins_sys_kbytes:= 0;
1752      cmp_info(i).ins_def_kbytes:= 0;
1753      cmp_info(i).def_ts     := NULL;
1754      cmp_info(i).processed  := FALSE;
1755      cmp_info(i).install    := FALSE;
1756      cmp_info(i).archivelog_kbytes := 0;
1757      cmp_info(i).flashbacklog_kbytes := 0;
1758    END LOOP;
1759  
1760    -- Load component id and name
1761    cmp_info(catalog).cid := 'CATALOG';
1762    cmp_info(catalog).cname := 'Oracle Catalog Views';
1763    cmp_info(catproc).cid := 'CATPROC';
1764    cmp_info(catproc).cname := 'Oracle Packages and Types';
1765    cmp_info(javavm).cid := 'JAVAVM';
1766    cmp_info(javavm).cname := 'JServer JAVA Virtual Machine';
1767    cmp_info(xml).cid := 'XML';
1768    cmp_info(xml).cname := 'Oracle XDK for Java';
1769    cmp_info(catjava).cid := 'CATJAVA';
1770    cmp_info(catjava).cname := 'Oracle Java Packages';
1771    cmp_info(xdb).cid := 'XDB';
1772    cmp_info(xdb).cname := 'Oracle XML Database';
1773    cmp_info(rac).cid := 'RAC';
1774    cmp_info(rac).cname := 'Real Application Clusters';
1775    cmp_info(owm).cid := 'OWM';
1776    cmp_info(owm).cname := 'Oracle Workspace Manager';
1777    cmp_info(odm).cid := 'ODM';
1778    cmp_info(odm).cname := 'Data Mining';
1779    cmp_info(mgw).cid := 'MGW';
1780    cmp_info(mgw).cname := 'Messaging Gateway';
1781    cmp_info(aps).cid := 'APS';
1782    cmp_info(aps).cname := 'OLAP Analytic Workspace';
1783    cmp_info(xoq).cid := 'XOQ';
1784    cmp_info(xoq).cname := 'Oracle OLAP API';
1785    cmp_info(ordim).cid := 'ORDIM';
1786    cmp_info(ordim).cname := 'Oracle Multimedia';
1787    cmp_info(sdo).cid := 'SDO';
1788    cmp_info(sdo).cname := 'Oracle Spatial';
1789    cmp_info(context).cid := 'CONTEXT';
1790    cmp_info(context).cname := 'Oracle Text';
1791    cmp_info(wk).cid := 'WK';
1792    cmp_info(wk).cname := 'Oracle Ultra Search';
1793    cmp_info(ols).cid := 'OLS';
1794    cmp_info(ols).cname := 'Oracle Label Security';
1795    cmp_info(exf).cid := 'EXF';
1796    cmp_info(exf).cname := 'Expression Filter';
1797    cmp_info(em).cid := 'EM';
1798    cmp_info(em).cname := 'Oracle Enterprise Manager Repository';
1799    cmp_info(rul).cid := 'RUL';
1800    cmp_info(rul).cname := 'Rule Manager';
1801    cmp_info(apex).cid := 'APEX';
1802    cmp_info(apex).cname := 'Oracle Application Express';
1803    cmp_info(dv).cid := 'DV';
1804    cmp_info(dv).cname := 'Oracle Database Vault';
1805    cmp_info(misc).cid := 'STATS';
1806    cmp_info(misc).cname := 'Gather Statistics';
1807  
1808    -- Initialize comp script names
1809  
1810    IF db_n_version = 112 THEN
1811      --
1812      -- for 11.2, several components moved into
1813      -- catalog/catproc so they no longer have their own scripts
1814      --
1815      cmp_info(catalog).script := '?/rdbms/admin/catalog.sql';
1816      cmp_info(catproc).script := '?/rdbms/admin/catproc.sql';
1817      cmp_info(javavm).script  := '?/javavm/install/jvmpatch.sql';
1818      cmp_info(xml).script     := '?/xdk/admin/xmlpatch.sql';
1819      cmp_info(xdb).script     := '?/rdbms/admin/xdbpatch.sql';
1820      cmp_info(rac).script     := '?/rdbms/admin/catclust.sql';
1821      cmp_info(ols).script     := '?/rdbms/admin/olspatch.sql';
1822      cmp_info(exf).script     := '?/rdbms/admin/exfpatch.sql';
1823      cmp_info(rul).script     := '?/rdbms/admin/rulpatch.sql';
1824      cmp_info(owm).script     := '?/rdbms/admin/owmpatch.sql';
1825      cmp_info(ordim).script   := '?/ord/im/admin/impatch.sql';
1826      cmp_info(sdo).script     := '?/md/admin/sdopatch.sql';
1827      cmp_info(context).script := '?/ctx/admin/ctxpatch.sql';
1828      cmp_info(mgw).script     := '?/mgw/admin/mgwpatch.sql';
1829      cmp_info(aps).script     := '?/olap/admin/apspatch.sql';
1830      cmp_info(xoq).script     := '?/olap/admin/xoqpatch.sql';
1831      cmp_info(apex).script    := '?/apex/apxpatch.sql';
1832      cmp_info(dv).script      := '?/rdbms/admin/dvpatch.sql';
1833    ELSE
1834      cmp_info(catalog).script := '?/rdbms/admin/catalog.sql';
1835      cmp_info(catproc).script := '?/rdbms/admin/catproc.sql';
1836      cmp_info(javavm).script  := '?/javavm/install/jvmdbmig.sql';
1837      cmp_info(xml).script     := '?/xdk/admin/xmldbmig.sql';
1838      cmp_info(xdb).script     := '?/rdbms/admin/xdbdbmig.sql';
1839      cmp_info(rac).script     := '?/rdbms/admin/catclust.sql';
1840      cmp_info(ols).script     := '?/rdbms/admin/olsdbmig.sql';
1841      cmp_info(exf).script     := '?/rdbms/admin/exfdbmig.sql';
1842      cmp_info(rul).script     := '?/rdbms/admin/ruldbmig.sql';
1843      cmp_info(owm).script     := '?/rdbms/admin/owmdbmig.sql';
1844      cmp_info(odm).script     := '?/rdbms/admin/odmdbmig.sql';
1845      cmp_info(ordim).script   := '?/ord/im/admin/imdbmig.sql';
1846      cmp_info(sdo).script     := '?/md/admin/sdodbmig.sql';
1847      cmp_info(context).script := '?/ctx/admin/ctxdbmig.sql';
1848      cmp_info(wk).script      := '?/rdbms/admin/wkremov.sql';
1849      cmp_info(mgw).script     := '?/mgw/admin/mgwdbmig.sql';
1850      cmp_info(aps).script     := '?/olap/admin/apsdbmig.sql';
1851      cmp_info(xoq).script     := '?/olap/admin/xoqdbmig.sql';
1852      cmp_info(apex).script    := '?/apex/apxdbmig.sql';
1853      cmp_info(dv).script      := '?/rdbms/admin/dvdbmig.sql';
1854    END IF;
1855  
1856    -- *****************************************************************
1857    -- Store Release Dependent Data
1858    -- *****************************************************************
1859  
1860    -- kbytes for component installs (into SYSTEM and DEFAULT tablespaces)
1861    -- rae: add 10% for 11g .
1862    -- the '*1.2' below from point (a) to (b) are rae's .
1863    -- Point (a)
1864    cmp_info(javavm).ins_sys_kbytes:= 105972*1.2;  -- rae's
1865    cmp_info(xml).ins_sys_kbytes:=      4818*1.2;  -- rae's
1866    cmp_info(catjava).ins_sys_kbytes:=  5760*1.2;  -- rae's
1867    cmp_info(xdb).ins_sys_kbytes :=     10*c_kb * 1.2;
1868    IF db_block_size = 16384 THEN
1869      cmp_info(xdb).ins_def_kbytes:=   (88*2)*c_kb * 1.2;
1870    ELSE
1871      cmp_info(xdb).ins_def_kbytes:=   88*c_kb * 1.2;
1872    END IF;
1873    cmp_info(ordim).ins_sys_kbytes :=   10*c_kb * 1.2;  -- actually saw 1MB
1874    cmp_info(ordim).ins_def_kbytes :=   60*c_kb * 1.2;
1875    cmp_info(em).ins_sys_kbytes:= 0; -- was 22528*1.2 (rae's)
1876    cmp_info(em).ins_def_kbytes:= 0; -- was 51200*1.2 (rae's)
1877    -- Point (b)
1878  
1879    -- If there's XMLIndex on the XDB Repository during APEX upgrade
1880    -- from 11107 to 121 (apex v3 to v4), then 316M increase in xdb is seen.
1881    -- 316M = 85M (increase in lob segments + tables owned by xdb) +
1882    --        231M (increase in xmlindexes on xdb repository)
1883    -- (I.e., if no xmlindexes, then 85M of increase in XDB during APEX v3->v4
1884    -- upgrade.)
1885  
1886    IF db_n_version = 102 THEN
1887      -- mult by 1.1 for experimental noise
1888      cmp_info(catalog).sys_kbytes:=   67*c_kb * 1.1;
1889      cmp_info(catproc).sys_kbytes:=   (99+100)*c_kb * 1.1; -- catproc+catupend
1890      cmp_info(javavm).sys_kbytes:=   101*c_kb * 1.1;
1891      cmp_info(xdb).sys_kbytes:=       12*c_kb * 1.1;
1892      cmp_info(ordim).sys_kbytes:=     10*c_kb * 1.1;
1893      cmp_info(sdo).sys_kbytes:=       12*c_kb * 1.1;
1894      cmp_info(apex).sys_kbytes:=      81*c_kb * 1.1;
1895  
1896      cmp_info(catalog).sysaux_kbytes:=  14*c_kb * 1.1;
1897      cmp_info(catproc).sysaux_kbytes:=  31*c_kb * 1.1;
1898      cmp_info(aps).sysaux_kbytes:=      36*c_kb * 1.1;
1899  
1900      cmp_info(context).def_ts_kbytes:=  2*c_kb; -- CTXSYS , default
1901      cmp_info(exf).def_ts_kbytes:=      2*c_kb; -- EXFSYS , default
1902      cmp_info(apex).def_ts_kbytes:=    320*c_kb * 1.1; -- FLOWS_
1903      cmp_info(ordim).def_ts_kbytes:=   15*c_kb * 1.1; -- ORDSYS
1904      cmp_info(sdo).def_ts_kbytes:=     38*c_kb * 1.1; -- MDSYS
1905      cmp_info(em).def_ts_kbytes:=                  0; -- SYSMAN
1906      cmp_info(catproc).def_ts_kbytes:= 31*c_kb * 1.1;
1907      cmp_info(owm).def_ts_kbytes:=      2*c_kb; -- WMSYS
1908      cmp_info(xdb).def_ts_kbytes:=     85*c_kb; -- XDB
1909      cmp_info(ols).def_ts_kbytes:=      2*c_kb; -- LBACSYS , default
1910      cmp_info(dv).def_ts_kbytes:=       2*c_kb; -- DVSYS , default
1911      cmp_info(aps).def_ts_kbytes :=    37*c_kb * 1.1;
1912      cmp_info(wk).def_ts_kbytes:=       0;      -- WK removed => 0 increase
1913  
1914    ELSIF db_n_version = 111 THEN
1915  
1916      -- mult by 1.1 or 1.2 for experimental noise
1917      cmp_info(catalog).sys_kbytes:=  64*c_kb * 1.1;
1918      cmp_info(catproc).sys_kbytes:=  (59+123)*c_kb * 1.1; -- catproc+catupend
1919      cmp_info(javavm).sys_kbytes:=   49*c_kb * 1.1;
1920      cmp_info(context).sys_kbytes:=   7*c_kb * 1.1;
1921      cmp_info(xdb).sys_kbytes:=       2*c_kb * 1.1;
1922      cmp_info(ordim).sys_kbytes:=    50*c_kb * 1.1;
1923      cmp_info(sdo).sys_kbytes:=      11*c_kb * 1.1;
1924      cmp_info(apex).sys_kbytes:=     50*c_kb * 1.1;
1925      cmp_info(em).sys_kbytes:=                   0;
1926  
1927      cmp_info(catalog).sysaux_kbytes:=   12*c_kb * 1.1;
1928      cmp_info(catproc).sysaux_kbytes:=   21*c_kb * 1.1;
1929      cmp_info(aps).sysaux_kbytes:=       13*c_kb * 1.1;
1930  
1931      cmp_info(context).def_ts_kbytes:=  2*c_kb; -- CTXSYS , default
1932      cmp_info(exf).def_ts_kbytes:=      2*c_kb; -- EXFSYS , default
1933      cmp_info(apex).def_ts_kbytes :=  320*c_kb * 1.1; -- FLOWS_
1934      cmp_info(sdo).def_ts_kbytes:=     23*c_kb * 1.1; -- MDSYS
1935      cmp_info(ordim).def_ts_kbytes:=   15*c_kb * 1.1; -- ORDSYS
1936      cmp_info(em).def_ts_kbytes:=      0;       -- SYSMAN, removed, 0 increase
1937      cmp_info(catproc).def_ts_kbytes:= 21*c_kb * 1.1;
1938      cmp_info(owm).def_ts_kbytes:=      2*c_kb;       -- WMSYS, default
1939      cmp_info(xdb).def_ts_kbytes:=     85*c_kb; -- XDB
1940      cmp_info(ols).def_ts_kbytes:=      2*c_kb;       -- LBACSYS , default
1941      cmp_info(dv).def_ts_kbytes:=       2*c_kb;       -- DVSYS , default
1942      cmp_info(wk).def_ts_kbytes:=       0;        -- WK removed => 0 increase
1943  
1944    ELSIF db_n_version = 112 THEN
1945  
1946      -- mult by 1.1 or 1.2 for experimental noise
1947      cmp_info(catalog).sys_kbytes:=  58*c_kb * 1.1;
1948      cmp_info(catproc).sys_kbytes:=  (31+123)*c_kb * 1.1;  -- catproc+catupend
1949      cmp_info(javavm).sys_kbytes:=   10*c_kb * 1.1;
1950      cmp_info(context).sys_kbytes:=   4*c_kb * 1.1;
1951      cmp_info(xdb).sys_kbytes:=       2*c_kb * 1.1;
1952      cmp_info(sdo).sys_kbytes:=       2*c_kb * 1.1;
1953      cmp_info(apex).sys_kbytes:=     50*c_kb * 1.1;
1954  
1955      cmp_info(catalog).sysaux_kbytes:=   2*c_kb;  -- default
1956      cmp_info(catproc).sysaux_kbytes:=  27*c_kb * 1.1;
1957  
1958      -- apex: 269 is the amount of space needed (as seen from experiments) +
1959      --       50 is the padding because if apex is in its own tablespace
1960      --       then having a padding would be good
1961      cmp_info(apex).def_ts_kbytes :=  320*c_kb * 1.1; -- FLOWS_
1962  
1963      cmp_info(sdo).def_ts_kbytes:=     10*c_kb * 1.1; -- MDSYS
1964      cmp_info(ordim).def_ts_kbytes:=    2*c_kb;       -- ORDSYS , default
1965      cmp_info(em).def_ts_kbytes:=       0;      -- SYSMAN , 0 increase
1966      cmp_info(owm).def_ts_kbytes:=      2*c_kb; -- WMSYS , default
1967      cmp_info(xdb).def_ts_kbytes:=     85*c_kb; -- XDB , default
1968      cmp_info(aps).def_ts_kbytes :=     2*c_kb; -- default
1969      cmp_info(ols).def_ts_kbytes:=      2*c_kb; -- LBACSYS , default
1970      cmp_info(dv).def_ts_kbytes:=       2*c_kb; -- DVSYS , default
1971      cmp_info(wk).def_ts_kbytes:=       0;      -- WK removed => 0 increase
1972  
1973    ELSIF db_n_version = 121 THEN
1974      -- initial estimates of growth in patch release
1975      -- let's use 112 values for now (copy and paste of 112 values from above)
1976      -- CML: need to update for 121 patch upgrades
1977  
1978      -- mult by 1.1 or 1.2 for experimental noise
1979      cmp_info(catalog).sys_kbytes:=  58*c_kb * 1.1;
1980      cmp_info(catproc).sys_kbytes:=  (31+123)*c_kb * 1.1;  -- catproc+catupend
1981      cmp_info(javavm).sys_kbytes:=   10*c_kb * 1.1;
1982      cmp_info(context).sys_kbytes:=   4*c_kb * 1.1;
1983      cmp_info(xdb).sys_kbytes:=       2*c_kb * 1.1;
1984      cmp_info(sdo).sys_kbytes:=       2*c_kb * 1.1;
1985      cmp_info(apex).sys_kbytes:=     50*c_kb * 1.1;
1986  
1987      cmp_info(catalog).sysaux_kbytes:=   2*c_kb;  -- default
1988      cmp_info(catproc).sysaux_kbytes:=  27*c_kb * 1.2;
1989  
1990      cmp_info(apex).def_ts_kbytes :=  320*c_kb * 1.1; -- FLOWS_
1991      cmp_info(sdo).def_ts_kbytes:=     10*c_kb * 1.1; -- MDSYS
1992      cmp_info(ordim).def_ts_kbytes:=    2*c_kb;       -- ORDSYS , default
1993      cmp_info(em).def_ts_kbytes:=       0;      -- SYSMAN , 0 increase
1994      cmp_info(owm).def_ts_kbytes:=      2*c_kb; -- WMSYS , default
1995      cmp_info(xdb).def_ts_kbytes:=     85*c_kb; -- XDB , default
1996      cmp_info(aps).def_ts_kbytes :=     2*c_kb; -- default
1997      cmp_info(ols).def_ts_kbytes:=      2*c_kb; -- LBACSYS , default
1998      cmp_info(dv).def_ts_kbytes:=       2*c_kb; -- DVSYS , default
1999      cmp_info(wk).def_ts_kbytes:=       0;      -- WK removed => 0 increase
2000  
2001    END IF;
2002  
2003    -- Flashback and archivelog for each database component
2004  
2005    cmp_info(catalog).archivelog_kbytes   := 580;
2006    cmp_info(catalog).flashbacklog_kbytes := 285;
2007  
2008    -- catproc = catproc + utlmmig + utlrp
2009    cmp_info(catproc).archivelog_kbytes   := 705+410+312;
2010    cmp_info(catproc).flashbacklog_kbytes := 155+0+210;
2011  
2012    cmp_info(javavm).archivelog_kbytes    := 455;
2013    cmp_info(javavm).flashbacklog_kbytes  := 160;
2014  
2015    cmp_info(xml).archivelog_kbytes       := 96;
2016    cmp_info(xml).flashbacklog_kbytes     := 55;
2017  
2018    cmp_info(aps).archivelog_kbytes       := 96;
2019  
2020    cmp_info(dv).archivelog_kbytes        := 47;
2021  
2022    cmp_info(context).archivelog_kbytes   := 92;
2023  
2024    cmp_info(xdb).archivelog_kbytes       := 174;
2025    cmp_info(xdb).flashbacklog_kbytes     := 55;
2026  
2027    cmp_info(catjava).archivelog_kbytes   := 50;
2028  
2029    cmp_info(owm).archivelog_kbytes       := 49;
2030    cmp_info(owm).flashbacklog_kbytes     := 60;
2031  
2032    cmp_info(ordim).archivelog_kbytes     := 354;
2033  
2034    cmp_info(sdo).archivelog_kbytes       := 487;
2035    cmp_info(sdo).flashbacklog_kbytes     := 115;
2036  
2037    cmp_info(apex).archivelog_kbytes      := 822;
2038  
2039    cmp_info(xoq).archivelog_kbytes       := 49;
2040  
2041    cmp_info(em).archivelog_kbytes       := 415;
2042    cmp_info(em).flashbacklog_kbytes     := 447;
2043  
2044    -- For tablespace sizing
2045    -- CML: TS: estimate for utlrp later?  utlrp space goes into system and
2046    --          system right now is not sized for utlrp.
2047    cmp_info(misc).sys_kbytes:=     100*c_kb;  -- misc: round up to 100M fudge
2048    cmp_info(misc).sysaux_kbytes:=   50*c_kb;  -- misc: round up to  50M fudge
2049  
2050    --
2051    -- Grab the Component ID (varchar2) from
2052    -- registry, and then see if the
2053    -- schema exists in USER$ below which means its
2054    -- in use in this database.
2055    --
2056    OPEN reg_cursor FOR
2057       'SELECT cid, status, version, schema#
2058        FROM sys.registry$ WHERE namespace =''SERVER''';
2059  
2060    LOOP
2061  
2062      FETCH reg_cursor INTO c_cid, n_status, c_version, n_schema;
2063      EXIT WHEN reg_cursor%NOTFOUND;
2064  
2065      -- If the status is not  REMOVED or REMOVING
2066      IF n_status NOT IN (99,8)
2067      THEN
2068        EXECUTE IMMEDIATE 'SELECT name FROM sys.user$  WHERE user#=:1'
2069        INTO c_schema
2070        USING n_schema;
2071  
2072        FOR i IN 1..max_components LOOP
2073          IF c_cid = cmp_info(i).cid
2074          THEN
2075            store_comp(i, c_schema, c_version, n_status);
2076            EXIT; -- from component search loop
2077          END IF;
2078        END LOOP;  -- ignore if not in component list
2079      END IF;
2080    END LOOP;
2081    CLOSE reg_cursor;
2082  
2083  
2084    -- Ultra Search not in 10.1.0.2 registry so check schema
2085    IF NOT cmp_info(wk).processed THEN
2086      BEGIN
2087        EXECUTE IMMEDIATE 'SELECT NULL FROM sys.user$ WHERE name = ''WKSYS'''
2088        INTO c_null;
2089        store_comp(wk, 'WKSYS', db_version, NULL);
2090      EXCEPTION
2091           WHEN NO_DATA_FOUND THEN NULL;
2092      END;
2093    END IF;
2094  
2095    -- Check for HTML DB in 9.2.0 and 10.1 databases
2096    -- 121:  Is this needed
2097    BEGIN
2098      EXECUTE IMMEDIATE 'SELECT FLOWS_010500.wwv_flows_release from sys.dual'
2099      INTO c_version;
2100      store_comp(apex,'FLOWS_010500',c_version, NULL);
2101    EXCEPTION
2102         WHEN OTHERS THEN NULL;
2103    END;
2104  
2105    -- 121:  Is this needed
2106    BEGIN
2107      EXECUTE IMMEDIATE 'SELECT FLOWS_010600.wwv_flows_release from sys.dual'
2108      INTO c_version;
2109      store_comp(apex,'FLOWS_010600',c_version, NULL);
2110    EXCEPTION
2111       WHEN OTHERS THEN NULL;
2112    END;
2113  
2114    -- Check for APEX in 10.2 databases
2115    BEGIN
2116      EXECUTE IMMEDIATE 'SELECT FLOWS_020000.wwv_flows_release from sys.dual'
2117      INTO c_version;
2118      store_comp(apex,'FLOWS_020000',c_version, NULL);
2119    EXCEPTION
2120       WHEN OTHERS THEN NULL;
2121    END;
2122  
2123    BEGIN
2124      EXECUTE IMMEDIATE 'SELECT FLOWS_020100.wwv_flows_release from sys.dual'
2125      INTO c_version;
2126      store_comp(apex,'FLOWS_020100',c_version, NULL);
2127    EXCEPTION
2128       WHEN OTHERS THEN NULL;
2129    END;
2130  
2131    -- Database Vault not in registry so check for dvsys schema
2132    IF NOT cmp_info(dv).processed THEN
2133      BEGIN
2134        EXECUTE IMMEDIATE 'SELECT NULL FROM sys.user$ WHERE name = ''DVSYS'''
2135        INTO  c_null;
2136        store_comp(dv, 'DVSYS', '10.2.0', NULL);
2137      EXCEPTION
2138         WHEN NO_DATA_FOUND THEN NULL;
2139      END;
2140    END IF;
2141  
2142    -- CML: TS: estimate for utlrp later?
2143      -- Consider MISC (miscellaneous) in registry because
2144      -- cmp_info(misc).processed has to be equal to TRUE before the tablespace
2145      -- sizing algorithm will consider the space needed for MISC.
2146      -- this call will set 'cmp_info(misc).processed := TRUE;'
2147    store_comp(misc, 'SYS', NULL, NULL);
2148  
2149  
2150    IF db_n_version != 112 THEN -- install required components on major release only
2151      -- if SDO, ORDIM, WK, EXF, or ODM components are present, need JAVAVM
2152      IF NOT cmp_info(javavm).processed THEN
2153        IF cmp_info(ordim).processed OR cmp_info(wk).processed OR
2154             cmp_info(exf).processed OR cmp_info(sdo).processed
2155        THEN
2156          store_comp(javavm, 'SYS', NULL, NULL);
2157          cmp_info(javavm).install := TRUE;
2158          store_comp(catjava, 'SYS', NULL, NULL);
2159          cmp_info(catjava).install := TRUE;
2160        END IF;
2161      END IF;
2162  
2163      -- If there is a JAVAVM component
2164      -- THEN include the CATJAVA component.
2165      IF cmp_info(javavm).processed AND NOT cmp_info(catjava).processed
2166      THEN
2167        store_comp(catjava, 'SYS', NULL, NULL);
2168        cmp_info(catjava).install := TRUE;
2169      END IF;
2170  
2171      -- If interMedia or Spatial component, but no XML, Then
2172      -- install XML
2173      IF NOT cmp_info(xml).processed AND
2174           (cmp_info(ordim).processed OR cmp_info(sdo).processed)
2175      THEN
2176        store_comp(xml, 'SYS', NULL, NULL);
2177        cmp_info(xml).install := TRUE;
2178      END IF;
2179  
2180      -- If no XDB, Then install XDB
2181      IF NOT cmp_info(xdb).processed THEN
2182        store_comp(xdb, 'XDB', NULL, NULL);
2183        cmp_info(xdb).install := TRUE;
2184        cmp_info(xdb).def_ts := 'SYSAUX';
2185      END IF;
2186  
2187      -- If Spatial component, but no ORDIM, Then
2188      -- install ORDIM
2189      IF NOT cmp_info(ordim).processed AND
2190           (cmp_info(sdo).processed)
2191      THEN
2192        store_comp(ordim, 'ORDSYS', NULL, NULL);
2193        cmp_info(ordim).install := TRUE;
2194        cmp_info(ordim).def_ts := 'SYSAUX';
2195      END IF;
2196   END IF;  -- not for patch release
2197  
2198  END init_components;
2199  
2200  PROCEDURE init_resources
2201  IS
2202    idx           BINARY_INTEGER;
2203    tmp_cursor    cursor_t;
2204    tmp_num1      NUMBER;
2205    tmp_num2      NUMBER;
2206    delta_queues  INTEGER;
2207    delta_kbytes  NUMBER;
2208    p_tsname      VARCHAR2(128);
2209    tmp_varchar1  VARCHAR2(128);
2210    tmp_varchar2  VARCHAR2(128);
2211    p_status      VARCHAR2(30);
2212    sum_bytes     NUMBER;
2213    p_count       INTEGER;
2214  
2215  BEGIN
2216    --
2217    -- Misc stand-along values we report about
2218    --
2219    pMinFlashbackLogGen  := 0;
2220    pminArchiveLogGen    := 0;
2221  
2222    idx := 0;
2223    OPEN tmp_cursor FOR
2224        'SELECT tablespace_name, contents, extent_management FROM SYS.dba_tablespaces';
2225    LOOP
2226      FETCH tmp_cursor INTO p_tsname, tmp_varchar1, tmp_varchar2;
2227      EXIT WHEN tmp_cursor%NOTFOUND;
2228      IF p_tsname IN ('SYSTEM', 'SYSAUX', db_undo_tbs) OR
2229          is_comp_tablespace(p_tsname) OR
2230          ts_has_queues (p_tsname) OR
2231          ts_is_SYS_temporary (p_tsname) THEN
2232  
2233        idx := idx + 1;
2234        ts_info(idx).name  := p_tsname;
2235        IF tmp_varchar1 = 'TEMPORARY' THEN
2236          ts_info(idx).temporary := TRUE;
2237        ELSE
2238          ts_info(idx).temporary := FALSE;
2239        END IF;
2240  
2241        IF tmp_varchar2 = 'LOCAL' THEN
2242          ts_info(idx).localmanaged := TRUE;
2243        ELSE
2244          ts_info(idx).localmanaged := FALSE;
2245        END IF;
2246  
2247        -- Get number of kbytes used
2248        EXECUTE IMMEDIATE
2249          'SELECT SUM(bytes) FROM sys.dba_segments seg WHERE seg.tablespace_name = :1'
2250        INTO sum_bytes
2251        USING p_tsname;
2252        IF sum_bytes IS NULL THEN
2253          ts_info(idx).inuse := 0;
2254        ELSIF sum_bytes <= c_kb THEN
2255          ts_info(idx).inuse := 1;
2256        ELSE
2257          ts_info(idx).inuse := ROUND(sum_bytes/c_kb);
2258        END IF;
2259        -- TS: calculate space used per tablespace (ts_info(idx).name)
2260  
2261        -- Get number of kbytes allocated
2262        IF ts_info(idx).temporary AND
2263          ts_info(idx).localmanaged THEN
2264          EXECUTE IMMEDIATE
2265            'SELECT SUM(bytes) FROM sys.dba_temp_files files WHERE ' ||
2266                 'files.tablespace_name = :1'
2267          INTO sum_bytes
2268          USING p_tsname;
2269        ELSE
2270          EXECUTE IMMEDIATE
2271             'SELECT SUM(bytes) FROM sys.dba_data_files files WHERE ' ||
2272                    'files.tablespace_name = :1'
2273          INTO sum_bytes
2274          USING p_tsname;
2275        END IF;
2276  
2277        IF sum_bytes IS NULL THEN
2278          ts_info(idx).alloc:=0;
2279        ELSIF sum_bytes <= c_kb THEN
2280          ts_info(idx).alloc:=1;
2281        ELSE
2282          ts_info(idx).alloc:=ROUND(sum_bytes/c_kb);
2283        END IF;
2284  
2285        -- Get number of kbytes of unused autoextend
2286        IF ts_info(idx).temporary AND
2287          ts_info(idx).localmanaged THEN
2288          EXECUTE IMMEDIATE
2289            'SELECT SUM(decode(maxbytes, 0, 0, maxbytes-bytes)) ' ||
2290            'FROM sys.dba_temp_files WHERE tablespace_name=:1'
2291          INTO sum_bytes
2292          USING p_tsname;
2293        ELSE
2294          EXECUTE IMMEDIATE
2295            'SELECT SUM(decode(maxbytes, 0, 0, maxbytes-bytes)) ' ||
2296            'FROM sys.dba_data_files WHERE tablespace_name=:1'
2297          INTO sum_bytes
2298          USING p_tsname;
2299        END IF;
2300  
2301        IF sum_bytes IS NULL THEN
2302          ts_info(idx).auto:=0;
2303        ELSIF sum_bytes <= c_kb THEN
2304          ts_info(idx).auto:=1;
2305        ELSE
2306          ts_info(idx).auto:=ROUND(sum_bytes/c_kb);
2307        END IF;
2308  
2309        -- total available is allocated plus auto extend
2310        ts_info(idx).avail := ts_info(idx).alloc + ts_info(idx).auto;
2311      END IF;
2312    END LOOP;
2313    CLOSE tmp_cursor;
2314  
2315    max_ts := idx;   -- max tablespaces of interest
2316  
2317    -- *****************************************************************
2318    -- Collect Public Rollback Information
2319    -- *****************************************************************
2320  
2321    idx := 0;
2322    IF db_undo != 'AUTO' THEN  -- using rollback segments
2323  
2324      OPEN tmp_cursor FOR
2325          'SELECT segment_name, next_extent, max_extents, status FROM SYS.dba_rollback_segs
2326              WHERE owner=''PUBLIC'' OR (owner=''SYS'' AND segment_name != ''SYSTEM'')';
2327      LOOP
2328        FETCH tmp_cursor INTO tmp_varchar1, tmp_num1, tmp_num2, p_status;
2329        EXIT WHEN tmp_cursor%NOTFOUND;
2330        BEGIN
2331          --- get sum of bytes and tablespace name
2332          EXECUTE IMMEDIATE
2333              'SELECT tablespace_name, sum(bytes) FROM sys.dba_segments
2334                  WHERE segment_name = :1  AND ROWNUM = 1 GROUP BY tablespace_name'
2335          INTO p_tsname, sum_bytes
2336          USING tmp_varchar1;
2337          IF sum_bytes < c_kb THEN
2338            sum_bytes := 1;
2339          ELSE
2340            sum_bytes := sum_bytes/c_kb;
2341          END IF;
2342        EXCEPTION WHEN NO_DATA_FOUND THEN
2343          sum_bytes := NULL;
2344        END;
2345  
2346        IF sum_bytes IS NOT NULL THEN
2347          idx:=idx + 1;
2348          rs_info(idx).tbs_name := p_tsname;
2349          rs_info(idx).seg_name := tmp_varchar1;
2350          rs_info(idx).status   := p_status;
2351          rs_info(idx).next     := tmp_num1/c_kb;
2352          rs_info(idx).max_ext  := tmp_num2;
2353          rs_info(idx).inuse    := sum_bytes;
2354          EXECUTE IMMEDIATE
2355            'SELECT ROUND(SUM(DECODE(maxbytes, 0, 0,maxbytes-bytes)/:1))
2356                FROM sys.dba_data_files WHERE tablespace_name=:2'
2357          INTO rs_info(idx).auto
2358          USING c_kb, p_tsname;
2359  
2360          EXECUTE IMMEDIATE
2361            'SELECT ROUND(SUM(DECODE(maxbytes, 0, 0,maxbytes-bytes)/:1))
2362                FROM sys.dba_data_files WHERE tablespace_name=:2'
2363          INTO tmp_num1
2364          USING c_kb, p_tsname;
2365        END IF;
2366      END LOOP;
2367      CLOSE tmp_cursor;
2368    END IF;  -- using undo tablespace, not rollback
2369  
2370    max_rs := idx;
2371  
2372    -- *****************************************************************
2373    -- Determine free space needed if
2374    --   Archiving was on;
2375    --   Flashback Database was on
2376    -- We only report the values if they are actually on.
2377    -- *****************************************************************
2378  
2379    -- calculate the minimum amount of archive and flashback logs used
2380    -- for an upgrade for each component.
2381    --
2382    -- This is only an issue when db_log_mode = 'ARCHIVELOG'
2383    --
2384    FOR i in 1..max_comps LOOP
2385      IF cmp_info(i).processed THEN
2386        pMinArchiveLogGen := pMinArchiveLogGen
2387                               + cmp_info(i).archivelog_kbytes;
2388        pMinFlashbacklogGen := pMinFlashbacklogGen
2389                               + cmp_info(i).flashbacklog_kbytes;
2390      END IF;
2391    END LOOP;
2392  
2393    -- The numbers used were seen from experiments.  Add 10% for experimental
2394    -- noise.
2395    pMinArchiveLogGen := pMinArchiveLogGen * 1.1;
2396    pMinFlashbacklogGen := pMinFlashbacklogGen * 1.1;
2397  
2398    -- Total recovery area needed is:
2399    --   pMinArchiveLogGen + pMinFlashbacklogGen;
2400  
2401    -- *****************************************************************
2402    -- Collect Flashback Information
2403    -- *****************************************************************
2404  
2405    flashback_info.active := FALSE;
2406    flashback_info.name := '';
2407    flashback_info.limit := 0;
2408    flashback_info.used := 0;
2409    flashback_info.reclaimable := 0;
2410    flashback_info.files := 0;
2411    flashback_info.file_dest := '';
2412    flashback_info.dsize := 0;
2413  
2414    IF db_flashback_on THEN
2415      --
2416      -- Get the rest of the flashback settings
2417      --
2418      flashback_info.active := TRUE;
2419  
2420      BEGIN
2421        EXECUTE IMMEDIATE 'SELECT rfd.name, rfd.space_limit, rfd.space_used,
2422                    rfd.space_reclaimable, rfd.number_of_files,
2423                    vp1.value, vp2.value
2424          FROM v$recovery_file_dest rfd, v$parameter vp1, v$parameter vp2
2425          WHERE UPPER(vp1.name) = ''DB_RECOVERY_FILE_DEST'' AND
2426                 UPPER(vp2.name) = ''DB_RECOVERY_FILE_DEST_SIZE'''
2427         INTO flashback_info.name, flashback_info.limit, flashback_info.used,
2428                flashback_info.reclaimable, flashback_info.files,
2429                flashback_info.file_dest, flashback_info.dsize;
2430        EXCEPTION
2431          WHEN NO_DATA_FOUND THEN flashback_info.active := FALSE;
2432      END;
2433    END IF;
2434  
2435    -- *****************************************************************
2436    -- Calculate Tablespace Requirements
2437    -- *****************************************************************
2438  
2439    -- Look at all relevant tablespaces
2440    -- TS: loop per tablespace (ts_info(t).name)
2441    FOR t IN 1..max_ts LOOP
2442      delta_kbytes:=0;   -- initialize calculated tablespace delta
2443  
2444      IF ts_info(t).name = 'SYSTEM' THEN -- sum the component SYS kbytes
2445        FOR i IN 1..max_comps LOOP
2446  
2447          IF pDBGSizeResources THEN
2448            IF cmp_info(i).processed THEN
2449              DisplayDiagLine (cmp_info(i).cid || ' Processed. ' || ' Default Tblspace ' || cmp_info(i).def_ts || '.');
2450            ELSE
2451              DisplayDiagLine (cmp_info(i).cid || ' NOT Processed.');
2452            END IF;
2453          END IF;
2454  
2455          IF cmp_info(i).processed THEN
2456            IF cmp_info(i).install THEN  -- if component will be installed
2457              delta_kbytes := delta_kbytes + cmp_info(i).ins_sys_kbytes;
2458              IF pDBGSizeResources THEN
2459                DisplayDiagLine ('SYSTEM ' ||
2460                    LPAD(cmp_info(i).cid, 10) || ' ToBeInstalled ' ||
2461                    LPAD(cmp_info(i).ins_sys_kbytes/c_kb,10) || 'Mb');
2462              END IF;
2463            ELSE  -- if component is already in the registry
2464              delta_kbytes := delta_kbytes + cmp_info(i).sys_kbytes;
2465              IF pDBGSizeResources THEN
2466                DisplayDiagLine ('SYSTEM ' ||
2467                       LPAD(cmp_info(i).cid, 10) || ' IsInRegistry ' ||
2468                       LPAD(cmp_info(i).sys_kbytes/c_kb,10) || 'Mb');
2469              END IF;
2470            END IF;
2471          END IF;  -- nothing to add if component is or will not be in
2472                   -- the registry
2473        END LOOP;
2474      END IF;  -- end of special SYSTEM tablespace processing
2475      -- TS: delta after looping through components in SYSTEM
2476  
2477      IF ts_info(t).name = 'SYSAUX' THEN -- sum the component SYSAUX kbytes
2478        FOR i IN 1..max_comps LOOP
2479          IF cmp_info(i).processed AND
2480                (cmp_info(i).def_ts = 'SYSAUX' OR
2481                 cmp_info(i).def_ts = 'SYSTEM') THEN
2482            IF cmp_info(i).sysaux_kbytes >= cmp_info(i).def_ts_kbytes THEN
2483              delta_kbytes := delta_kbytes + cmp_info(i).sysaux_kbytes;
2484            ELSE
2485              delta_kbytes := delta_kbytes + cmp_info(i).def_ts_kbytes;
2486            END IF;
2487            IF pDBGSizeResources THEN
2488              DisplayDiagLine('SYSAUX ' ||
2489                     LPAD(cmp_info(i).cid, 10) || ' ' ||
2490                     LPAD(cmp_info(i).sysaux_kbytes/c_kb,10) || 'Mb');
2491            END IF;
2492            -- bug 13060071 :  apex , xdb
2493            -- if xdb and apex are both in db, then add 316M-85M (or 231M
2494            -- more) to sysaux if xdb resides here
2495            IF (cmp_info(i).cid = 'XDB'
2496                AND cmp_info(apex).processed = TRUE) THEN
2497              delta_kbytes :=  delta_kbytes + (231*c_kb);
2498              IF pDBGSizeResources THEN
2499                DisplayDiagLine('SYSAUX ' ||
2500                    LPAD(cmp_info(i).cid, 10) || ' ' || '(due to APEX) ' ||
2501                    LPAD(231, 10) || 'Mb');
2502              END IF;
2503            END IF;
2504          END IF;
2505        END LOOP;
2506      END IF;  -- end of special SYSAUX tablespace processing
2507      -- TS: sum delta for components in SYSAUX
2508  
2509      -- For tablespaces that are not SYSTEM:
2510      -- For tablespaces that are not SYSAUX:
2511      -- For tablespaces that are not UNDO:
2512      -- Now add in component default tablespace deltas
2513      -- def_tablespace_name is NULL for unprocessed comps
2514  
2515      IF (ts_info(t).name != 'SYSTEM' AND
2516          ts_info(t).name != 'SYSAUX' AND
2517          ts_info(t).name != db_undo_tbs) THEN
2518        FOR i IN 1..max_comps LOOP
2519          IF (ts_info(t).name = cmp_info(i).def_ts AND
2520             cmp_info(i).processed) THEN
2521            IF cmp_info(i).install THEN  -- use install amount
2522              delta_kbytes := delta_kbytes + cmp_info(i).ins_def_kbytes;
2523              IF pDBGSizeResources THEN
2524                DisplayDiagLine( RPAD(ts_info(t).name, 10) ||
2525                             LPAD(cmp_info(i).cid, 10) || ' ' ||
2526                             LPAD(cmp_info(i).ins_def_kbytes,10));
2527              END IF;
2528  
2529            ELSE  -- use default tablespace amount
2530              -- bug 9664514
2531              -- if apex version in the source db is older than the version
2532              -- in target db, then apex upgrade include apex install;
2533              -- estimate 180M for typical apex install.
2534              -- note: this section is for space calculations for
2535              -- tablespaces that are non-system and non-sysaux
2536              delta_kbytes :=  delta_kbytes + cmp_info(i).def_ts_kbytes;
2537  
2538              IF pDBGSizeResources THEN
2539                DisplayDiagLine(RPAD(ts_info(t).name, 10) ||
2540                        LPAD(cmp_info(i).cid, 10) || ' ' ||
2541                        LPAD(cmp_info(i).def_ts_kbytes/c_kb, 10) || 'Mb');
2542                --update_puiu_data('SCHEMA',
2543                --   ts_info(t).name || '-' || cmp_info(i).schema,
2544                --   cmp_info(i).def_ts_kbytes);
2545              END IF;
2546            END IF;
2547  
2548            -- bug 13060071 :  apex , xdb
2549            -- if xdb and apex are both in db, then add 316M-85M (or 231M
2550            -- more) to xdb default tablespace
2551            IF (cmp_info(i).cid = 'XDB' AND
2552                cmp_info(apex).processed = TRUE) THEN
2553              delta_kbytes :=  delta_kbytes + (231*c_kb);
2554              IF pDBGSizeResources THEN
2555                DisplayDiagLine(RPAD(ts_info(t).name, 10) || ' ' ||
2556                          LPAD(cmp_info(i).cid, 10) || ' ' ||
2557                          '(due to APEX) ' || LPAD(231, 10) || 'Mb');
2558              END IF;
2559            END IF;
2560          END IF;
2561        END LOOP; -- end of default tablespace calculations
2562      END IF; -- end of if tblspace is not undo and not sysaux and not system
2563              -- then add in component default tablespace deltas
2564  
2565      -- TS: sum delta for install in default tablespaces other than
2566      --          SYSAUX
2567  
2568      -- For tablespaces that are not undo:
2569      -- Now look for queues in user schemas
2570      IF ts_info(t).name != db_undo_tbs THEN
2571        EXECUTE IMMEDIATE 'SELECT count(*) FROM sys.dba_tables tb, sys.dba_queues q
2572            WHERE q.queue_table = tb.table_name AND
2573                 tb.tablespace_name = '' || ts_info(t).name || '' AND tb.owner NOT IN
2574                  (''SYS'',''SYSTEM'',''MDSYS'',''ORDSYS'',''OLAPSYS'',''XDB'',
2575                  ''LBACSYS'',''CTXSYS'',''ODM'',''DMSYS'', ''WKSYS'',''WMSYS'',
2576                   ''SYSMAN'',''EXFSYS'') '
2577        INTO delta_queues;
2578  
2579        IF delta_queues > 0 THEN
2580          delta_kbytes := delta_kbytes + delta_queues*48;
2581          IF pDBGSizeResources THEN
2582            DisplayDiagLine(RPAD(ts_info(t).name, 10) ||
2583                    ' QUEUE count = ' || delta_queues);
2584          END IF;
2585        END IF;
2586      END IF;  -- end of if tablespace is not undo
2587               -- then look for queues in user schemas
2588  
2589      -- See if this is the temporary tablespace for SYS
2590      IF ts_is_SYS_temporary(ts_info(t).name) THEN
2591        delta_kbytes := delta_kbytes + 50*c_kb;  -- Add 50M for TEMP
2592      END IF;
2593  
2594      -- See if this is the UNDO tablespace - be sure at least
2595      -- 400M (or c_undo_minsz_kb) is available
2596      IF ts_info(t).name = db_undo_tbs THEN
2597        ts_info(t).min := c_undo_minsz_kb;
2598        IF ts_info(t).alloc < ts_info(t).min THEN
2599          delta_kbytes := ts_info(t).min - ts_info(t).inuse;
2600        ELSE
2601          delta_kbytes := 0;
2602        END IF;
2603      END IF;  -- end of if this is the undo tablespace
2604  
2605      -- If DBUA output, then add in EM install if not in database
2606      IF pOutputType = c_output_xml THEN
2607        IF NOT cmp_info(em).processed THEN
2608          IF ts_info(t).name = 'SYSTEM' THEN
2609            delta_kbytes := delta_kbytes + cmp_info(em).ins_sys_kbytes;
2610          ELSIF ts_info(t).name = 'SYSAUX' THEN
2611            delta_kbytes := delta_kbytes + cmp_info(em).ins_def_kbytes;
2612          END IF;
2613        END IF;
2614      END IF;
2615  
2616      -- Put a 20% safety factor on DELTA and round it off
2617      delta_kbytes := ROUND(delta_kbytes*1.20);
2618  
2619      -- Finally, save DELTA value
2620      ts_info(t).delta := delta_kbytes;
2621  
2622      -- Calculate here the recommendation for minimum tablespace size - it is
2623      -- the "delta" plus existing in use amount IF tablespace is not undo.
2624      -- Else if tablespace is undo, then minimum was already set above
2625      -- to 400M (or c_undo_minsz_kb); therefore no need to calculate here.
2626  
2627      -- calculate ts_info(t).min
2628      IF ts_info(t).name != db_undo_tbs THEN
2629        -- calculate minimum tablespace size IF tablespace is NOT undo
2630        ts_info(t).min := ts_info(t).inuse + ts_info(t).delta;
2631  
2632        -- See if this is the SYSAUX tablespace - be sure at least 500M allocated
2633        IF ts_info(t).name = 'SYSAUX' THEN
2634          IF ts_info(t).min < c_sysaux_minsz_kb THEN
2635            ts_info(t).min := c_sysaux_minsz_kb;
2636          END IF;
2637        END IF;  -- end of checking that the minimum required space for SYSAUX
2638                 -- is at least 500Mb (or c_sysaux_minsz_kb)
2639  
2640      END IF;  -- end of calculate ts_info(t).min
2641  
2642      -- convert to MB and round up(min required)/down (alloc,avail,inuse)
2643      ts_info(t).min :=   CEIL(ts_info(t).min/c_kb);
2644      ts_info(t).alloc := ROUND((ts_info(t).alloc-512)/c_kb);
2645      ts_info(t).avail := ROUND((ts_info(t).avail-512)/c_kb);
2646      ts_info(t).inuse := ROUND((ts_info(t).inuse)/c_kb);
2647  
2648      -- Determine amount of additional space needed
2649      -- independent of autoextend on/off
2650      --
2651  
2652      IF ts_info(t).min > ts_info(t).alloc THEN
2653        ts_info(t).addl  := ts_info(t).min - ts_info(t).alloc;
2654      ELSE
2655        ts_info(t).addl := 0;
2656      END IF;
2657  
2658      -- Do we have enough space in the existing tablespace?
2659      IF ts_info(t).min < ts_info(t).avail  THEN
2660        ts_info(t).inc_by := 0;
2661      ELSE
2662         -- need to add space
2663         ts_info(t).inc_by := ts_info(t).min - ts_info(t).avail;
2664  
2665         -- sorta silly to ask user to increase tablespace by, for example, 3M.
2666         -- so how about : if there are any increases of less than 50M, we'll
2667         -- just round up the increase to 50M (or c_incby_minsz_mb).
2668         IF ts_info(t).inc_by < c_incby_minsz_mb THEN
2669           -- round up 'min' size such that the inc_by size would equal to 50M
2670           ts_info(t).min := ts_info(t).min +
2671                               (c_incby_minsz_mb - ts_info(t).inc_by);
2672           -- round up the 'inc_by' size to 50M
2673           ts_info(t).inc_by := c_incby_minsz_mb;
2674         END IF;  -- if inc_by is < 50M
2675      END IF;
2676  
2677      -- Find at least one file in the tablespace with autoextend on.
2678      -- If found, then that tablespace has autoextend on; else not on.
2679      -- DBUA will use this information to add to autoextend
2680      -- or to check for total space on disk
2681      --
2682      IF ts_info(t).addl > 0 OR ts_info(t).inc_by > 0 THEN
2683        ts_info(t).fauto := FALSE;
2684        IF ts_info(t).temporary AND  ts_info(t).localmanaged THEN
2685          OPEN tmp_cursor FOR
2686               'SELECT file_name, autoextensible from sys.dba_temp_files ' ||
2687               'where tablespace_name = :1' using ts_info(t).name;
2688        ELSE
2689          OPEN tmp_cursor FOR
2690               'SELECT file_name, autoextensible from sys.dba_data_files ' ||
2691               'where tablespace_name = :1' using ts_info(t).name;
2692        END IF;
2693        LOOP
2694          FETCH tmp_cursor INTO tmp_varchar1, tmp_varchar2;
2695          EXIT WHEN tmp_cursor%NOTFOUND;
2696          IF tmp_varchar2 = 'YES' THEN
2697            ts_info(t).fname := tmp_varchar1;
2698            ts_info(t).fauto := TRUE;
2699            EXIT;
2700          END IF;
2701        END LOOP;
2702        CLOSE tmp_cursor;
2703      END IF;
2704    END LOOP;  -- end of tablespace loop
2705  END init_resources;
2706  
2707  procedure time_zone_check
2708  IS
2709    --
2710    -- This is decared as a public function for the package.
2711    --
2712    -- Allow dbms_preup.timezone_check to be called which
2713    -- tells the real procedure to call the init routine.
2714    --
2715  BEGIN
2716    tz_fixup(TRUE);
2717  END time_zone_check;
2718  
2719  procedure tz_fixup (call_init BOOLEAN)
2720  IS
2721    --
2722    -- This is the timzeone procedure that does the work
2723    --
2724    tmp_bool BOOLEAN;
2725  BEGIN
2726    -- If called with call_init = TRUE, call the init
2727    -- package, otherwise don't.  We need this because
2728    -- the init package will call this procedure
2729    -- and we'll end up in a loop.
2730    --
2731    IF call_init THEN
2732      init_package;
2733    ELSE
2734      -- Need db_tz_version below - fetch it the same way the init routine
2735      -- does.
2736      EXECUTE IMMEDIATE 'SELECT version from v$timezone_file'
2737        INTO db_tz_version;
2738    END IF;
2739    --
2740    -- Update registry$database with tz version (create it if necessary)
2741    --
2742    tmp_bool := FALSE;
2743    IF NOT db_readonly and NOT db_invalid_state THEN
2744      BEGIN
2745        EXECUTE IMMEDIATE
2746            'UPDATE registry$database set tz_version = :1'
2747        USING db_tz_version;
2748        COMMIT;
2749      EXCEPTION WHEN OTHERS THEN
2750        IF sqlcode = -904 THEN  -- registry$database exists but no tz_version
2751          tmp_bool := TRUE;
2752        END IF;
2753      END;
2754  
2755      IF tmp_bool = TRUE
2756      THEN
2757        --
2758        -- registry$database does not have tz_version,
2759        -- add it here.
2760        --
2761        EXECUTE IMMEDIATE
2762               'ALTER TABLE registry$database ADD (tz_version NUMBER)';
2763        EXECUTE IMMEDIATE
2764               'UPDATE registry$database set tz_version = :1'
2765        USING db_tz_version;
2766        COMMIT;
2767      END IF;
2768  
2769      -- populate sys.props$ with Day Light Saving Time (DST) props
2770      -- Only needed for releases before 11.2
2771      IF db_n_version IN (102, 111) THEN
2772        -- only if the database time zone file versions match.
2773        BEGIN
2774          -- remove all DST entries that we will then populate
2775          EXECUTE IMMEDIATE '
2776             DELETE sys.props$ WHERE name IN (''DST_UPGRADE_STATE'',
2777                                            ''DST_PRIMARY_TT_VERSION'',
2778                                            ''DST_SECONDARY_TT_VERSION'')';
2779          EXECUTE IMMEDIATE 'INSERT INTO sys.props$ (name, value$, comment$)
2780               VALUES (''DST_UPGRADE_STATE'', ''NONE'',
2781                     ''State of Day Light Saving Time Upgrade'')';
2782          EXECUTE IMMEDIATE 'INSERT INTO sys.props$ (name, value$, comment$)
2783               VALUES (''DST_PRIMARY_TT_VERSION'', TO_CHAR( :1, ''FM999''),
2784                     ''Version of primary timezone data file'')'
2785          USING db_tz_version;
2786          EXECUTE IMMEDIATE 'INSERT INTO sys.props$ (name, value$, comment$)
2787                VALUES (''DST_SECONDARY_TT_VERSION'', ''0'',
2788                      ''Version of secondary timezone data file'')';
2789          COMMIT;
2790        END;
2791      END IF;
2792    END IF;  -- DB read only and db_invalid state
2793  END tz_fixup;
2794  
2795  --
2796  -- Put a line out to the output file (or screen)
2797  --
2798  PROCEDURE DisplayLine (line VARCHAR2)
2799  IS
2800  BEGIN
2801    --
2802    -- If the package isn't inited yet (output from init routines)
2803    -- use dbms_output (output files would not be opened)
2804    --
2805    IF p_package_inited = FALSE OR pOutputDest = c_output_terminal THEN
2806      dbms_output.put_line (line);
2807    ELSE
2808      UTL_FILE.PUT_LINE (pOutputUFT,line);
2809    END IF;
2810  END DisplayLine;
2811  
2812  --
2813  -- Put a line of text directly to a file
2814  --
2815  PROCEDURE DisplayLine (uft UTL_FILE.FILE_TYPE, line IN VARCHAR2)
2816  IS
2817  BEGIN
2818    BEGIN
2819      UTL_FILE.PUT_LINE (uft,line);
2820    EXCEPTION
2821      WHEN OTHERS THEN NULL; -- utl_file.invalid_filehandle
2822    END;
2823  END DisplayLine;
2824  
2825  PROCEDURE DisplayDiagLine (line IN VARCHAR2)
2826  IS
2827  BEGIN
2828    IF pOutputType = c_output_xml THEN
2829      DisplayLine ('<!-- DBG: ' || line || ' -->');
2830    ELSE
2831      DisplayLine ('DBG: ' || line);
2832    END IF;
2833  END DisplayDiagLine;
2834  
2835  --
2836  -- Put a line out using put_line (no matter what)
2837  --
2838  PROCEDURE DisplayLinePL (line VARCHAR2)
2839  IS
2840  BEGIN
2841    dbms_output.put_line (line);
2842  END DisplayLinePL;
2843  
2844  FUNCTION CenterLine (line IN VARCHAR2) RETURN VARCHAR2
2845  IS
2846  BEGIN
2847    RETURN (LPAD(line,35+(length(line)/2)+1));
2848  END CenterLine;
2849  
2850  --
2851  -- Put a line of text to output AND to passed file but
2852  -- its wrapped around dbms_output.put_line (so text only)
2853  -- intended to be dumped out while the pre/post fixup scripts
2854  -- are being run.
2855  --
2856  PROCEDURE DisplayLineBoth (uft UTL_FILE.FILE_TYPE, line IN VARCHAR2)
2857  IS
2858  BEGIN
2859    DisplayLine(line);
2860    IF pOutputtingScripts THEN
2861      DisplayLine (uft, 'dbms_output.put_line (''' || line || ''');');
2862    END IF;
2863  END DisplayLineBoth;
2864  
2865  
2866  PROCEDURE DisplayBanner
2867  IS
2868  BEGIN
2869    DisplayLine('**********************************************************************');
2870  END DisplayBanner;
2871  
2872  --
2873  -- Overloaded version go to script file if we are creating one.
2874  --
2875  PROCEDURE DisplayBanner (uft UTL_FILE.FILE_TYPE)
2876  IS
2877  BEGIN
2878    DisplayLine('**********************************************************************');
2879    IF pOutputtingScripts THEN
2880      DisplayLine (uft, 'dbms_output.put_line ('''
2881        || '**********************************************************************'
2882        || ''');');
2883    END IF;
2884  END DisplayBanner;
2885  
2886  --
2887  -- Put the passed line out, centering it in a field of 70 char (the length of the banner)
2888  --
2889  PROCEDURE DisplayCenter (line IN VARCHAR2)
2890  IS
2891  BEGIN
2892    DisplayLine(LPAD(line,35+(length(line)/2)+1));
2893  END DisplayCenter;
2894  
2895  --
2896  -- Overloaded, including dumping to script file (only TEXT to be
2897  -- displayed when the script file is executed)
2898  --
2899  PROCEDURE DisplayCenter (uft UTL_FILE.FILE_TYPE, line IN VARCHAR2)
2900  IS
2901  BEGIN
2902    DisplayLine(LPAD(line,35+(length(line)/2)+1));
2903    IF pOutputtingScripts THEN
2904      DisplayLine (uft, 'dbms_output.put_line ('''
2905        || LPAD(line,35+(length(line)/2)+1)
2906        || ''');');
2907    END IF;
2908  END DisplayCenter;
2909  
2910  --
2911  -- Same as above, only use dbms_output.put_line only
2912  -- Intended to be used by fixup routine to better control
2913  -- format.
2914  --
2915  PROCEDURE DisplayCenterPL (line IN VARCHAR2)
2916  IS
2917  BEGIN
2918    dbms_output.put_line(LPAD(line,35+(length(line)/2)+1));
2919  END DisplayCenterPL;
2920  
2921  PROCEDURE DisplayWarning (text varchar2)
2922  IS
2923  BEGIN
2924    DisplayLine ('WARNING: --> ' || text);
2925  END DisplayWarning;
2926  
2927  PROCEDURE DisplayError (text varchar2)
2928  IS
2929  BEGIN
2930    pCheckErrorCount := pCheckErrorCount + 1;
2931    DisplayLine ('ERROR: --> ' || text);
2932  END DisplayError;
2933  
2934  --
2935  --  Define what the output from this is going to be
2936  --  Text/XML are the only valid options.
2937  --  Defaulting to text
2938  -- If XML, call the procedure to output the header
2939  -- .
2940  PROCEDURE set_output_type (p_type VARCHAR2)
2941  IS
2942  BEGIN
2943    IF p_type = 'XML' THEN
2944      pOutputType := c_output_xml;
2945    ELSE
2946      -- Default to text
2947      pOutputType := c_output_text;
2948    END IF;
2949  END set_output_type;
2950  
2951  PROCEDURE set_output_file (p_on_off BOOLEAN)
2952  IS
2953  BEGIN
2954    IF p_on_off THEN
2955      IF pOutputDest = c_output_file THEN
2956        -- Already done.
2957        RETURN;
2958      END IF;
2959      set_output_file (c_output_fn);
2960    ELSE
2961      close_file;
2962    END IF;  -- on/off
2963  END set_output_file;
2964  
2965  --
2966  -- Overloaded version of set_output_file to include
2967  -- location.
2968  -- Note that p_location is assumed to be verified
2969  -- by the caller.
2970  --
2971  PROCEDURE set_output_file (p_location VARCHAR2, p_fn VARCHAR2)
2972  IS
2973  BEGIN
2974    -- Set local dirobject name then call set output
2975    pOutputLocation := p_location;
2976    pOutputVerified := TRUE;
2977    set_output_file(p_fn);
2978  END set_output_file;
2979  
2980  PROCEDURE set_output_file (p_fn VARCHAR2)
2981  IS
2982    openFailure BOOLEAN;
2983  BEGIN
2984    pOutputFName := p_fn;
2985  
2986    IF (pOutputLocation IS NULL ) THEN
2987      verifyDefaultDirObj;
2988    END IF;
2989    openFailure := FALSE;
2990    IF pOutputVerified THEN
2991      BEGIN
2992        pOutputUFT := UTL_FILE.FOPEN(pOutputLocation, pOutputFName, 'W', 15000);
2993        EXCEPTION WHEN OTHERS THEN openFailure := TRUE;
2994      END;
2995      IF openFailure THEN
2996        DisplayLine ('WARNING: Failed to open ' || pOutputFName || ' for write access');
2997        DisplayLine('    script will generate terminal output only');
2998        pOutputVerified := FALSE;
2999        pOutputLocation := NULL;
3000        pOutputDest       := c_output_terminal;
3001      ELSE
3002        pOutputDest := c_output_file;
3003      END IF;
3004    ELSE
3005      --
3006      -- Failed to verify the outputdir, default to
3007      -- terminal (verify routine will issue error)
3008      --
3009      pOutputDest := c_output_terminal;
3010    END IF;
3011  END set_output_file;
3012  
3013  PROCEDURE close_file
3014  IS
3015  BEGIN
3016    IF pOutputDest = c_output_file THEN
3017      UTL_FILE.FCLOSE(pOutputUFT);
3018      pOutputDest := c_output_terminal;
3019  
3020      IF pOutputtingScripts = FALSE AND pCreatedDirObj THEN
3021        --
3022        -- Cleanup the directory if we created it, however the
3023        -- DBUA process deals with this so just ignore any
3024        -- drop error.
3025        --
3026        BEGIN
3027          EXECUTE IMMEDIATE 'DROP DIRECTORY :1' USING pOutputLocation;
3028        EXCEPTION WHEN OTHERS THEN NULL;
3029        END;
3030      END IF;
3031      -- We no longer have a pOutputFName and reset pOutputLocation
3032      pOutputFName := NULL;
3033      pOutputLocation := NULL;
3034    END IF;
3035  END close_file;
3036  
3037  --
3038  -- For manual mode, we need to output the path were the logs/scripts
3039  -- If we are not outputting files, return ''
3040  --
3041  FUNCTION get_output_path RETURN VARCHAR2
3042  IS
3043    path    VARCHAR2(4000);
3044  BEGIN
3045    IF pOutputtingScripts = FALSE THEN
3046      RETURN '*** Scripts/Logs are not being Generated ***';
3047    END IF;
3048  
3049    BEGIN
3050      EXECUTE IMMEDIATE 'SELECT directory_path from DBA_DIRECTORIES where directory_name=:1'
3051      INTO path
3052      USING c_dir_obj;
3053      EXCEPTION WHEN NO_DATA_FOUND THEN path := '*** PATH NOT DEFINED ***';
3054    END;
3055    RETURN path;
3056  END get_output_path;
3057  
3058  PROCEDURE set_scripts (p_on_off BOOLEAN)
3059  IS
3060    openFailure BOOLEAN;
3061    timeinfo    VARCHAR2(60);
3062    genline     VARCHAR2(200);
3063  BEGIN
3064    IF p_on_off THEN
3065      IF pOutputtingScripts THEN
3066        -- Already done.
3067        RETURN;
3068      END IF;
3069      --
3070      -- Make sure a directory object exists
3071      --
3072      verifyDefaultDirObj;
3073  
3074      IF pOutputVerified = FALSE THEN
3075        --
3076        -- We couldn't verify the directory object
3077        --
3078        pOutputtingScripts := FALSE;
3079        RETURN;
3080      END IF;
3081  
3082      --
3083      -- Open both files and put some info out.
3084      -- Also dump out a begin/end output line - if there
3085      -- is no errors, these lines will stop the script from
3086      -- generating an error because the begin/end block would be
3087      -- empty.
3088      --
3089      openFailure := FALSE;
3090      BEGIN
3091        pPreScriptUFT  := UTL_FILE.FOPEN(pOutputLocation, pPreScriptFname, 'W', 15000);
3092        EXCEPTION WHEN OTHERS THEN openFailure := TRUE;
3093      END;
3094      IF openFailure THEN
3095        DisplayLine ('WARNING: Failed to open ' || pPreScriptFname || ' for write access');
3096      ELSE
3097        BEGIN
3098          pPostScriptUFT := UTL_FILE.FOPEN(pOutputLocation, pPostScriptFname, 'W', 15000);
3099          EXCEPTION WHEN OTHERS THEN openFailure := TRUE;
3100        END;
3101        IF openFailure THEN
3102          DisplayLine ('WARNING: Failed to open ' || pPostScriptFname || ' for write access');
3103        END IF;
3104      END IF;
3105  
3106      IF openFailure THEN
3107        DisplayLine('     script will not generate fixup scripts.');
3108        pOutputVerified := FALSE;
3109        pOutputLocation := NULL;
3110        pOutputtingScripts := FALSE;
3111        RETURN;
3112      END IF;
3113  
3114      EXECUTE IMMEDIATE 'SELECT TO_CHAR(SYSTIMESTAMP,''YYYY-MM-DD HH24:MI:SS '') FROM SYS.DUAL'
3115      INTO timeinfo;
3116  
3117      --
3118      -- The linesize at 750 allows the buffering of some of the help text
3119      -- which can get long.  No data will be lost, the line will just be
3120      -- unnaturally wrapped.
3121      --
3122      DisplayLine (pPreScriptUFT, 'REM Pre-Upgrade Script Generated on: ' || timeinfo);
3123      DisplayLine (pPreScriptUFT, 'REM Generated by Version: ' || c_version || ' Build: '
3124                                          || c_build);
3125      DisplayLine (pPreScriptUFT, 'SET ECHO OFF SERVEROUTPUT ON FORMAT WRAPPED TAB OFF LINESIZE 750;' || crlf);
3126      -- In its own begin/end so the output gets out before
3127      -- the real work gets started.
3128      genline := 'Pre-Upgrade Fixup Script Generated on ' || timeinfo || ' Version: ' || c_version
3129          || ' Build: ' || c_build;
3130      DisplayLine (pPreScriptUFT, 'BEGIN');
3131      DisplayLine (pPreScriptUFT, '  dbms_output.put_line (''' || genline || ''');');
3132      DisplayLine (pPreScriptUFT, '  dbms_output.put_line (''Beginning Pre-Upgrade Fixups...'');');
3133      DisplayLine (pPreScriptUFT, 'END;');
3134      DisplayLine (pPreScriptUFT, '/');
3135      DisplayLine (pPreScriptUFT, 'BEGIN');
3136      DisplayLine (pPreScriptUFT, 'dbms_preup.clear_run_flag(TRUE);');
3137      DisplayLine (pPreScriptUFT, 'END;');
3138      DisplayLine (pPreScriptUFT, '/');
3139     --
3140      -- Now post...
3141      --
3142      DisplayLine (pPostScriptUFT, 'REM Post Upgrade Script Generated on: ' || timeinfo);
3143      DisplayLine (pPostScriptUFT, 'REM Generated by Version: ' || c_version || ' Build: '
3144                                          || c_build);
3145      DisplayLine (pPostScriptUFT, 'SET ECHO OFF SERVEROUTPUT ON FORMAT WRAPPED TAB OFF LINESIZE 750;' || crlf);
3146  
3147      genline := 'Post Upgrade Fixup Script Generated on ' || timeinfo || ' Version: ' || c_version
3148          || ' Build: ' || c_build;
3149      -- In its own begin/end so the output gets out before
3150      -- the real work gets started.
3151      DisplayLine (pPostScriptUFT, 'BEGIN');
3152      DisplayLine (pPostScriptUFT, '  dbms_output.put_line (''' || genline || ''');');
3153      DisplayLine (pPostScriptUFT, '  dbms_output.put_line (''Beginning Post-Upgrade Fixups...'');');
3154      DisplayLine (pPostScriptUFT, 'END;');
3155      DisplayLine (pPostScriptUFT, '/');
3156      DisplayLine (pPostScriptUFT, 'BEGIN');
3157      DisplayLine (pPostScriptUFT, 'dbms_preup.clear_run_flag(FALSE);');
3158      DisplayLine (pPostScriptUFT, 'END;');
3159      DisplayLine (pPostScriptUFT, '/');
3160      pOutputtingScripts := TRUE;
3161    ELSE
3162      IF pOutputtingScripts THEN
3163        --
3164        -- Dump out a call to the routine to run through all the checks and report
3165        -- a summary of success/failures/user actions
3166        --
3167        DisplayLine (pPreScriptUFT, 'BEGIN dbms_preup.fixup_summary(TRUE); END;');
3168        DisplayLine (pPreScriptUFT,'/');
3169  
3170        DisplayLine (pPostScriptUFT, 'BEGIN dbms_preup.fixup_summary(FALSE); END;');
3171        DisplayLine (pPostScriptUFT,'/');
3172  
3173  
3174        EXECUTE IMMEDIATE 'SELECT TO_CHAR(SYSTIMESTAMP,''YYYY-MM-DD HH24:MI:SS '') FROM SYS.DUAL'
3175        INTO timeinfo;
3176  
3177        DisplayLine (pPreScriptUFT, 'BEGIN');
3178        DisplayLine (pPreScriptUFT,
3179            'dbms_output.put_line (''**************** Pre-Upgrade Fixup Script Complete *********************'');');
3180        DisplayLine (pPreScriptUFT, 'END;' || crlf || '/' || crlf);
3181        DisplayLine (pPreScriptUFT, 'REM Pre-Upgrade Script Closed At: ' || timeinfo);
3182  
3183        DisplayLine (pPostScriptUFT, 'BEGIN');
3184        DisplayLine (pPostScriptUFT,
3185            'dbms_output.put_line (''*************** Post Upgrade Fixup Script Complete ********************'');');
3186        DisplayLine (pPostScriptUFT,'END;' || crlf || '/' );
3187        DisplayLine (pPostScriptUFT,'REM Post Upgrade Script Closed At: ' || timeinfo);
3188  
3189        UTL_FILE.FCLOSE(pPreScriptUFT);
3190        UTL_FILE.FCLOSE(pPostScriptUFT);
3191        --
3192        pOutputtingScripts := FALSE;
3193      END IF;
3194      IF pOutputDest = c_output_terminal AND pCreatedDirObj THEN
3195        --
3196        -- If we created the directory object, (and we are not outputting
3197        -- to a log file) drop the directory object (usually done in close_file
3198        -- but that will not be called if we are not outputting a log file)
3199        --
3200        BEGIN
3201          EXECUTE IMMEDIATE 'DROP DIRECTORY :1' USING pOutputLocation;
3202        EXCEPTION WHEN OTHERS THEN NULL;
3203        END;
3204      END IF;
3205      pOutputLocation := NULL;
3206  
3207    END IF;  -- on/off
3208  END set_scripts;
3209  
3210  PROCEDURE verifyDefaultDirObj
3211  --
3212  -- Bulk of this code started with a version in catbundle.sql
3213  -- The code creates a java package to create an actual
3214  -- directory on the server under cfgtoollogs/<dbid>/preupgrade
3215  -- and then also creates a directory object to point there.
3216  -- Note: If the directory object already exists, it will
3217  -- be used and no directory will be created.
3218  --
3219  -- The global value:
3220  --   pOutputVerified
3221  -- is set to TRUE if the directory object could be verified,
3222  -- otherwise FALSE.
3223  --
3224  -- Notes:
3225  --   This routine will dump out a warning should the directory object
3226  --   fail to be verified.
3227  --
3228  IS
3229    dummy       VARCHAR2(2500);
3230    tmp_varchar VARCHAR2(200);
3231    platform    v$database.platform_name%TYPE;
3232    uniqueName  VARCHAR2(100);
3233    logDir      VARCHAR2(4000);  -- the physical directory
3234    dirObjName  VARCHAR2(128);   -- the object name
3235    rdbmsLogDir VARCHAR2(500);
3236    homeDir     VARCHAR2(500);
3237    baseDir     VARCHAR2(500);
3238    useDir      VARCHAR2(500);
3239    tmp_dirpath VARCHAR2(4000);
3240    usingExistingDef BOOLEAN := FALSE;
3241    clearJava   BOOLEAN;
3242    status      NUMBER;
3243    javaOK      NUMBER;
3244    javaCreate  VARCHAR2(500) :=
3245      'CREATE OR REPLACE FUNCTION PreupCreateDir(path VARCHAR2)
3246         RETURN NUMBER AS
3247         LANGUAGE JAVA
3248         NAME ''PreupCreateDir.create (java.lang.String) return java.lang.int'';';
3249    dummyCreate   VARCHAR2(500) :=
3250      'CREATE OR REPLACE FUNCTION PreupCreateDir(path VARCHAR2)
3251         RETURN NUMBER AS
3252       BEGIN
3253         RETURN 0;
3254       END PreupCreateDir;';
3255    createString  VARCHAR2(500);
3256  
3257    nameAlreadyExists  EXCEPTION;
3258    PRAGMA exception_init(nameAlreadyExists, -955);
3259  
3260    classInUse         EXCEPTION;
3261    PRAGMA EXCEPTION_INIT(classInUse, -29553);
3262  
3263  BEGIN
3264  
3265    --
3266    -- See if the directory object already exists
3267    --
3268    BEGIN
3269      EXECUTE IMMEDIATE 'SELECT directory_name,directory_path from DBA_DIRECTORIES where directory_name=:1'
3270      INTO tmp_varchar, tmp_dirpath
3271      USING c_dir_obj;
3272      EXCEPTION WHEN NO_DATA_FOUND THEN NULL;
3273    END;
3274  
3275    IF tmp_varchar = c_dir_obj THEN
3276      --
3277      -- The directory object exists and is using our name
3278      --
3279      pOutputLocation := c_dir_obj;
3280      pCreatedDirObj := FALSE;
3281      --
3282      -- Define logDir (javascript will veirfy it exists)
3283      --
3284      logDir := dbms_assert.enquote_literal(tmp_dirpath);
3285      usingExistingDef := TRUE;
3286    END IF;
3287  
3288    IF usingExistingDef = FALSE THEN
3289      --
3290      -- If we didn't grab the existing directory path from the query above
3291      -- construct one here.
3292      --
3293      -- This is the default case (assuming we will create the directory object)
3294      -- so figure out the path we want so we can actually create the target
3295      -- directory.
3296      --
3297      -- Determine where we are going to put the log/scripts
3298      --
3299      -- Determine ORACLE_HOME value
3300      EXECUTE IMMEDIATE 'SELECT NLS_UPPER(platform_name) FROM v$database'
3301         INTO platform;
3302  
3303      EXECUTE IMMEDIATE 'SELECT value FROM v$parameter where '
3304         || 'name=''db_unique_name'''
3305        INTO uniqueName;
3306  
3307      -- Default to $ORACLE_BASE/cfgtoollogs/<db-unique-name>/preupgrade
3308      --  if $ORACLE_BASE is not defined then use
3309      -- $ORACLE_HOME/cfgtoollogs/<db-unique-name>/preupgrade
3310      -- if $ORACLE_HOME is not defined then error
3311  
3312      DBMS_SYSTEM.GET_ENV('ORACLE_BASE', baseDir);
3313      DBMS_SYSTEM.GET_ENV('ORACLE_HOME', homeDir);
3314  
3315      IF homeDir IS NULL THEN
3316        pOutputLocation := NULL;
3317        pOutputVerified := FALSE;
3318        DisplayLine('Warning:  ORACLE_HOME is not defined');
3319        DisplayLine('          Terminal output only');
3320        RETURN;
3321      END IF;
3322  
3323      IF baseDir IS NOT NULL THEN
3324        useDir := baseDir;
3325      ELSE
3326        useDir := homeDir;
3327      END IF;
3328  
3329      --
3330      -- Setup logDir and rdbmsLogDir, starting with useDir as the
3331      -- default.
3332      --
3333      IF INSTR(platform, 'WINDOWS') != 0 THEN
3334        -- Windows, use '\'
3335        useDir := RTRIM(useDir, '\');  -- Remove any trailing slashes
3336        logDir := dbms_assert.enquote_literal(
3337                useDir
3338             || '\cfgtoollogs\'
3339             || uniqueName
3340             || '\preupgrade\');
3341        rdbmsLogDir := homeDir || '\rdbms\log\';
3342      ELSIF INSTR(platform, 'VMS') != 0 THEN
3343        -- VMS, use [] and .
3344        logDir := dbms_assert.enquote_literal (REPLACE (
3345              useDir
3346           || '[cfgtoollogs.'
3347           ||  uniqueName
3348           || '.preupgrade]', '][', '.'));
3349        rdbmsLogDir := REPLACE(homeDir || '[rdbms.log]', '][', '.');
3350      ELSE
3351        -- Unix and z/OS, '/'
3352        useDir := RTRIM(useDir, '/');  -- Remove any trailing slashes
3353        logDir := dbms_assert.enquote_literal(
3354                useDir
3355             || '/cfgtoollogs/'
3356             || uniqueName
3357             || '/preupgrade/');
3358        rdbmsLogDir := homeDir || '/rdbms/log/';
3359      END IF;
3360    END IF;
3361  
3362    --
3363    -- Load in the Java piece
3364    --
3365    status := 1;
3366    javaOK := 0;
3367  
3368    IF dbms_registry.is_valid('JAVAVM',dbms_registry.release_version) = 1 THEN
3369      BEGIN
3370        -- Because of the dbms_assert checks we know we are getting a string with
3371        -- leading and trailing single quotes as the path.  We need to remove those
3372        -- single quotes before using the passed path variable.
3373        EXECUTE IMMEDIATE '
3374          CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED "PreupCreateDir" AS
3375            import java.lang.*;
3376            import java.util.*;
3377            import java.io.*;
3378  
3379            public class PreupCreateDir
3380            {
3381              public static int create (String path)
3382              {
3383                path = path.substring(1,path.length()-1); /* Take off leading/trailing quotes */
3384                File myFile = new File(path);
3385                if (myFile.exists())
3386                {
3387                  if (myFile.canWrite())
3388                    return 1;  /* Directory exists and is writable, OK */
3389                  else
3390                    return 2;  /* Directory exists and is not writable, NOT OK */
3391                }
3392                else
3393                {
3394                  if (myFile.mkdirs())
3395                    return 1;  /* Directory created, OK */
3396                  else
3397                    return 4;  /* Directory could not be created, NOT OK */
3398                }
3399              }
3400            }';
3401          javaOK := 1;
3402          EXCEPTION
3403            WHEN classInUse THEN javaOK := 1;  -- already created
3404            WHEN OTHERS THEN     javaOK := 0;
3405      END;
3406  
3407      IF javaOK = 1 THEN
3408        createString := javaCreate;
3409      ELSE
3410        --  Create dummy version if the java create failed
3411        createString := dummyCreate;
3412      END IF;
3413    ELSE
3414      -- JavaVM is not present or in an invalid state
3415      --
3416      -- Create dummy version of PreupCreateDir so subsequent
3417      -- blocks will compile
3418      createString := dummyCreate;
3419    END IF;
3420    EXECUTE IMMEDIATE createString;
3421  
3422    IF javaOK = 1 THEN
3423      DECLARE
3424        --
3425        -- This exception is command and is handled by ending
3426        -- the session inside the loop.
3427        --
3428        JavaSessionCleared EXCEPTION;
3429        PRAGMA EXCEPTION_INIT(JavaSessionCleared, -29549);
3430      BEGIN
3431        clearJava := FALSE;
3432        status := 0;
3433        FOR tries IN 1..2 LOOP
3434          BEGIN
3435            EXECUTE IMMEDIATE 'CALL PreupCreateDir(:1) into :2'
3436            USING IN logDir, OUT status;
3437          EXCEPTION
3438            WHEN JavaSessionCleared THEN  clearJava := TRUE;
3439            WHEN OTHERS THEN
3440             IF usingExistingDef = FALSE THEN
3441               logDir := dbms_assert.enquote_literal(rdbmsLogDir);
3442             ELSE
3443               -- Can't do anything, exit the loop
3444               EXIT;
3445             END IF;
3446          END;
3447  
3448          IF clearJava THEN
3449            -- Clear state and try again
3450            -- Use dynamic SQL since dbms_java may not be installed
3451            BEGIN
3452              EXECUTE IMMEDIATE 'BEGIN :1 := dbms_java.endsession; END;'
3453              USING OUT dummy;
3454            EXCEPTION WHEN OTHERS THEN NULL;
3455            END;
3456          ELSIF status = 1 THEN
3457            -- Success, exit loop
3458            EXIT;
3459          ELSIF status = 2 THEN
3460            --
3461            -- Directory exists, not writeable
3462            --
3463            IF usingExistingDef = FALSE THEN
3464              --
3465              -- We said where to create the dir, and it failed,
3466              -- try the rdbmdLogDir area
3467              --
3468              logDir := dbms_assert.enquote_literal(rdbmsLogDir);
3469            ELSE
3470              --
3471              -- They specified an area, and we can't write to it.
3472              --
3473              EXIT;
3474            END IF;
3475          ELSE
3476            --
3477            -- status = 4 = could not create the directory
3478            --
3479            EXIT;
3480          END IF;
3481        END LOOP;
3482      END;
3483      --
3484      -- done with the java, clean it up
3485      --
3486      BEGIN
3487        EXECUTE IMMEDIATE 'DROP JAVA SOURCE "PreupCreateDir"';
3488      EXCEPTION WHEN OTHERS THEN NULL;
3489      END;
3490  
3491      --
3492      -- end the session
3493      --
3494      BEGIN
3495        EXECUTE IMMEDIATE 'BEGIN :1 := dbms_java.endsession; END;'
3496        USING OUT dummy;
3497      EXCEPTION WHEN OTHERS THEN NULL;
3498      END;
3499    END IF;
3500  
3501    --
3502    -- Even if we failed to verify things, try to create the
3503    -- default directory.
3504    --
3505    IF usingExistingDef = FALSE THEN
3506      --
3507      -- Try to create the directory object for the actual directory
3508      -- the javascript created or verified existed
3509      --
3510      BEGIN
3511        EXECUTE IMMEDIATE
3512          'CREATE DIRECTORY ' || c_dir_obj || ' AS ' || logDir ;
3513        EXCEPTION
3514          WHEN nameAlreadyExists THEN pCreatedDirObj := FALSE;
3515          WHEN OTHERS THEN status := 0;
3516      END;
3517  
3518      IF status = 0 THEN
3519        pOutputLocation := NULL;
3520        pOutputVerified := FALSE;
3521        DisplayLine('WARNING: Unable to create required directory object');
3522        DisplayLine('         Terminal output only');
3523        RETURN;
3524      END IF;
3525      BEGIN
3526        -- 10.n gives an error on granting to sys, just ignore it.
3527        EXECUTE IMMEDIATE
3528         'GRANT READ,WRITE ON DIRECTORY ' || c_dir_obj || ' TO SYS';
3529        EXCEPTION WHEN OTHERS THEN NULL;
3530      END;
3531    END IF;  -- Using Existing Def = false
3532  
3533    IF status != 1 THEN
3534      --
3535      -- something went wrong with the java (or it was not even executed)
3536      --
3537      pOutputLocation := NULL;
3538      pOutputVerified := FALSE;
3539  
3540      IF status = 2 THEN
3541        -- A two means we can't write to the area.
3542        tmp_varchar := 'Unable to write to  directory ';
3543      ELSIF status = 4 THEN
3544        -- Only other is a 4 which means we couldn't create the dir
3545        tmp_varchar := 'Unable to create directory ';
3546      ELSE
3547        -- 0 ?  Could not verify/create because of JAVA
3548        tmp_varchar := 'Unable to verify or create directory ';
3549      END IF;
3550  
3551      IF usingExistingDef = TRUE THEN
3552        --
3553        -- Tell them we tried to use their existing dir object and it failed
3554        --
3555        DisplayLine('WARNING: ' || tmp_varchar || logDir
3556                || ' for existing Directory Object: ' || c_dir_obj);
3557      ELSE
3558        --
3559        -- We failed to create the directory that we want
3560        --
3561        DisplayLine('WARNING: ' || tmp_varchar || logDir
3562                || ' for Directory Object: ' || c_dir_obj);
3563      END IF;
3564      --
3565      -- Finish it off and get out.
3566      --
3567      DisplayLine('     script will generate terminal output only');
3568      RETURN;
3569    END IF;
3570  
3571    --
3572    -- Set the package variable (will be used for utl_file)
3573    --
3574    pOutputLocation := c_dir_obj;
3575    pOutputVerified := TRUE;
3576  
3577  END verifyDefaultDirObj;
3578  
3579  PROCEDURE start_xml_document
3580  IS
3581  BEGIN
3582    init_package;
3583    DisplayLine ('<RDBMSUP xmlns="http://www.oracle.com/Upgrade" version="'
3584            || c_version || '">');
3585  END start_xml_document;
3586  
3587  PROCEDURE end_xml_document
3588  IS
3589  BEGIN
3590     DisplayLine ('</RDBMSUP>');
3591  END end_xml_document;
3592  
3593  -- ****************************************************************************
3594  -- Run a specific check, but don't generate any fixup script or output
3595  -- Do that by setting the 'pCheckOnly' package level variable then execute
3596  -- the check
3597  -- ****************************************************************************
3598  FUNCTION run_check_simple (check_name VARCHAR2) RETURN check_record_t
3599  IS
3600    t_check_rec    check_record_t;
3601    execute_failed BOOLEAN := FALSE;
3602    idx            NUMBER;
3603    retval         NUMBER;
3604    check_stmt     VARCHAR2(100);
3605    r_text         VARCHAR2(1000);
3606  
3607  BEGIN
3608    init_package;
3609  
3610    IF check_names.EXISTS(check_name) = FALSE
3611    THEN
3612      EXECUTE IMMEDIATE 'BEGIN
3613        RAISE_APPLICATION_ERROR (-20000,
3614              ''Pre-Upgrade Package Requested Check does not exist''); END;';
3615        RETURN (NULL);
3616    END IF;
3617    idx := check_names(check_name).idx;
3618  
3619    pCheckOnly := TRUE;
3620  
3621    IF check_table(idx).always_fail THEN
3622      --
3623      -- We want to fail this check, set the global
3624      -- so the package checks know to fail
3625      --
3626      pDBGFailCheck := TRUE;
3627    END IF;
3628  
3629    -- Clear out the info about the check before
3630    -- executing it (only an issue during re-run)
3631    --
3632    check_table(idx).passed         := FALSE;
3633    check_table(idx).skipped        := FALSE;
3634    check_table(idx).executed       := FALSE;
3635    check_table(idx).execute_failed := FALSE;
3636    check_table(idx).fixup_executed := FALSE;
3637    check_table(idx).fixup_failed   := FALSE;
3638    check_table(idx).always_fail    := FALSE;
3639  
3640    check_stmt := 'BEGIN :r1 := dbms_preup.'
3641       || dbms_assert.simple_sql_name(check_table(idx).f_name_prefix)
3642       ||  '_check (:rtxt); END;';
3643  
3644    BEGIN
3645      EXECUTE IMMEDIATE check_stmt
3646         USING OUT retval, IN OUT r_text;
3647      EXCEPTION WHEN OTHERS THEN
3648        execute_failed := TRUE;
3649    END;
3650  
3651    --
3652    -- Save away the results of the check
3653    --
3654    t_check_rec.executed := TRUE;
3655  
3656    IF execute_failed = TRUE
3657    THEN
3658      -- Passed is already FALSE
3659      t_check_rec.execute_failed := TRUE;
3660    ELSE
3661      IF retval = c_status_success THEN
3662        t_check_rec.passed := TRUE;
3663      ELSIF retval = c_status_not_for_this_version THEN
3664        t_check_rec.passed := TRUE;
3665        t_check_rec.skipped := TRUE;
3666      ELSE
3667        -- Passed is already FALSE
3668        t_check_rec.result_text := r_text;
3669      END IF;
3670    END IF;
3671  
3672    --
3673    -- Always turn these off
3674    --
3675    pDBGFailCheck := FALSE;
3676    pCheckOnly := FALSE;
3677  
3678    return t_check_rec;
3679  END run_check_simple;
3680  
3681  -- ****************************************************************************
3682  -- Same as run_check_simple only return true/false
3683  -- ****************************************************************************
3684  FUNCTION condition_exists (check_name VARCHAR2) RETURN BOOLEAN
3685  IS
3686    t_check_rec    check_record_t := NULL;
3687    execute_failed BOOLEAN := FALSE;
3688    idx            NUMBER;
3689    retval         NUMBER;
3690    check_stmt     VARCHAR2(100);
3691    r_text         VARCHAR2(1000);
3692  
3693  BEGIN
3694    init_package;
3695  
3696    t_check_rec := dbms_preup.run_check_simple(check_name);
3697  
3698    IF t_check_rec.passed THEN
3699      RETURN FALSE;
3700    ELSE
3701      RETURN TRUE;
3702    END IF;
3703  END condition_exists;
3704  
3705  
3706  FUNCTION run_check (check_name VARCHAR2) RETURN check_record_t
3707  IS
3708    execute_failed    BOOLEAN := FALSE;
3709    idx               NUMBER;
3710    retval            NUMBER;
3711    check_stmt        VARCHAR2(100);
3712    r_text            VARCHAR2(1000);
3713  
3714  BEGIN
3715  
3716    init_package;
3717  
3718    IF check_names.EXISTS(check_name) = FALSE
3719    THEN
3720      EXECUTE IMMEDIATE 'BEGIN
3721        RAISE_APPLICATION_ERROR (-20000,
3722              ''Pre-Upgrade Package Requested Check does not exist''); END;';
3723        return (NULL);
3724    END IF;
3725    idx := check_names(check_name).idx;
3726  
3727    IF check_table(idx).always_fail THEN
3728      --
3729      -- We want to fail this check, set the global
3730      -- so the package checks know to fail
3731      --
3732      pDBGFailCheck := TRUE;
3733    END IF;
3734  
3735    -- Clear out the info about the check before
3736    -- executing it (only an issue during re-run)
3737    --
3738    check_table(idx).passed         := FALSE;
3739    check_table(idx).skipped        := FALSE;
3740    check_table(idx).executed       := FALSE;
3741    check_table(idx).execute_failed := FALSE;
3742    check_table(idx).fixup_executed := FALSE;
3743    check_table(idx).fixup_failed   := FALSE;
3744    check_table(idx).always_fail    := FALSE;
3745  
3746    --
3747    -- This executes the check procedure
3748    -- An example would be
3749    --
3750    --  BEGIN :r1 := purge_recyclebin_check(r_text); END;
3751    --
3752  
3753    check_stmt := 'BEGIN :r1 := dbms_preup.'
3754        || dbms_assert.simple_sql_name(check_table(idx).f_name_prefix)
3755        ||  '_check (:rtxt); END;';
3756  
3757    BEGIN
3758      EXECUTE IMMEDIATE check_stmt
3759         USING OUT retval, IN OUT r_text;
3760      EXCEPTION WHEN OTHERS THEN
3761        execute_failed := TRUE;
3762    END;
3763  
3764    --
3765    -- Save away the results of the check
3766    --
3767    check_table(idx).executed := TRUE;
3768  
3769    if execute_failed = TRUE
3770    THEN
3771      check_table(idx).execute_failed := TRUE;
3772      check_table(idx).passed := FALSE;
3773    ELSE
3774      IF retval = c_status_success THEN
3775        check_table(idx).passed := TRUE;
3776      ELSIF retval = c_status_not_for_this_version THEN
3777        check_table(idx).passed := TRUE;
3778        check_table(idx).skipped := TRUE;
3779      ELSE
3780        check_table(idx).passed := FALSE;
3781        check_table(idx).result_text := r_text;
3782      END IF;
3783    END IF;
3784    --
3785    -- Always turn this off
3786    --
3787    pDBGFailCheck := FALSE;
3788    return (check_table(idx));
3789  END run_check;
3790  
3791  --
3792  -- Run a check, dump out the results, no script created
3793  --
3794  PROCEDURE run_check (check_name VARCHAR2)
3795  IS
3796    t_check_rec     check_record_t;
3797    execute_failed  BOOLEAN := FALSE;
3798    checkonly       BOOLEAN;
3799    idx             NUMBER;
3800    retval          NUMBER;
3801    check_stmt      VARCHAR2(100);
3802    r_text          VARCHAR2(1000);
3803  
3804  BEGIN
3805  
3806    init_package;
3807  
3808    IF check_names.EXISTS(check_name) = FALSE
3809    THEN
3810      EXECUTE IMMEDIATE 'BEGIN
3811        RAISE_APPLICATION_ERROR (-20000,
3812              ''Pre-Upgrade Package Requested Check does not exist''); END;';
3813        return;
3814    END IF;
3815  
3816    checkonly := pCheckOnly;
3817    pCheckOnly := TRUE;
3818  
3819    idx := check_names(check_name).idx;
3820  
3821    --
3822    -- Because the info is not recorded in our check_table,
3823    -- the run status fields do not need to be cleared)
3824    --
3825  
3826    --
3827    -- This executes the check procedure
3828    -- An example would be
3829    --
3830    --  BEGIN :r1 := purge_recyclebin_check(r_text); END;
3831    --
3832    check_stmt := 'BEGIN :r1 := dbms_preup.'
3833      || dbms_assert.simple_sql_name(check_table(idx).f_name_prefix)
3834      ||  '_check (:rtxt); END;';
3835  
3836    BEGIN
3837      EXECUTE IMMEDIATE check_stmt
3838         USING OUT retval, IN OUT r_text;
3839      EXCEPTION WHEN OTHERS THEN
3840        execute_failed := TRUE;
3841    END;
3842  
3843    DisplayLinePL('');
3844    DisplayLinePL('**********************************************************************');
3845    DisplayLinePL('Check Tag:       ' || check_table(idx).name);
3846    DisplayLinePL('Check Summary:   ' || check_table(idx).descript);
3847    DisplayLinePL('Check Help Text: ');
3848    DisplayLinePL('  ' || getHelp(check_table(idx).name,c_help_overview));
3849    DisplayLinePL('Fixup Summary: ');
3850    DisplayLinePL('  ' || getHelp(check_table(idx).name,c_help_fixup));
3851    DisplayLinePL('');
3852  
3853  
3854    IF execute_failed = TRUE THEN
3855      DisplayLinePL(CenterLine('**** Check Failed to Execute ****'));
3856    ELSE
3857      IF retval = c_status_success THEN
3858        DisplayLinePL('++++ Check Passed');
3859      ELSIF retval = c_status_not_for_this_version THEN
3860        DisplayLinePL('++++ Check Not Valid from your current release.');
3861      ELSE
3862        DisplayLinePL('++++ Check Failed:');
3863        DisplayLinePL('   ' || r_text);
3864      END IF;
3865    END IF;
3866    --
3867    -- Restore setting
3868    --
3869    pCheckOnly := checkonly;
3870  END run_check;
3871  
3872  PROCEDURE run_fixup_and_report (check_name VARCHAR2)
3873  IS
3874    --
3875    -- Run a check and dump any errors out to stdout.
3876    -- This procedure is used by the fixup scripts.
3877    -- "set server output on" must be executed before and
3878    -- must be connected as SYS
3879    --
3880    -- NOTE:
3881    --   This function is intended to be run OUTSIDE of the preupgrade
3882    --   checks, therefore, its output is displayed to the terminal or
3883    --   redirected location specified (spool) and not to the preupgrade
3884    --   log file.
3885    --
3886    idx          NUMBER;
3887    retval       NUMBER;
3888    r_sqlcode    NUMBER := 0;
3889    check_stmt   VARCHAR2(100);
3890    r_text       VARCHAR2(1500);
3891  
3892  BEGIN
3893    init_package;
3894  
3895    IF check_names.EXISTS(check_name) = FALSE
3896    THEN
3897      RAISE_APPLICATION_ERROR (-20000,
3898              'Pre-Upgrade Package Requested Fixup: ' ||
3899              check_name || ' does not exist');
3900      RETURN;
3901    END IF;
3902    idx := check_names(check_name).idx;
3903  
3904    --
3905    -- This executes the fixup procedure,
3906    -- An example would be
3907    --
3908    --  BEGIN :r1 := purge_recyclebin_fixup(r_text, r_sqlcode); END;
3909    --
3910  
3911    check_stmt := 'BEGIN :r1 := dbms_preup.'
3912       || dbms_assert.simple_sql_name(check_table(idx).f_name_prefix)
3913       || '_fixup (:rtxt, :rsqlcode); END;';
3914  
3915    --
3916    -- No exception catching here, let the lower levels catch
3917    -- and return the problems.
3918    --
3919    DisplayLinePL('');
3920    DisplayLinePL('**********************************************************************');
3921    DisplayLinePL('Check Tag:     ' || check_table(idx).name);
3922    DisplayLinePL('Check Summary: ' || check_table(idx).descript);
3923    DisplayLinePL('Fix Summary:   ' || getHelp(check_table(idx).name,c_help_fixup));
3924    DisplayLinePL('**********************************************************************');
3925  
3926    --
3927    -- Clear out the existing values
3928    --
3929    check_table(idx).fixup_executed := FALSE;
3930    check_table(idx).result_text    := '';
3931    check_table(idx).sqlcode        := 0;
3932  
3933    EXECUTE IMMEDIATE check_stmt
3934       USING OUT retval, IN OUT r_text, IN OUT r_sqlcode;
3935  
3936    --
3937    -- Save away the results of the fixup
3938    --
3939    check_table(idx).fixup_executed := TRUE;
3940    check_table(idx).result_text    := r_text;
3941    check_table(idx).sqlcode        := r_sqlcode;
3942    check_table(idx).fixup_status   := retval;
3943  
3944    IF retval = c_fixup_status_success THEN
3945      check_table(idx).fixup_failed := FALSE;
3946      DisplayLinePL('Fixup Succeeded');
3947    ELSIF retval = c_fixup_status_info THEN
3948      -- The fixup wants to return some text, display it here
3949      check_table(idx).fixup_failed := FALSE;
3950      DisplayLinePL('Fixup Returned Information:');
3951      DisplayLinePL(check_table(idx).result_text);
3952    ELSE
3953      check_table(idx).fixup_failed := TRUE;
3954      DisplayLinePL('Fixup Failed:');
3955      DisplayLinePL  (check_table(idx).result_text);
3956      DisplayLinePL  ('SQL Code: ' || check_table(idx).sqlcode);
3957    END IF;
3958    DisplayLinePL('**********************************************************************');
3959    DisplayLinePL('');
3960    return;
3961  END run_fixup_and_report;
3962  
3963  
3964  PROCEDURE run_fixup_info (check_name VARCHAR2)
3965  IS
3966    --
3967    -- Run a check, and instead of returning a record with the info
3968    -- on the run (which is what run_check does), This grabs the return
3969    -- text from the fixup routine and displays it.
3970    -- This is only used for those fixup functions that can not do
3971    -- anything for the existing issue, but we need to display some
3972    -- text.
3973    --
3974    -- NOTE:
3975    --   This function is intended to be run OUTSIDE of the preupgrade
3976    --   checks, therefore, its output is displayed to the terminal or
3977    --   redirected location specified and not to the preupgrade
3978    --   log file.
3979    --
3980    idx          NUMBER;
3981    retval       NUMBER;
3982    r_sqlcode    NUMBER := 0;
3983    check_stmt   VARCHAR2(100);
3984    r_text       VARCHAR2(1000);
3985  
3986  BEGIN
3987    init_package;
3988  
3989    IF check_names.EXISTS(check_name) = FALSE
3990    THEN
3991      RAISE_APPLICATION_ERROR (-20000,
3992              'Pre-Upgrade Package Requested Fixup: ' ||
3993              check_name || ' does not exist');
3994      RETURN;
3995    END IF;
3996    idx := check_names(check_name).idx;
3997  
3998    --
3999    -- This executes the fixup procedure,
4000    -- An example would be
4001    --
4002    --  BEGIN :r1 := purge_recyclebin_fixup(r_text, r_sqlcode); END;
4003    --
4004  
4005    check_stmt := 'BEGIN :r1 := dbms_preup.'
4006       || dbms_assert.simple_sql_name(check_table(idx).f_name_prefix)
4007       || '_fixup (:rtxt, :rsqlcode); END;';
4008  
4009    --
4010    -- No exception catching here, let the lower levels catch
4011    -- and return the problems.
4012    --
4013  
4014    dbms_output.put_line ('------- ---------- Executing Fixup  ------------ ----------');
4015    dbms_output.put_line ('------- ' || RPAD (check_table(idx).name, 40) || ' ----------');
4016  
4017    EXECUTE IMMEDIATE check_stmt
4018       USING OUT retval, IN OUT r_text, IN OUT r_sqlcode;
4019  
4020    --
4021    -- Save away the results of the fixup
4022    --
4023    check_table(idx).fixup_executed := TRUE;
4024    check_table(idx).result_text    := r_text;
4025    check_table(idx).sqlcode        := r_sqlcode;
4026    --
4027    -- don't care about the return status
4028    --
4029    check_table(idx).fixup_failed := FALSE;
4030    dbms_output.put_line ('------- ------------ Fixup Succeeded ----------- ----------');
4031    dbms_output.put_line ('------- ------- Informational Text Returned ---- ----------');
4032    dbms_output.put_line (check_table(idx).result_text);
4033    dbms_output.put_line ('------- ---------------------------------------- ----------');
4034  END run_fixup_info;
4035  
4036  
4037  FUNCTION run_fixup (check_name VARCHAR2) RETURN check_record_t
4038  IS
4039    idx          NUMBER;
4040    retval       NUMBER;
4041    r_sqlcode    NUMBER := 0;
4042    check_stmt   VARCHAR2(100);
4043    r_text       VARCHAR2(1000);
4044  
4045  BEGIN
4046    init_package;
4047  
4048    IF check_names.EXISTS(check_name) = FALSE
4049    THEN
4050      EXECUTE IMMEDIATE 'BEGIN
4051        RAISE_APPLICATION_ERROR (-20000,
4052              ''Pre-Upgrade Package Requested Fixup: '' ||
4053              check_name || '' does not exist''); END;';
4054        return (NULL);
4055    END IF;
4056    idx := check_names(check_name).idx;
4057  
4058    -- This executes the fixup procedure
4059    -- An example would be
4060    --
4061    --  BEGIN :r1 := purge_recyclebin_fixup(r_text, r_sqlcode); END;
4062    --
4063  
4064    check_stmt := 'BEGIN :r1 := dbms_preup.'
4065      || dbms_assert.simple_sql_name(check_table(idx).f_name_prefix)
4066      || '_fixup (:rtxt, :rsqlcode); END;';
4067  
4068    --
4069    -- No exception catching here, let the lower levels catch
4070    -- and return the problems.
4071    --
4072    EXECUTE IMMEDIATE check_stmt
4073       USING OUT retval, IN OUT r_text, IN OUT r_sqlcode;
4074  
4075    --
4076    -- Save away the results of the fixup
4077    --
4078    check_table(idx).fixup_executed := TRUE;
4079    check_table(idx).result_text    := r_text;
4080    check_table(idx).sqlcode        := r_sqlcode;
4081  
4082    IF retval = 1
4083    THEN
4084      check_table(idx).fixup_failed := FALSE;
4085    ELSE
4086      check_table(idx).fixup_failed := TRUE;
4087    END IF;
4088  
4089    return (check_table(idx));
4090  END run_fixup;
4091  
4092  -- ****************************************************************************
4093  --    Debug Functions/Procedures
4094  -- ****************************************************************************
4095  
4096  --
4097  -- Set always_fail for a specific check, causing the check to not
4098  -- actually execute the specific check, but cause it to 'fail'
4099  --
4100  PROCEDURE dbg_check (check_name VARCHAR2)
4101  IS
4102    execute_failed    BOOLEAN := FALSE;
4103    idx               NUMBER;
4104    retval            NUMBER;
4105    check_stmt        VARCHAR2(100);
4106  
4107  BEGIN
4108    init_package;
4109  
4110    IF check_names.EXISTS(check_name) = FALSE
4111    THEN
4112      EXECUTE IMMEDIATE 'BEGIN
4113        RAISE_APPLICATION_ERROR (-20000,
4114              ''Pre-Upgrade Package Requested Check does not exist''); END;';
4115    END IF;
4116    idx := check_names(check_name).idx;
4117    check_table(idx).always_fail := TRUE;
4118  END dbg_check;
4119  
4120  --
4121  -- Set All the checks always_fail to TRUE
4122  --
4123  PROCEDURE dbg_all_checks
4124  IS
4125  BEGIN
4126    init_package;
4127  
4128    FOR i IN 1..pCheckCount LOOP
4129      check_table(i).always_fail := TRUE;
4130    END LOOP;
4131    pDBGFailAll := TRUE;
4132  END dbg_all_checks;
4133  
4134  --
4135  -- Turn on or off the output of space information into
4136  -- the log
4137  --
4138  PROCEDURE dbg_space_resources (onoff BOOLEAN)
4139  IS
4140  BEGIN
4141    init_package;
4142    pDBGSizeResources := onoff;
4143  END dbg_space_resources;
4144  
4145  --
4146  -- Turn on or off the output of resource information
4147  -- (as if there is an issue with each resource)
4148  --
4149  PROCEDURE dbg_all_resources (onoff BOOLEAN)
4150  IS
4151  BEGIN
4152    init_package;
4153    pDBGAllResources := onoff;
4154  END dbg_all_resources;
4155  
4156  --
4157  -- Output the result text of a check
4158  --
4159  PROCEDURE  display_check_text (check_record check_record_t )
4160  IS
4161  BEGIN
4162     DisplayLine (check_record.result_text);
4163  END display_check_text;
4164  
4165  -- ****************************************************************************
4166  --    General utility functions
4167  -- ****************************************************************************
4168  
4169  --------------------------- pvalue_to_number --------------------------------
4170  -- This function converts a parameter string to a number. The function takes
4171  -- into account that the parameter string may have a 'K' or 'M' multiplier
4172  -- character.
4173  FUNCTION pvalue_to_number (value_string VARCHAR2) RETURN NUMBER
4174  IS
4175    ilen NUMBER;
4176    pvalue_number NUMBER;
4177  
4178  BEGIN
4179      -- How long is the input string?
4180      ilen := LENGTH ( value_string );
4181  
4182      -- Is there a 'K' or 'M' in last position?
4183      IF SUBSTR(UPPER(value_string), ilen, 1) = 'K' THEN
4184           RETURN (c_kb * TO_NUMBER (SUBSTR (value_string, 1, ilen-1)));
4185  
4186      ELSIF SUBSTR(UPPER(value_string), ilen, 1) = 'M' THEN
4187           RETURN (c_mb * TO_NUMBER (SUBSTR (value_string, 1, ilen-1)));
4188      END IF;
4189  
4190      -- A multiplier wasn't found. Simply convert this string to a number.
4191      RETURN (TO_NUMBER (value_string));
4192  END pvalue_to_number;
4193  
4194  PROCEDURE store_oldval (minvp  IN OUT MINVALUE_TABLE_T)
4195  IS
4196    c_value   VARCHAR2(80);
4197    i         INTEGER;
4198  BEGIN
4199    FOR i IN 1..max_minvp LOOP
4200      BEGIN
4201        EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE name =
4202           LOWER(:1)'
4203        INTO c_value
4204        USING minvp(i).name;
4205        minvp(i).oldvalue := pvalue_to_number(c_value);
4206      EXCEPTION WHEN NO_DATA_FOUND THEN
4207           minvp(i).oldvalue := NULL;
4208      END;
4209    END LOOP;
4210  
4211    -- After getting init ora values:
4212    -- Parameter streams_pool_size is not available in 92. Set old value to 0.
4213    IF (db_n_version = 920) THEN
4214      minvp(str_idx).oldvalue := 0;
4215    END IF;
4216  END store_oldval;
4217  
4218  PROCEDURE store_renamed (i   IN OUT BINARY_INTEGER,
4219                           old VARCHAR2,
4220                           new VARCHAR2)
4221  IS
4222  BEGIN
4223    i:= i+1;
4224    rp(i).oldname:=old;
4225    rp(i).newname:=new;
4226  END store_renamed;
4227  
4228  PROCEDURE store_removed (i IN OUT BINARY_INTEGER,
4229                           name       VARCHAR2,
4230                           version    VARCHAR2,
4231                           deprecated BOOLEAN)
4232  IS
4233  BEGIN
4234    i:=i+1;
4235    op(i).name:=name;
4236    op(i).version:=version;
4237    op(i).deprecated:=deprecated;
4238  END store_removed;
4239  
4240  PROCEDURE store_special (i    IN OUT BINARY_INTEGER,
4241                           old  VARCHAR2,
4242                           oldv VARCHAR2,
4243                           new  VARCHAR2,
4244                           newv VARCHAR2)
4245  IS
4246  BEGIN
4247    i:= i+1;
4248    sp(i).oldname      := old;
4249    sp(i).oldvalue     := oldv;
4250    sp(i).newname      := new;
4251    sp(i).newvalue     := newv;
4252    sp(i).db_match     := FALSE;
4253    sp(i).dbua_OutInUpdate := FALSE;
4254  END store_special;
4255  
4256  PROCEDURE store_required (i    IN OUT BINARY_INTEGER,
4257                           name  VARCHAR2,
4258                           newvn NUMBER,
4259                           newvs VARCHAR2,
4260                           dtype NUMBER)
4261  --
4262  -- Pass a 0, or '', for the newvn (new value numeric) or
4263  -- that you are not setting.
4264  --    store_required(idx, 'foo', 0, 'bar', 2);
4265  -- would mean a string value of 'bar' is expected
4266  --
4267  IS
4268  BEGIN
4269    i:= i+1;
4270    reqp(i).name:=name;
4271    reqp(i).newnumbervalue:=newvn;
4272    reqp(i).newstringvalue:=newvs;
4273    reqp(i).type:= dtype;
4274    reqp(i).db_match:=FALSE;
4275  END store_required;
4276  
4277  PROCEDURE find_newval (minvp  IN OUT MINVALUE_TABLE_T,
4278                         dbbit  NUMBER)
4279  IS
4280    extra    NUMBER;
4281  BEGIN
4282  
4283    IF minvp(tg_idx).oldvalue != 0 THEN  -- SGA_TARGET in use
4284      find_sga_mem_values(minvp, dbbit);
4285  
4286      IF minvp(tg_idx).newvalue > minvp(tg_idx).oldvalue THEN
4287        minvp(tg_idx).display := TRUE;
4288      END IF;
4289  
4290      -- do not set display to TRUE for these params: sga_target,
4291      -- memory_target, db_cache_size, java_pool_size,
4292      -- shared_pool_size, large_pool_size, and streams_pool_size
4293      FOR i IN 1..max_minvp LOOP
4294        IF i NOT IN (tg_idx,mt_idx,cs_idx,jv_idx,sp_idx,lp_idx,str_idx) AND
4295            (minvp(i).oldvalue IS NULL OR
4296            minvp(i).oldvalue < minvp(i).minvalue) THEN
4297          minvp(i).display := TRUE;
4298          minvp(i).newvalue := minvp(i).minvalue;
4299        END IF;
4300      END LOOP;
4301    ELSE -- pool sizes included
4302      FOR i IN 1..max_minvp LOOP
4303        -- don't print recommendations for sga_target, memory_target,
4304        -- large_pool_size, and streams_pool_size
4305        IF i NOT IN (tg_idx,mt_idx,lp_idx,str_idx) AND
4306            (minvp(i).oldvalue IS NULL OR
4307             minvp(i).oldvalue < minvp(i).minvalue) THEN
4308          minvp(i).display := TRUE;
4309          minvp(i).newvalue := minvp(i).minvalue;
4310        END IF;
4311      END LOOP;
4312    END IF;
4313  
4314    -- For 11.1 and 11.2 check if MEMORY_TARGET is set and NON-ZERO
4315    -- then check that MEMORY_TARGET is at least 12M greater than
4316    -- sga_target + pga_target (for cases where SGA_TARGET is in use)
4317    IF db_n_version IN (111,112) AND
4318         db_memory_target AND (minvp(mt_idx).oldvalue != 0) THEN
4319      find_sga_mem_values(minvp, dbbit);
4320  
4321      -- If the newvalue is greater than the old value set the display TRUE
4322      IF minvp(mt_idx).newvalue > minvp(mt_idx).oldvalue THEN
4323        minvp(mt_idx).display := TRUE;
4324        -- Loop through other pool sizes to ignore warnings
4325        -- If displaying MEMORY_TARGET warning then the other
4326        -- pool sizes do not need warnings
4327      END IF;
4328  
4329      -- If a minimum value is required for MEMORY_TARGET then
4330      -- do not output a minimum value for sga_target or pga_aggregate
4331      -- or shared_pool_size or java_pool_size or db_cache_size or
4332      -- large_pool_size or streams_pool_size as these values
4333      -- are no longer considered once MEMORY_TARGET value is set.
4334      -- i.e., for params listed above, set display to FALSE if memory_target
4335      -- is set.
4336      FOR i IN 1..max_minvp LOOP
4337        IF i IN (tg_idx,pg_idx,sp_idx,jv_idx,cs_idx,lp_idx,str_idx) AND minvp(i).display THEN
4338          minvp(i).display := FALSE;
4339        END IF;
4340      END LOOP;
4341    END IF; -- 11.1/11.2 db and memory_target in use
4342  END find_newval;
4343  
4344  --------------------------- find_sga_mem_values -------------------------------
4345  -- This is called when sga_target or memory_target is used.
4346  
4347  PROCEDURE find_sga_mem_values (minvp  IN OUT MINVALUE_TABLE_T,
4348                                 dbbit  NUMBER)
4349  IS
4350    cpucalc   NUMBER;
4351    extra     NUMBER;
4352    mtgval    NUMBER;
4353  BEGIN
4354  
4355    -- We're here because sga_target/memory_target is used.
4356    -- Need to find new values for sga_target.
4357  
4358    -- First, reset min values for pools related to sga_target.
4359  
4360    -- If db_cpus is < 12, then calculate sga_target using 12 cpus.
4361    -- If db_cpus is >= 12, then calculate sga_target using cpu_count.
4362    -- If db_cpus is >= 64, then calculate sga_target using 64 cpus.
4363    -- At this point, we don't have enough data to size for greater than 64 cpus.
4364    IF (db_cpus >= 64) THEN
4365      cpucalc := 64;
4366    ELSIF (db_cpus >= 12) THEN
4367      cpucalc := db_cpus;
4368    ELSIF (db_cpus < 12) THEN
4369      cpucalc := 12;
4370    END IF;
4371  
4372    minvp(cs_idx).minvalue := cpucalc*4 * c_mb;
4373    minvp(str_idx).minvalue := 0;  -- 0M
4374  
4375    IF dbbit = 32 THEN
4376      minvp(jv_idx).minvalue := 64 * c_mb;
4377      minvp(sp_idx).minvalue := 180 * c_mb;
4378      minvp(lp_idx).minvalue := (cpucalc*2*2 * .5) * c_mb;
4379      extra := (8 + 32 + 56) * c_mb;  -- 96M
4380    ELSE
4381      minvp(jv_idx).minvalue := 100 * c_mb;
4382      minvp(sp_idx).minvalue := 280 * c_mb;
4383      minvp(lp_idx).minvalue := (cpucalc*2*2 * .5) * c_mb;
4384      extra := (8*2+32*2+28+20+16) * c_mb;  -- 144M
4385    END IF;
4386  
4387    minvp(tg_idx).minvalue :=
4388      minvp(cs_idx).minvalue + minvp(jv_idx).minvalue +
4389      minvp(sp_idx).minvalue + minvp(lp_idx).minvalue +
4390      minvp(str_idx).minvalue + extra;
4391  
4392    minvp(mt_idx).minvalue :=
4393      minvp(cs_idx).minvalue + minvp(jv_idx).minvalue +
4394      minvp(sp_idx).minvalue + minvp(lp_idx).minvalue +
4395      minvp(str_idx).minvalue + minvp(pg_idx).minvalue + extra;
4396  
4397    -- buffer cache (cs)
4398    IF minvp(cs_idx).oldvalue > minvp(cs_idx).minvalue THEN
4399      minvp(cs_idx).diff := minvp(cs_idx).oldvalue - minvp(cs_idx).minvalue;
4400    END IF;
4401  
4402    -- java pool (jv)
4403    IF minvp(jv_idx).oldvalue > minvp(jv_idx).minvalue THEN
4404      minvp(jv_idx).diff := minvp(jv_idx).oldvalue - minvp(jv_idx).minvalue;
4405    END IF;
4406  
4407    -- shared pool (sp)
4408    IF minvp(sp_idx).oldvalue > minvp(sp_idx).minvalue THEN
4409      minvp(sp_idx).diff := minvp(sp_idx).oldvalue - minvp(sp_idx).minvalue;
4410    END IF;
4411  
4412    -- large pool (lp)
4413    IF minvp(lp_idx).oldvalue > minvp(lp_idx).minvalue THEN
4414      minvp(lp_idx).diff := minvp(lp_idx).oldvalue - minvp(lp_idx).minvalue;
4415    END IF;
4416  
4417    -- streams pool (str)
4418    IF minvp(str_idx).oldvalue > minvp(str_idx).minvalue THEN
4419      minvp(str_idx).diff :=
4420        minvp(str_idx).oldvalue - minvp(str_idx).minvalue;
4421    END IF;
4422  
4423    -- pga_aggregate_target (pg)
4424    IF minvp(pg_idx).oldvalue > minvp(pg_idx).minvalue THEN
4425      minvp(pg_idx).diff :=
4426        minvp(pg_idx).oldvalue - minvp(pg_idx).minvalue;
4427    END IF;
4428  
4429    -- calculate sga_target 'newvalue' (new derived minimum) based on
4430    -- tg_idx.minvalue and user-specified pool sizes
4431    minvp(tg_idx).newvalue :=
4432        minvp(tg_idx).minvalue + minvp(cs_idx).diff
4433        + minvp(jv_idx).diff + minvp(sp_idx).diff
4434        + minvp(lp_idx).diff + minvp(str_idx).diff;
4435  
4436    -- calculate memory_target 'newvalue' (new derived minimum) based on
4437    -- mt_idx.minvalue and user-specified pool sizes
4438    minvp(mt_idx).newvalue :=
4439      minvp(mt_idx).minvalue + minvp(cs_idx).diff
4440      + minvp(jv_idx).diff + minvp(sp_idx).diff
4441      + minvp(lp_idx).diff + minvp(str_idx).diff + minvp(pg_idx).diff;
4442    IF (minvp(tg_idx).oldvalue != 0) THEN -- SGA_TARGET in use
4443      -- calculate 'newvalue' (new derived minimum) based on user-set sga_target
4444      -- and user-set pga_aggregate_target.  also add 12M to this calculation
4445      -- for memory_target if sga_target is also set.
4446      mtgval := minvp(tg_idx).oldvalue + minvp(pg_idx).oldvalue + 12*c_mb;
4447      -- set 'newvalue' to the larger of the two new derived minimums (see above)
4448      IF (mtgval > minvp(mt_idx).newvalue) THEN
4449        minvp(mt_idx).newvalue := mtgval;
4450      END IF;
4451    END IF;
4452  
4453    -- Note: Although sga_target and memory_target values are found here, we
4454    -- don't set DISPLAY in minvp in this procedure.  This setting is done
4455    -- in find_newval.
4456  
4457  END find_sga_mem_values;
4458  
4459  --------------------------- store_minvalue --------------------------------
4460  PROCEDURE store_minvalue (i     BINARY_INTEGER,
4461                            name  VARCHAR2,
4462                            minv  NUMBER,
4463                            minvp IN OUT MINVALUE_TABLE_T)
4464  IS
4465  BEGIN
4466     minvp(i).name := name;
4467     minvp(i).minvalue := minv;
4468     minvp(i).display := FALSE;
4469     minvp(i).diff := 0;
4470  END store_minvalue;
4471  
4472  --------------------------- store_minval_dbbit -----------------------------
4473  PROCEDURE store_minval_dbbit  (dbbit  NUMBER,
4474                                 i      IN OUT BINARY_INTEGER,
4475                                 name   VARCHAR2,
4476                                 minv   NUMBER)
4477  IS
4478  BEGIN
4479     i:= i+1;
4480     IF dbbit = 32 THEN  -- set values for 32-bit
4481       store_minvalue(i, name, minv, minvp_db32);
4482     ELSIF dbbit = 64 THEN  -- set values for 64-bit
4483       store_minvalue(i, name, minv, minvp_db64);
4484     ELSE -- if 0 (or anything but 32 and 64), then set values for both db bits
4485       store_minvalue(i, name, minv, minvp_db32);
4486       store_minvalue(i, name, minv, minvp_db64);
4487     END IF;
4488  
4489  END store_minval_dbbit;
4490  
4491  --------------------------- store_comp -----------------------------------
4492  PROCEDURE store_comp (i       BINARY_INTEGER,
4493                        schema  VARCHAR2,
4494                        version VARCHAR2,
4495                        status  NUMBER)
4496  IS
4497  BEGIN
4498     cmp_info(i).processed := TRUE;
4499     IF status = 0 THEN
4500        cmp_info(i).status := 'INVALID';
4501     ELSIF status = 1 THEN
4502        cmp_info(i).status := 'VALID';
4503     ELSIF status = 2 THEN
4504        cmp_info(i).status := 'LOADING';
4505     ELSIF status = 3 THEN
4506        cmp_info(i).status := 'LOADED';
4507     ELSIF status = 4 THEN
4508        cmp_info(i).status := 'UPGRADING';
4509     ELSIF status = 5 THEN
4510        cmp_info(i).status := 'UPGRADED';
4511     ELSIF status = 6 THEN
4512        cmp_info(i).status := 'DOWNGRADING';
4513     ELSIF status = 7 THEN
4514        cmp_info(i).status := 'DOWNGRADED';
4515     ELSIF status = 8 THEN
4516        cmp_info(i).status := 'REMOVING';
4517     ELSIF status = 9 THEN
4518        cmp_info(i).status := 'OPTION OFF';
4519     ELSIF status = 10 THEN
4520        cmp_info(i).status := 'NO SCRIPT';
4521     ELSIF status = 99 THEN
4522        cmp_info(i).status := 'REMOVED';
4523     ELSE
4524        cmp_info(i).status := NULL;
4525     END IF;
4526     cmp_info(i).version   := version;
4527     cmp_info(i).schema    := schema;
4528     EXECUTE IMMEDIATE
4529        'SELECT default_tablespace FROM sys.dba_users WHERE username =:1'
4530     INTO cmp_info(i).def_ts
4531     USING schema;
4532  EXCEPTION
4533     WHEN NO_DATA_FOUND THEN NULL;
4534  END store_comp;
4535  
4536  -------------------------- is_comp_tablespace ------------------------------------
4537  -- returns TRUE if some existing component has the tablespace as a default
4538  
4539  FUNCTION is_comp_tablespace (tsname VARCHAR2) RETURN BOOLEAN
4540  IS
4541  BEGIN
4542    FOR i IN 1..max_components LOOP
4543      IF cmp_info(i).processed AND
4544         tsname = cmp_info(i).def_ts THEN
4545        RETURN TRUE;
4546      END IF;
4547    END LOOP;
4548    RETURN FALSE;
4549  END is_comp_tablespace;
4550  
4551  -------------------------- ts_has_queues ---------------------------------
4552  -- returns TRUE if there is at least one queue in the tablespace
4553  FUNCTION ts_has_queues (tsname VARCHAR2) RETURN BOOLEAN
4554  IS
4555    t_null CHAR(1);
4556  BEGIN
4557    EXECUTE IMMEDIATE 'SELECT NULL FROM sys.dba_tables t
4558        WHERE EXISTS
4559        (SELECT 1 FROM sys.dba_queues q
4560           WHERE q.queue_table = t.table_name AND q.owner = t.owner)
4561        AND t.tablespace_name = :1 AND rownum <= 1'
4562        INTO t_null
4563        USING tsname;
4564      RETURN TRUE;
4565    EXCEPTION
4566      WHEN NO_DATA_FOUND THEN RETURN FALSE;
4567  END ts_has_queues;
4568  
4569  -------------------------- ts_is_SYS_temporary ---------------------------------
4570  -- returns TRUE if there is at least one queue in the tablespace
4571  
4572  FUNCTION ts_is_SYS_temporary (tsname VARCHAR2) RETURN BOOLEAN
4573  IS
4574    t_null CHAR(1);
4575  BEGIN
4576    EXECUTE IMMEDIATE 'SELECT NULL FROM sys.dba_users
4577          WHERE username = ''SYS'' AND temporary_tablespace = :1'
4578      INTO t_null
4579      USING tsname;
4580    RETURN TRUE;
4581  EXCEPTION
4582    WHEN NO_DATA_FOUND THEN RETURN FALSE;
4583  END ts_is_SYS_temporary;
4584  
4585  --
4586  -- Note:  There could be a verify function on
4587  -- the params passed in, but for now, we assume the
4588  -- caller is passing something DBUA knows how to handle
4589  --
4590  FUNCTION genDBUAXMLCheck (
4591       name       VARCHAR2,
4592       eseverity  NUMBER,
4593       etext      VARCHAR2,
4594       ecause     VARCHAR2,
4595       action     VARCHAR2,
4596       detailtype VARCHAR2,
4597       detailinfo VARCHAR2,
4598       fixuptype  VARCHAR2,
4599       fixupstage VARCHAR2 ) RETURN VARCHAR2
4600  IS
4601    t_severity   VARCHAR2(10);
4602  
4603  --  name
4604  --    Text name that MUST BE KNOWN BY DBUA.  They use it to key off of.
4605  --
4606  --  eseverity
4607  --    c_check_level_warning, _error, _info - tells the DBUA how to handle
4608  --    the condition.
4609  --
4610  --  etext
4611  --    Text of the error (if DBUA has a translated message, they will
4612  --      use that, otherwise, this will be displayed)
4613  --
4614  --  ecause
4615  --    Details of what causes this issue.
4616  --
4617  --  action
4618  --    Action to be taken to resolve the issue.
4619  --
4620  --                         detailtype/info
4621  --    Detail is the details for the issue being reported.  What check
4622  --    was run that caused this issue to be reported.
4623  --
4624  --  detailtype
4625  --    c_dbua_detail_type_text or _sql.  If _text, the DBUA will display
4626  --    it when displaying information about this issue.  If _sql, the
4627  --    DBUA will execute it, grab the output and display it.  Make
4628  --    sure the SQL generates approporate output.
4629  --
4630  --  detailinfo
4631  --   If _text, a description of what the issue is, if _sql, then
4632  --   its the SQL command to execute to generate output that will be
4633  --   displayed by the DBUA.
4634  --
4635  --  fixuptype
4636  --    c_dbua_fixup_type_auto _manual
4637  --    _auto =  there is a fixup function to solve the issue which
4638  --      can be executed to resolve the issue.
4639  --    _manual = There may still be a fixup function, but it must
4640  --      either confirmed, or executed manually (complex issue, or
4641  --      possible data manupulation).
4642  --
4643  --  fixupstage
4644  --    c_dbua_fixup_stage_pre, _post, _now
4645  --     _pre = Should be fixed before the upgrade is executed, usually
4646  --       right before the upgrade is started.
4647  --     _post = Should be fixed after the upgrade is executed
4648  --     _now = Can be solved right now, no need to wait until right
4649  --       before upgrade is executed.
4650  --
4651  BEGIN
4652    IF (eseverity = c_check_level_warning) THEN
4653      t_severity := c_check_level_warning_txt;
4654    ELSIF (eseverity = c_check_level_error) THEN
4655      t_severity := c_check_level_error_txt;
4656    ELSIF (eseverity = c_check_level_info) THEN
4657      t_severity := c_check_level_info_txt;
4658    ELSE
4659      t_severity := c_check_level_success_txt;
4660    END IF;
4661    return ('<PreUpgradeCheck ID="' || name ||
4662     '" Status="'  || t_severity  || '">' ||
4663     '<Message><Text>'         || etext      || '</Text>'   ||
4664              '<Cause>'        || ecause     || '</Cause>'  ||
4665              '<Action>'       || action     || '</Action>' ||
4666              '<Detail Type="' || detailtype || '">'  ||
4667                 detailinfo || '</Detail>' ||
4668     '</Message>' ||
4669     '<FixUp Type="' || fixuptype  || '" FixAtStage="' || fixupstage || '"/>' ||
4670     '</PreUpgradeCheck>');
4671  END genDBUAXMLCheck;
4672  
4673  
4674  FUNCTION htmlentities (intxt varchar2) RETURN VARCHAR2
4675    --
4676    -- Replace chars which DBUA/XML will parse into
4677    -- their HTML equivilants
4678    --
4679  IS
4680    rstr VARCHAR2(4000);
4681  BEGIN
4682    --
4683    -- Because we can't depend on the env turing DEFINE off,
4684    -- use chr(38) for the ampersand character.
4685    --
4686    rstr := replace(intxt, chr(38), chr(38) || 'amp;');
4687    rstr := replace(rstr, '<',      chr(38) || 'lt;');
4688    return replace(rstr, '>',      chr(38) || 'gt;');
4689    -- dbua testing showed that the ' and " did not need
4690    -- replacing
4691  END htmlentities;
4692  
4693  --
4694  -- Output a 'fixup' to the passed file.
4695  -- This is a call to the dbms_preup.run_fixup_and_report
4696  -- routine.  That routine will run the fixup and report
4697  -- the problem.
4698  --
4699  PROCEDURE genFixup (name VARCHAR2 )
4700  IS
4701    idx     NUMBER;
4702    rstr    VARCHAR2(400);
4703    tlevel  VARCHAR2(30);
4704    taction VARCHAR2(50);
4705    tfile   UTL_FILE.FILE_TYPE;
4706  
4707  BEGIN
4708    IF pCheckOnly THEN
4709      return;
4710    END IF;
4711  
4712    idx := check_names(name).idx;
4713  
4714    rstr := 'dbms_preup.run_fixup_and_report(''' || name || ''');';
4715  
4716    IF check_table(idx).fix_type IN (c_fix_source_manual,
4717                                     c_fix_source_auto,
4718                                     c_fix_target_manual_pre,
4719                                     c_fix_target_auto_pre) THEN
4720      tfile := pPreScriptUFT;
4721    ELSE
4722      tfile := pPostScriptUFT;
4723    END IF;
4724  
4725    If check_table(idx).fix_type IN (c_fix_source_manual,
4726                                     c_fix_target_manual_pre,
4727                                     c_fix_target_manual_post) THEN
4728      taction := pActionRequired;
4729    ELSE
4730      taction := 'Fixup routine';
4731    END IF;
4732  
4733    IF check_table(idx).level = c_check_level_info THEN
4734      tlevel := 'Informational';
4735    ELSIF check_table(idx).level = c_check_level_warning THEN
4736      tlevel := 'Warning';
4737    ELSIF check_table(idx).level = c_check_level_error THEN
4738      tlevel := 'Error';
4739    ELSIF check_table(idx).level = c_check_level_recommend THEN
4740      tlevel := 'Recommendation';
4741    END IF;
4742  
4743    DisplayLine (tfile, 'BEGIN');
4744    DisplayLine (tfile, '-- *****************  Fixup Details ***********************************');
4745    DisplayLine (tfile, '-- Name:        ' || name);
4746    DisplayLine (tfile, '-- Description: ' || check_table(idx).descript);
4747    DisplayLine (tfile, '-- Severity:    ' || tlevel);
4748    DisplayLine (tfile, '-- Action:      ' || taction);
4749    DisplayLine (tfile, '-- Fix Summary: ');
4750    DisplayLine (tfile, '--     ' || GetHelp(name, c_help_fixup));
4751    DisplayLine (tfile, '');
4752    DisplayLine (tfile, rstr);
4753    DisplayLine (tfile, 'END;');
4754    DisplayLine (tfile, '/');
4755  
4756  END genFixup;
4757  
4758  -- **********************************************************************************
4759  --   Output routines for each phase of the preupgrade checks
4760  -- **********************************************************************************
4761  PROCEDURE output_summary
4762  IS
4763    t_varchar   VARCHAR2(40);
4764  BEGIN
4765    init_package;
4766    if pOutputType = c_output_xml
4767    THEN
4768      -- TODO:  DBUA may need to know if this is a
4769      -- restart.
4770      DisplayLine ('<SupportedOracleVersions value="' || c_supported_versions || '"/>');
4771      DisplayLine ('<OracleVersion value="'           || db_version || '"/>');
4772      DisplayLine ('<Database Name="'  || db_name || '" Version=" '
4773               || db_version || '" Compatibility="'
4774               || db_compat  || '"/>');
4775      IF pDBGFailAll THEN
4776        DisplayDiagLine (' ***** DEBUG MODE *****');
4777      END IF;
4778    ELSE
4779      IF pDBGFailAll THEN
4780        t_varchar := ' ***** DEBUG MODE *****';
4781      ELSE
4782        t_varchar := '';
4783      END IF;
4784      DisplayLine('Oracle Database Pre-Upgrade Information Tool ' || TO_CHAR(SYSDATE, 'MM-DD-YYYY HH24:MI:SS'));
4785      DisplayLine('Script Version: ' || c_version || c_patchset ||
4786                              ' Build: ' || c_build || t_varchar);
4787      DisplayBanner;
4788      DisplayLine ('   Database Name:  ' || db_name );
4789      DisplayLine ('         Version:  ' || db_version );
4790      DisplayLine ('      Compatible:  ' || db_compat );
4791      DisplayLine ('       Blocksize:  ' || db_block_size );
4792      DisplayLine ('        Platform:  ' || db_platform );
4793      DisplayLine ('   Timezone file:  V' || db_tz_version );
4794      IF db_readonly THEN
4795        DisplayLine ('        ReadOnly:   TRUE');
4796      END IF;
4797      IF db_is_XE THEN
4798        DisplayLine ('         Edition:  ' || 'XE' );
4799      END IF;
4800    END IF;
4801  END output_summary;
4802  
4803  PROCEDURE output_xml_initparams (minvp MINVALUE_TABLE_T)
4804  IS
4805    i       NUMBER;
4806  BEGIN
4807    DisplayLine ('<Update>');
4808    FOR i IN 1..max_minvp LOOP
4809      IF minvp(i).display THEN
4810        IF NOT (i = jv_idx and NOT cmp_info(javavm).processed) THEN
4811          IF NOT (i = mt_idx and minvp(i).oldvalue IS NULL) THEN
4812             DisplayLine('<Parameter name="' ||
4813                minvp(i).name ||
4814              '" atleast="' || TO_CHAR(ROUND(minvp(i).newvalue)) ||
4815              '" atleast_32="' || TO_CHAR(ROUND(minvp_db32(i).newvalue)) ||
4816              '" atleast_64="' || TO_CHAR(ROUND(minvp_db64(i).newvalue)) ||
4817              '" type="NUMBER"/>');
4818          END IF;
4819        END IF;
4820      END IF;
4821    END LOOP;
4822  
4823    IF db_compat_majorver < c_compat_min_num THEN
4824      --
4825      -- Display the minimum compatibility (manual mode has
4826      -- actual check)
4827      --
4828      DisplayLine (
4829        '<Parameter name="compatible" atleast="' || c_compat_min || '" type="VERSION"/>');
4830    END IF;
4831  
4832    --
4833    -- Check the special list for any values that
4834    -- need to be updated and dumped out inside the <update> tags for the DBUA
4835    --
4836    FOR i IN 1..max_sp LOOP
4837      IF sp(i).dbua_OutInUpdate THEN
4838        IF sp(i).db_match = TRUE AND
4839          sp(i).newvalue IS NOT NULL THEN
4840          -- <parameter name="Audit_Trail" newValue="NONE"/>
4841          DisplayLine('<Parameter name="' || sp(i).oldname ||
4842              '" newValue="' || sp(i).newvalue || '" type="STRING"/>');
4843        ELSIF pDBGAllResources THEN
4844          DisplayLine('<Parameter name="' || sp(i).oldname ||
4845              '" newValue="' || sp(i).newvalue || '" type="STRING"/>');
4846        END IF;
4847      END IF;
4848    END LOOP;
4849    DisplayLine ('</Update>');
4850  END output_xml_initparams;
4851  
4852  PROCEDURE output_initparams
4853  IS
4854    changes_req BOOLEAN;
4855    def_or_obs  VARCHAR2(15);
4856    result_txt  VARCHAR2(200);
4857    tmp_str     VARCHAR2(80);
4858  BEGIN
4859    init_package;
4860  
4861    IF db_invalid_state = TRUE THEN
4862      IF pOutputType = c_output_xml THEN
4863        --
4864        -- Although the DBUA will ensure the db is
4865        -- opended correctly, leave this error output
4866        --
4867        result_txt:= genDBUAXMLCheck('DATABASE_NOT_OPEN',
4868          c_check_level_error,
4869          'Database must be in "OPEN" state.',
4870          'Database is not in OPEN state',
4871          'SELECT status from V$INSTANCE',
4872           c_dbua_detail_type_text,
4873          'Close the database and reopen it using OPEN as the state',
4874          c_dbua_fixup_type_manual,
4875          c_dbua_fixup_stage_pre );
4876      ELSE
4877        DisplayLine ('Database not in OPEN state.');
4878        DisplayLine ('   Database must be in OPEN state for script to execute correctly.');
4879      END IF;
4880      return;
4881    END IF;
4882  
4883    IF (pOutputType = c_output_xml)
4884    THEN
4885      DisplayLine ('<InitParams>');
4886  
4887      IF db_64bit THEN
4888        output_xml_initparams(minvp_db64);
4889      ELSE
4890        output_xml_initparams(minvp_db32);
4891      END IF;
4892  
4893      -- Migration tag was here
4894  
4895      DisplayLine ('<NonHandled>');
4896      --  DisplayLine ('<Parameter name="remote_listener"/>');
4897      DisplayLine ('</NonHandled>');
4898  
4899      DisplayLine ('<Rename>');
4900      FOR i IN 1..max_rp LOOP
4901        IF rp(i).db_match = TRUE THEN
4902          DisplayLine(
4903          '<Parameter name="' || rp(i).oldname ||
4904                    '" newName="' || rp(i).newname || '"/>');
4905        ELSIF pDBGAllResources THEN
4906          DisplayLine(
4907          '<Parameter name="' || rp(i).oldname ||
4908                    '" newName="' || rp(i).newname || '"/>');
4909        END IF;
4910      END LOOP;
4911  
4912      -- Display parameters that have a new name and a new value
4913      FOR i IN 1..max_sp LOOP
4914        IF sp(i).db_match = TRUE AND
4915          sp(i).newvalue IS NOT NULL AND
4916          sp(i).dbua_OutInUpdate = FALSE THEN
4917          DisplayLine('<Parameter name="' || sp(i).oldname ||
4918              '" newName="' || sp(i).newname ||
4919              '" newValue="' || sp(i).newvalue || '"/>');
4920        ELSIF pDBGAllResources THEN
4921          IF sp(i).dbua_OutInUpdate = FALSE THEN
4922            DisplayLine('<Parameter name="' || sp(i).oldname ||
4923                '" newName="' || sp(i).newname ||
4924                '" newValue="' || sp(i).newvalue || '"/>');
4925          END IF;
4926        END IF;
4927      END LOOP;
4928      DisplayLine ('</Rename>');
4929  
4930      DisplayLine('<Remove>');
4931      FOR i IN 1..max_op LOOP
4932        IF op(i).db_match = TRUE THEN
4933           DisplayLine('<Parameter name="' ||
4934             op(i).name || '"/>');
4935        ELSIF pDBGAllResources THEN
4936           DisplayLine('<Parameter name="' ||
4937             op(i).name || '"/>');
4938        END IF;
4939      END LOOP;
4940      DisplayLine('</Remove>');
4941      DisplayLine ('</InitParams>');
4942    ELSE
4943      --
4944      -- Text output
4945      --
4946      --
4947      -- compat check is done as an actual check
4948      -- since it can stop the DB from starting up
4949      --
4950      DisplayBanner;
4951      DisplayCenter('[Renamed Parameters]');
4952      changes_req := FALSE;
4953  
4954      FOR i IN 1..max_rp LOOP
4955        IF rp(i).db_match = TRUE THEN
4956          changes_req := TRUE;
4957          DisplayWarning('"' || rp(i).oldname ||
4958              '" new name is "' || rp(i).newname || '"');
4959        ELSIF pDBGAllResources THEN
4960          DisplayWarning('"' || rp(i).oldname ||
4961              '" new name is "' || rp(i).newname || '"');
4962        END IF;
4963      END LOOP;
4964  
4965      -- Display parameters that have a new name and a new value
4966  
4967      FOR i IN 1..max_sp LOOP
4968        IF sp(i).db_match = TRUE AND
4969            sp(i).newvalue IS NOT NULL
4970        THEN
4971          changes_req := TRUE;
4972          IF sp(i).oldvalue IS NULL
4973          THEN
4974            DisplayWarning('"' || sp(i).oldname ||
4975                '" new name is "' || sp(i).newname ||
4976                '" new value is "' || sp(i).newvalue || '"');
4977          ELSE
4978            DisplayLine('"' || sp(i).oldname ||
4979               '" old value was "' || sp(i).oldvalue || '";');
4980            DisplayLine('         --> new name is "' ||
4981                sp(i).newname || '", new value is "' || sp(i).newvalue || '"');
4982          END IF;
4983        ELSIF pDBGAllResources THEN
4984          IF sp(i).newvalue IS NULL THEN
4985            tmp_str := 'NULL';
4986          ELSE
4987            tmp_str := sp(i).newvalue;
4988          END IF;
4989          IF sp(i).oldvalue IS NULL  THEN
4990            DisplayWarning('"' || sp(i).oldname ||
4991                '" new name is "' || sp(i).newname ||
4992                '" new value is "' || tmp_str || '"');
4993          ELSE
4994            DisplayLine('"' || sp(i).oldname ||
4995               '" old value was "' || sp(i).oldvalue || '";');
4996            DisplayLine('         --> new name is "' ||
4997                sp(i).newname || '", new value is "' || tmp_str || '"');
4998          END IF;
4999        END IF;
5000      END LOOP;
5001  
5002      IF changes_req THEN
5003        DisplayLine('');
5004        DisplayCenter ('[Changes required in Oracle Database init.ora or spfile]');
5005        DisplayLine('');
5006      ELSE
5007        DisplayCenter('[No Renamed Parameters in use]');
5008      END IF;
5009      DisplayBanner;
5010  
5011      changes_req := FALSE;
5012      DisplayBanner;
5013      DisplayCenter ('[Obsolete/Deprecated Parameters]');
5014  
5015      FOR i IN 1..max_op LOOP
5016        IF op(i).deprecated = TRUE
5017        THEN
5018          def_or_obs := 'DESUPPORTED';
5019        ELSE
5020          def_or_obs := 'OBSOLETE';
5021        END IF;
5022  
5023        IF op(i).db_match = TRUE THEN
5024          changes_req := TRUE;
5025  
5026          IF op(i).name NOT IN ('background_dump_dest','user_dump_dest')
5027          THEN
5028            DisplayLine(
5029              '--> ' || rpad(op(i).name, 28) || ' ' ||
5030                       rpad(op(i).version, 10) || ' ' ||
5031                       rpad(def_or_obs, 12));
5032          ELSE
5033            -- bdump, udump deprecated by diagnostic_dest
5034            -- If core_dump_dest gets back onto this list, it goes here (and above)
5035            DisplayLine (
5036              '--> ' || rpad(op(i).name, 28) || ' ' ||
5037                       rpad(op(i).version, 10) || ' ' ||
5038                       rpad(def_or_obs, 12) ||
5039                       ' replaced by  "diagnostic_dest"');
5040          END IF;
5041        ELSIF pDBGAllResources THEN
5042          DisplayLine(
5043              '--> ' || rpad(op(i).name, 28) || ' ' ||
5044                       rpad(op(i).version, 10) || ' ' ||
5045                       rpad(def_or_obs, 12));
5046        END IF;
5047      END LOOP;
5048  
5049      IF changes_req THEN
5050        DisplayLine('');
5051        DisplayCenter('[Changes required in Oracle Database init.ora or spfile]');
5052        DisplayLine('');
5053      ELSE
5054        DisplayCenter ('[No Obsolete or Desupported Parameters in use]');
5055      END IF;
5056    END IF;  -- check for terminal output
5057  END output_initparams;
5058  
5059  PROCEDURE output_components
5060  IS
5061    post_list_info VARCHAR2(300) := '';
5062    tmp_varchar    VARCHAR2(30);
5063    ui             VARCHAR2(10);
5064  
5065  BEGIN
5066    init_package;
5067  
5068    IF db_invalid_state = TRUE THEN
5069      return;
5070    END IF;
5071  
5072    IF  pOutputType = c_output_xml
5073    THEN
5074      IF (cmp_info(catalog).status = 'VALID' AND cmp_info(catproc).status = 'VALID') THEN
5075        tmp_varchar := cmp_info(catalog).status;
5076      ELSE
5077        tmp_varchar := 'INVALID';
5078      END IF;
5079      DisplayLine ('<Components>');
5080        --
5081        -- For Server status, use Catalog status (catalog and catproc are
5082        -- skipped in the below loop)
5083        --
5084        DisplayLine ('<Component id ="Oracle Server" type="SERVER" cid="RDBMS" version="'
5085                  || db_version || '" status="' || tmp_varchar || '"/>');
5086        --
5087        -- Note:
5088        --      1,2 are catalog and catproc which are skipped
5089        --
5090        FOR i IN 3 .. max_components LOOP
5091          IF cmp_info(i).processed and NOT (cmp_info(i).cid = 'WK') THEN
5092            IF (cmp_info(i).status = NULL) THEN
5093              -- If we get a NULL value, don't dump out the status
5094              tmp_varchar := '';
5095            ELSE
5096              -- Create the status= entry
5097              tmp_varchar := ' status="' || cmp_info(i).status || '"';
5098            END IF;
5099            DisplayLine ('<Component id="'   || cmp_info(i).cname   ||
5100                              '" cid="'     || cmp_info(i).cid     ||
5101                              '" script="'  || cmp_info(i).script  ||
5102                              '" version="' || cmp_info(i).version ||
5103                              '"' || tmp_varchar || '/>');
5104          END IF;
5105        END LOOP;
5106     DisplayLine('</Components>');
5107    ELSE
5108      DisplayBanner;
5109      DisplayCenter ('[Component List]');
5110      DisplayBanner;
5111  
5112      FOR i IN 1..max_components LOOP
5113        IF cmp_info(i).processed THEN
5114          IF cmp_info(i).install THEN ui := '[install]';
5115          ELSE                        ui := '[upgrade]';
5116          END IF;
5117          DisplayLine(
5118             '--> ' || rpad(cmp_info(i).cname, 38) || ' ' ||
5119                       rpad(ui, 10) || ' ' ||
5120                       rpad(cmp_info(i).status, 10));
5121          IF ((cmp_info(i).cid  = 'OLS') AND
5122                  NOT cmp_info(dv).processed) THEN
5123            post_list_info := post_list_info  || crlf
5124                || 'To successfully upgrade Oracle Label Security, choose ' || crlf
5125                || '''Select Options'' in Oracle installer and then select ' || crlf
5126                || 'Oracle Label Security.';
5127          END IF;
5128        END IF;
5129      END LOOP;
5130      IF (length(post_list_info) != 0) THEN
5131        DisplayLine (post_list_info);
5132      END IF;
5133    END IF;
5134  END output_components;
5135  
5136  PROCEDURE output_resources
5137  --
5138  -- This calls all the resource routines
5139  --
5140  IS
5141  BEGIN
5142    init_package;
5143  
5144    --
5145    -- Make sure resources are set before so
5146    -- everything is re-calculated.
5147    --
5148    init_resources;
5149  
5150    IF db_invalid_state = TRUE THEN
5151      RETURN;
5152    END IF;
5153    output_tablespaces;
5154    output_rollback_segs;
5155    output_flashback;
5156  END output_resources;
5157  
5158  PROCEDURE output_tablespaces
5159  IS
5160    resourcenum    NUMBER (38);
5161    changes_req BOOLEAN := FALSE;
5162  BEGIN
5163    IF pOutputType = c_output_xml
5164    THEN
5165      DisplayLine('<SystemResource>');
5166  
5167      FOR i IN 1..max_ts LOOP
5168        DisplayLine (
5169           '<Tablespace name="' || ts_info(i).name ||
5170           '" additional_size="' ||
5171               TO_CHAR(ROUND(ts_info(i).addl)) || '"/>');
5172  
5173        IF pDBGSizeResources THEN
5174          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5175                            ' used =                    ' || LPAD(ts_info(i).inuse,10));
5176          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5177                           ' delta=                    ' || LPAD(ts_info(i).delta,10));
5178          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5179                           ' total req=                ' || LPAD(ts_info(i).min,10));
5180          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5181                            ' alloc=                    ' || LPAD(ts_info(i).alloc,10));
5182          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5183                            ' auto_avail=               ' || LPAD(ts_info(i).auto,10));
5184          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5185                            ' total avail=              ' ||  LPAD(ts_info(i).avail,10));
5186          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5187                            ' additional space needed = ' || LPAD(ts_info(i).addl,10));
5188          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5189                            ' increment by =            ' || LPAD(ts_info(i).inc_by,10));
5190          DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5191                            ' total avail=              ' ||  LPAD(ts_info(i).avail,10));
5192        END IF;
5193      END LOOP;
5194      --
5195      -- ArchiveLogs and Flashback info
5196      --
5197      IF db_log_mode = 'ARCHIVELOG' OR pDBGSizeResources THEN
5198        resourcenum := pMinArchiveLogGen;
5199      ELSE
5200        resourcenum := 0;
5201      END IF;
5202      DisplayLine (
5203        '<ArchiveLogs name="ArchiveLogs" additional_size="' ||
5204           resourcenum || '" />');
5205  
5206      IF db_flashback_on OR pDBGSizeResources THEN
5207        resourcenum := pMinFlashbackLogGen;
5208      ELSE
5209        resourcenum := 0;
5210      END IF;
5211      DisplayLine (
5212        '<FlashbackLogs name="FlasbackLogs" additional_size="' ||
5213          resourcenum || '" />');
5214  
5215      DisplayLine('</SystemResource>');
5216    ELSE
5217      DisplayBanner;
5218      IF pUnsupportedUpgrade THEN
5219        DisplayCenter('[ Unsupported Upgrade: Tablespace Data Supressed ]');
5220      ELSE
5221        DisplayCenter('[Tablespaces]');
5222      END IF;
5223      DisplayBanner;
5224  
5225      IF max_ts > 0 and pUnsupportedUpgrade = FALSE THEN
5226        FOR i IN 1..max_ts LOOP
5227          --
5228          -- For debugging, dump out the allocated and used info
5229          --
5230          IF pDBGSizeResources THEN
5231            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5232                            ' used =                    ' || LPAD(ts_info(i).inuse,10));
5233            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5234                            ' delta=                    ' || LPAD(ts_info(i).delta,10));
5235            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5236                           ' total req=                ' || LPAD(ts_info(i).min,10));
5237            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5238                            ' alloc=                    ' || LPAD(ts_info(i).alloc,10));
5239            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5240                            ' auto_avail=               ' || LPAD(ts_info(i).auto,10));
5241            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5242                            ' total avail=              ' ||  LPAD(ts_info(i).avail,10));
5243            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5244                            ' additional space needed = ' || LPAD(ts_info(i).addl,10));
5245            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5246                            ' increment by =            ' || LPAD(ts_info(i).inc_by,10));
5247            DisplayDiagLine(RPAD(ts_info(i).name,10) ||
5248                            ' total avail=              ' ||  LPAD(ts_info(i).avail,10));
5249          END IF;
5250  
5251          IF ts_info(i).inc_by = 0 THEN
5252            DisplayLine(
5253              '--> ' || ts_info(i).name ||
5254                   ' tablespace is adequate for the upgrade.');
5255            DisplayLine(
5256              '     minimum required size: ' ||
5257              TO_CHAR(ROUND(ts_info(i).min)) || ' MB');
5258          ELSE
5259            --
5260            -- need more space in tablespace
5261            --
5262            changes_req := TRUE;
5263            DisplayError(ts_info(i).name ||
5264                        ' tablespace is not large enough for the upgrade.');
5265            DisplayLine(
5266               '     currently allocated size: ' ||
5267                TO_CHAR(ROUND(ts_info(i).alloc)) || ' MB');
5268            DisplayLine(
5269               '     minimum required size: ' ||
5270                TO_CHAR(ROUND(ts_info(i).min)) || ' MB');
5271            DisplayLine(
5272               '     increase current size by: ' ||
5273                TO_CHAR(ROUND(ts_info(i).inc_by)) || ' MB');
5274  
5275            IF ts_info(i).fauto THEN
5276               DisplayLine(
5277                 '     tablespace is AUTOEXTEND ENABLED.');
5278            ELSE
5279               DisplayLine(
5280                '     tablespace is NOT AUTOEXTEND ENABLED.');
5281            END IF;
5282          END IF;
5283        END LOOP;
5284      END IF;
5285  
5286      IF pUnsupportedUpgrade = FALSE THEN
5287          DisplayLine('');
5288        IF changes_req THEN
5289          DisplayCenter('[make adjustments in the current environment]');
5290        ELSE
5291          DisplayCenter('[No adjustments recommended]');
5292        END IF;
5293        DisplayLine('');
5294        DisplayBanner;
5295      END IF;
5296    END IF;   -- output type text
5297  END output_tablespaces;
5298  
5299  PROCEDURE output_rollback_segs
5300  IS
5301    auto VARCHAR2(3);
5302  BEGIN
5303    IF pOutputType = c_output_xml THEN
5304      RETURN;
5305    END IF;
5306  
5307    IF max_rs > 0 THEN
5308      DisplayBanner;
5309      DisplayLine('Rollback Segments: [make adjustments ' ||
5310                        'immediately prior to upgrading]');
5311      DisplayBanner;
5312      -- Loop through the rs_info table
5313      FOR i IN 1..max_rs LOOP
5314        IF rs_info(i).auto > 0 THEN
5315          auto:='ON';
5316        ELSE
5317          auto:='OFF';
5318        END IF;
5319        DisplayLine(
5320              '--> ' || rs_info(i).seg_name || ' in tablespace ' ||
5321                        rs_info(i).tbs_name || ' is ' ||
5322                        rs_info(i).status ||
5323                        '; AUTOEXTEND is ' || auto);
5324        DisplayLine(
5325              '     currently allocated: ' || rs_info(i).inuse
5326                    || 'K');
5327        DisplayLine(
5328              '     next extent size: ' || rs_info(i).next
5329                    || 'K; max extents: ' || rs_info(i).max_ext);
5330      END LOOP;
5331      DisplayWarning('For the upgrade, use a large (minimum 70M) ' ||
5332                           'public rollback segment');
5333      IF max_rs > 1 THEN
5334        DisplayWarning('Take smaller public rollback segments OFFLINE');
5335      END IF;
5336      DisplayLine ('');
5337    END IF;
5338  END output_rollback_segs;
5339  
5340  PROCEDURE output_flashback
5341  IS
5342  BEGIN
5343  
5344    IF pDBGSizeResources THEN
5345      FOR i in 1..max_comps LOOP
5346        IF cmp_info(i).processed THEN
5347          DisplayDiagLine ('Archivelog:   ' || rpad(cmp_info(i).cid,10) || ' ' ||
5348                           lpad(cmp_info(i).archivelog_kbytes,10));
5349          DisplayDiagLine ('Flashbacklog: ' || rpad(cmp_info(i).cid,10) || ' ' ||
5350                  lpad(cmp_info(i).flashbacklog_kbytes,10));
5351        END IF;
5352      END LOOP;
5353    END IF;
5354  
5355    IF pOutputType = c_output_xml THEN
5356      RETURN;
5357    END IF;
5358  
5359    IF flashback_info.active OR pDBGAllResources THEN
5360      DisplayBanner;
5361      IF pUnsupportedUpgrade THEN
5362        DisplayCenter('[ Unsupported Upgrade: Flashback Data Supressed ]');
5363      ELSE
5364        DisplayCenter('[Flashback Information]');
5365      END IF;
5366      DisplayBanner;
5367      DisplayLine ('--> name:          ' || flashback_info.name );
5368      DisplayLine ('--> limit:         ' || TO_CHAR( (flashback_info.limit / c_mb))          || ' MB');
5369      DisplayLine ('--> used:          ' || TO_CHAR( round((flashback_info.used / c_mb ),0))  || ' MB');
5370      DisplayLine ('--> size:          ' || TO_CHAR( (flashback_info.dsize / c_mb ))       || ' MB');
5371      DisplayLine ('--> reclaim:       ' || TO_CHAR( (flashback_info.reclaimable / c_mb)) || ' MB');
5372      DisplayLine ('--> files:         ' || TO_CHAR(flashback_info.files));
5373      DisplayLine ('');
5374      pCheckWarningCount := pCheckWarningCount + 1;
5375      DisplayWarning ('Flashback Database is enabled.');
5376      DisplayLine ('     Ensure adequate disk space exists in the flash recovery area');
5377      DisplayLine ('     before performing the upgrade.  Your recovery area');
5378      DisplayLine ('     will require at least '
5379                  || TO_CHAR(ROUND((pMinArchiveLogGen + pMinFlashbacklogGen)/c_mb))
5380                  || ' MB - or greater - of free space.');
5381      DisplayBanner;
5382    END IF;
5383  END output_flashback;
5384  
5385  PROCEDURE output_recommendations
5386  --
5387  -- Output both the pre and post recommendations
5388  --
5389  IS
5390  BEGIN
5391    init_package;
5392  
5393    IF db_invalid_state = TRUE OR pOutputType = c_output_xml THEN
5394      RETURN;
5395    END IF;
5396    DisplayLine(pPreScriptUFT, 'BEGIN');
5397    DisplayLineBoth(pPreScriptUFT, '');
5398    DisplayBanner(pPreScriptUFT);
5399    DisplayCenter(pPreScriptUFT, '[Pre-Upgrade Recommendations]');
5400    DisplayBanner(pPreScriptUFT);
5401    DisplayLineBoth(pPreScriptUFT, '');
5402    DisplayLine(pPreScriptUFT, 'END;');
5403    DisplayLine(pPreScriptUFT, '/');
5404  
5405    --
5406    -- Dump the pre recommendations
5407    --
5408    run_all_recommend (c_type_recommend_pre);
5409  
5410    DisplayLine(pPostScriptUFT, 'BEGIN');
5411    DisplayBanner(pPostScriptUFT);
5412    DisplayCenter(pPostScriptUFT, '[Post-Upgrade Recommendations]');
5413    DisplayBanner(pPostScriptUFT);
5414    DisplayLineBoth(pPostScriptUFT, '');
5415    DisplayLine(pPostScriptUFT, 'END;');
5416    DisplayLine(pPostScriptUFT, '/');
5417  
5418    --
5419    -- Dump the post recommendations
5420    --
5421    run_all_recommend (c_type_recommend_post);
5422    DisplayBanner;
5423  END output_recommendations;
5424  
5425  --
5426  -- A quick summary of the checks - this is the last thing
5427  -- seen in the log file.
5428  --
5429  -- The thought is, this may be the last thing seen so
5430  -- if there are things we REALLY need them to know, it should
5431  -- be output here.
5432  --
5433  -- This is ONLY for TEXT output.
5434  --
5435  PROCEDURE output_prolog
5436  IS
5437    toutput VARCHAR2(1000);
5438    tstr    VARCHAR2(30);
5439  BEGIN
5440    init_package;
5441  
5442    IF pOutputType = c_output_text THEN
5443      --
5444      -- Only output for non XML display
5445      --
5446      DisplayLine (CenterLine('************  Summary  ************'));
5447      DisplayLine ('');
5448  
5449      tstr := ' ERRORS';
5450      toutput := ' exist that must be addressed prior to performing your upgrade.';
5451      IF (pCheckErrorCount = 1) THEN
5452        tstr := ' ERROR';
5453      ELSIF pCheckErrorCount = 0 THEN
5454        toutput := ' exist in your database.';
5455      END IF;
5456      DisplayLine (LPAD(pCheckErrorCount,2) || tstr  || toutput);
5457  
5458      tstr := ' WARNINGS';
5459      toutput := ' that Oracle suggests are addressed to improve database performance.';
5460      IF (pCheckWarningCount = 1) THEN
5461        tstr := ' WARNING';
5462      ELSIF pCheckWarningCount = 0 THEN
5463        toutput := ' exist in your database.';
5464      END IF;
5465      DisplayLine (LPAD(pCheckWarningCount,2) || tstr  || toutput);
5466  
5467      tstr := ' INFORMATIONAL messages';
5468      toutput := ' that should be reviewed prior to your upgrade.';
5469      If pCheckInfoCount = 1 THEN
5470        tstr := ' INFORMATIONAL message';
5471      ELSIF (pCheckInfoCount = 0) THEN
5472        toutput := ' messages have been reported.';
5473      END IF;
5474      DisplayLine (LPAD(pCheckInfoCount,2) || tstr || toutput);
5475  
5476      toutput :=
5477           crlf || ' After your database is upgraded and open in normal mode you must run '
5478        || crlf || ' rdbms/admin/catuppst.sql which executes several required tasks and completes'
5479        || crlf || ' the upgrade process.'
5480        || crlf || crlf ||
5481                   ' You should follow that with the execution of rdbms/admin/utlrp.sql, and a'
5482        || crlf || ' comparison of invalid objects before and after the upgrade using'
5483        || crlf || ' rdbms/admin/utluiobj.sql'
5484        || crlf || crlf ||
5485                   ' If needed you may want to upgrade your timezone data using the process'
5486        || crlf || ' described in My Oracle Support note 977512.1'
5487        || crlf || CenterLine('***********************************');
5488      DisplayLine(toutput);
5489    END IF;
5490  END output_prolog;
5491  
5492  PROCEDURE output_preup_checks
5493  IS
5494  BEGIN
5495    IF db_invalid_state = TRUE THEN
5496      return;
5497    END IF;
5498  
5499    IF pOutputType = c_output_xml THEN
5500      DisplayLine ('<PreUpgradeChecks>');
5501    ELSE
5502      DisplayBanner;
5503      DisplayCenter('[Pre-Upgrade Checks]');
5504      DisplayBanner;
5505    END IF;
5506  
5507    FOR i IN 1..pCheckCount LOOP
5508      --
5509      -- Dump out the results of the Normal checks only
5510      -- if they failed (and if there is something to display)
5511      --
5512      IF (check_table(i).passed = FALSE AND
5513          ( check_table(i).type = c_type_check OR
5514            check_table(i).type = c_type_check_interactive_only)) THEN
5515        DisplayLine (check_table(i).result_text);
5516        DisplayLine ('');
5517      END IF;
5518    END LOOP;
5519  
5520    IF pOutputType = c_output_xml THEN
5521      DisplayLine ('</PreUpgradeChecks>');
5522      IF pOutputtingScripts THEN
5523        DisplayLinePL (CenterLine('[Pre and Post Upgrade Fixup Script Have been Generated]'));
5524        DisplayLinePL (CenterLine('[Location: ' || get_output_path || ' ]'));
5525      END IF;
5526    END IF;
5527  END output_preup_checks;
5528  
5529  --
5530  -- Dump out a summary of the checks that were run
5531  -- and also if there are any errors that require user
5532  -- action.
5533  --
5534  -- This output to TO THE TEMRINAL no matter what.
5535  --
5536  PROCEDURE output_check_summary
5537  IS
5538    path     VARCHAR2(500);
5539    tsuccess NUMBER  := 0;
5540    tfailed  NUMBER  := 0;
5541    terrors  NUMBER  := 0;
5542    ttotal   NUMBER  := 0;
5543  
5544  BEGIN
5545    IF db_invalid_state = TRUE THEN
5546      RETURN;
5547    END IF;
5548  
5549    init_package;
5550    IF pOutputType = c_output_text THEN
5551      FOR i IN 1..pCheckCount LOOP
5552        IF (check_table(i).executed) THEN
5553          IF check_table(i).passed THEN
5554            tsuccess := tsuccess +1;
5555          ELSE
5556            tfailed := tfailed +1;
5557          END IF;
5558          IF check_table(i).level = c_check_level_error THEN
5559            terrors := terrors + 1;
5560          END IF;
5561        END IF;
5562      END LOOP;
5563  
5564      path := get_output_path;
5565  
5566      DisplayLinePL(CenterLine('************************************************************'));
5567      DisplayLinePL('');
5568      DisplayLinePL('Results of the checks are located at:');
5569      DisplayLinePL(' ' || path || 'preupgrade.log');
5570      DisplayLinePL('');
5571  
5572      If pOutputtingScripts THEN
5573        DisplayLinePL('Pre-Upgrade Fixup Script (run in source database environment):');
5574        DisplayLinePL(' ' || path || 'preupgrade_fixups.sql');
5575        DisplayLinePL('');
5576  
5577        DisplayLinePL('Post-Upgrade Fixup Script (run shortly after upgrade):');
5578        DisplayLinePL(' ' || path || 'postupgrade_fixups.sql');
5579        DisplayLinePL('');
5580        DisplayLinePL(CenterLine('************************************************************'));
5581        DisplayLinePL('');
5582        DisplayLinePL(CenterLine('Fixup scripts must be reviewed prior to being executed.'));
5583        DisplayLinePL('');
5584        DisplayLinePL(CenterLine('************************************************************'));
5585      END IF;
5586  
5587      IF terrors != 0 THEN
5588        DisplayLinePL('');
5589        DisplayLinePL(CenterLine('************************************************************'));
5590        DisplayLinePL(CenterLine('====>> USER ACTION REQUIRED  <<===='));
5591        DisplayLinePL(CenterLine('************************************************************'));
5592        DisplayLinePL('');
5593        --
5594        -- Centerline cuts off long lines so if you are changing this line,
5595        -- be careful of its lenght.
5596        --
5597        DisplayLinePL(CenterLine('The following are *** ERROR LEVEL CONDITIONS *** that must be addressed'));
5598        DisplayLinePl(CenterLine('prior to attempting your upgrade.'));
5599        DisplayLinePL(CenterLine('Failure to do so will result in a failed upgrade.'));
5600        DisplayLinePL('');
5601  
5602        FOR i IN 1..pCheckCount LOOP
5603          IF (check_table(i).executed         AND
5604              check_table(i).passed  = FALSE  AND
5605              check_table(i).level = c_check_level_error) THEN
5606            ttotal := ttotal + 1;
5607            DisplayLinePL('');
5608            DisplayLinePL(LPAD(ttotal,2) || ') Check Tag:    ' || check_table(i).name);
5609            DisplayLinePL('    Check Summary: ' || check_table(i).descript);
5610            DisplayLinePL('    Fixup Summary: ');
5611            DisplayLinePL('     "' || getHelp(check_table(i).name,c_help_fixup) || '"');
5612            --
5613            -- Then let them know when the manual action is required.
5614            --
5615            IF (check_table(i).fix_type = c_fix_source_manual) THEN
5616              DisplayLinePL('    +++ Source Database Manual Action Required +++');
5617            ELSIF (check_table(i).fix_type = c_fix_target_manual_pre) THEN
5618              DisplayLinePL('   +++ Post Upgraded Database Manual Action Required +++');
5619            END IF;
5620            DisplayLinePL ('');
5621          END IF;
5622        END LOOP;
5623  
5624        IF ttotal = 1 THEN
5625          DisplayLinePL(CenterLine('You MUST resolve the above error prior to upgrade'));
5626        ELSE
5627          DisplayLinePL(CenterLine('You MUST resolve the above errors prior to upgrade'));
5628        END IF;
5629        DisplayLinePL('');
5630        DisplayLinePL(CenterLine('************************************************************'));
5631        DisplayLinePL('');
5632      END IF;
5633    END IF;  -- output type
5634  END output_check_summary;
5635  
5636  --
5637  -- This is called from the pre and post fixup routines to clear out
5638  -- the 'fixup_run' flag (in case the fixups are run multiple times).
5639  --
5640  -- If preup is TRUE, this is the summary for the
5641  -- preupgrade script.
5642  --
5643  PROCEDURE clear_run_flag (preup BOOLEAN)
5644  IS
5645  BEGIN
5646    init_package;
5647    FOR i IN 1..pCheckCount LOOP
5648      check_table(i).fixup_executed := FALSE;
5649    END LOOP;
5650  END clear_run_flag;
5651  
5652  --
5653  -- Walk through all the checks and provide a summary of how
5654  -- the fixup routines did.
5655  --
5656  -- This is intended to be run AFTER the fixup (pre or post)
5657  -- scripts have been executed (and is called from those
5658  -- scripts).
5659  --
5660  -- If preup is TRUE, this is the summary for the
5661  -- preupgrade script.
5662  --
5663  PROCEDURE fixup_summary (preup BOOLEAN)
5664  IS
5665    tinfo    NUMBER  := 0;
5666    tsuccess NUMBER  := 0;
5667    tfailed  NUMBER  := 0;
5668    terrors   NUMBER := 0;
5669    ttotal   NUMBER  := 0;
5670    tinfoerrors NUMBER := 0;
5671  
5672  BEGIN
5673    IF p_package_inited = FALSE THEN
5674      EXECUTE IMMEDIATE 'BEGIN
5675        RAISE_APPLICATION_ERROR (-20000,
5676              ''Pre-Upgrade Package Fixup Summary called prior to fixups being executed''); END;';
5677        RETURN;
5678    END IF;
5679  
5680    FOR i IN 1..pCheckCount LOOP
5681      --
5682      IF (check_table(i).fixup_executed) THEN
5683        ttotal := ttotal+ 1;
5684        IF check_table(i).fixup_status = c_fixup_status_success THEN
5685          tsuccess := tsuccess +1;
5686        ELSIF check_table(i).fixup_status = c_fixup_status_info THEN
5687          IF check_table(i).level = c_check_level_error  THEN
5688            --
5689            -- Fixup returned some info, but its an error level
5690            --
5691            tinfoerrors := tinfoerrors+1;
5692          ELSE
5693            tinfo := tinfo + 1;
5694          END IF;
5695        ELSIF check_table(i).fixup_status = c_fixup_status_failure THEN
5696          tfailed := tfailed + 1;
5697        END IF;
5698        IF (check_table(i).level = c_check_level_error AND
5699            check_table(i).fixup_status != c_fixup_status_success) THEN
5700          --
5701          -- This is an error level (must be fixed), that did not
5702          -- succeed,
5703          -- at the end of this routine, dump out a list of
5704          -- these so they know they need to resolve these prior to upgrade
5705          --
5706          terrors := terrors+1;
5707        END IF;
5708      END IF;
5709    END LOOP;
5710    --
5711    -- Output counts.
5712    --
5713    DisplayLinePL('');
5714    DisplayLinePL(CenterLine('**************************************************'));
5715    DisplayLinePL(CenterLine('************* Fixup Summary ************'));
5716    DisplayLinePL('');
5717    IF ttotal = 0 THEN
5718      DisplayLinePL('No fixup routines were executed.');
5719      DisplayLinePL('');
5720      DisplayLinePL(CenterLine('**************************************************'));
5721      RETURN;
5722    END IF;
5723  
5724    IF tsuccess = 1 THEN
5725  
5726      DisplayLinePL(' 1 fixup routine was successful.');
5727  
5728    ELSIF tsuccess = 0 THEN
5729      --
5730      -- If all we had was 'info' routines, then displaying
5731      -- that none were successful doesn't sound correct
5732      -- so take that into account here by seeing if infocount
5733      -- is the same as total.
5734      --
5735      IF ttotal = tinfo THEN
5736  
5737        IF tinfo = 1 THEN
5738          DisplayLinePL(' 1 fixup routine generated an INFORMATIONAL message that should be reviewed.');
5739        ELSE
5740          -- we know its not zero.
5741          DisplayLinePL(LPAD(tinfo,2) || ' fixup routines generated INFORMATIONAL messages that should be reviewed.');
5742        END IF;
5743      END IF;
5744  
5745    ELSE
5746      DisplayLinePL(LPAD(tsuccess,2) || ' fixup routines were successful.');
5747    END IF;
5748  
5749    IF tinfo != ttotal THEN
5750      --
5751      -- If they are equal, the message is taken care of
5752      -- in the tsuccess block above (all that ran returned info messages.
5753      --
5754      IF tinfo = 1 THEN
5755        DisplayLinePL(' 1 fixup routine returned INFORMATIONAL text that should be reviewed.');
5756      ELSE
5757        DisplayLinePL(LPAD(tinfo,2) || ' fixup routines returned INFORMATIONAL text that should be reviewed.');
5758      END IF;
5759    END IF;
5760  
5761    IF tinfoerrors != 0 THEN
5762      IF tinfoerrors = 1 THEN
5763        DisplayLinePL(' 1 ERROR LEVEL check returned INFORMATION that must be acted on prior to upgrade.');
5764      ELSE
5765        DisplayLinePL(LPAD(tinfoerrors,2) || ' ERROR LEVEL checks returned INFORMATION that must be acted on prior to upgrade.');
5766      END IF;
5767    END IF;
5768  
5769    IF tfailed = 1 THEN
5770      DisplayLinePL(' 1 fixup routine failed to execute. The output must be reviewed.');
5771    ELSIF tfailed != 0 THEN
5772      DisplayLinePL(LPAD(tfailed,2) || ' fixup routines failed to execute. The output must be reviewed.');
5773    END IF;
5774  
5775    --
5776    -- If there is an error level check that was run and did not succeed,
5777    -- make sure we report that they MUST RESOLVE this.
5778    --
5779    IF terrors != 0 THEN
5780      DisplayLinePL('');
5781      DisplayLinePL(CenterLine('************************************************************'));
5782      DisplayLinePL(CenterLine('====>> USER ACTION REQUIRED  <<===='));
5783      DisplayLinePL(CenterLine('************************************************************'));
5784  
5785      ttotal := 0;  -- reuse this variable.
5786      FOR i IN 1..pCheckCount LOOP
5787        --
5788        IF (check_table(i).level = c_check_level_error AND
5789            check_table(i).fixup_status != c_fixup_status_success) THEN
5790          --
5791          -- Report this as a MUST FIX
5792          --
5793          ttotal := ttotal + 1;
5794          DisplayLinePL('');
5795          DisplayLinePL(LPAD(ttotal,2) || ') Check Tag:    ' || check_table(i).name || ' failed.');
5796          DisplayLinePL('    Check Summary: ' || check_table(i).descript);
5797          DisplayLinePL('    Fixup Summary: ');
5798          DisplayLinePL('     "' || getHelp(check_table(i).name,c_help_fixup) || '"');
5799          IF check_table(i).fix_type IN (c_fix_source_manual,
5800                                         c_fix_target_manual_pre,
5801                                         c_fix_target_manual_post) THEN
5802            --
5803            -- If this is a manual situation, let them know they have
5804            -- something to do (may be redundant given the block we are in but...)
5805            --
5806            DisplayLinePL('    ' || pActionRequired);
5807          END IF;
5808        END IF;
5809      END LOOP;
5810  
5811      DisplayLinePL('');
5812      DisplayLinePL(CenterLine('**************************************************'));
5813      IF ttotal = 1 THEN
5814        DisplayLinePL(CenterLine('You MUST resolve the above error prior to upgrade'));
5815      ELSE
5816        DisplayLinePL(CenterLine('You MUST resolve the above errors prior to upgrade'));
5817      END IF;
5818      DisplayLinePL(CenterLine('**************************************************'));
5819      DisplayLinePL('');
5820    END IF;
5821    DisplayLinePL('');
5822  END fixup_summary;
5823  
5824  -- ***************************************************************************
5825  --                             Specific Check Area
5826  -- ***************************************************************************
5827  
5828  
5829  -- *****************************************************************
5830  --     AMD_EXISTS Section
5831  -- *****************************************************************
5832  FUNCTION amd_exists_check (result_txt OUT VARCHAR2) RETURN number
5833  IS
5834    n_status NUMBER := -1;
5835  BEGIN
5836    --
5837    -- Is AMD around?
5838    --
5839    BEGIN
5840      EXECUTE IMMEDIATE
5841         'SELECT  status FROM sys.registry$ WHERE cid=''AMD''
5842            AND namespace=''SERVER'''
5843         INTO n_status;
5844    EXCEPTION
5845        WHEN OTHERS THEN NULL; -- AMD not in registry
5846    END;
5847  
5848    IF n_status = -1 AND pDBGFailCheck = FALSE OR pOutputType = c_output_xml THEN
5849      -- AMD not in registry
5850      -- or output is XML, return success
5851      RETURN c_status_success;
5852    END IF;
5853  
5854    --
5855    -- This is a manual only check
5856    --
5857    result_txt := amd_exists_gethelp(c_help_overview);
5858  
5859    IF pOutputtingScripts THEN
5860        genFixup ('AMD_EXISTS');
5861    END IF;
5862    RETURN c_status_failure;
5863  
5864  END amd_exists_check ;
5865  
5866  FUNCTION amd_exists_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
5867  IS
5868  BEGIN
5869    IF HelpType = c_help_overview THEN
5870      return 'INFORMATION: --> OLAP Catalog(AMD) exists in database' || crlf
5871       || crlf || '     Starting with Oracle Database 12c, OLAP is desupported.'
5872       || crlf || '     If you are not using the OLAP Catalog component and want'
5873       || crlf || '     to remove it, then execute the '
5874       || crlf || '     ORACLE_HOME/oraolap/admin/catnoamd.sql script before or '
5875       || crlf || '     after the upgrade.';
5876    ELSIF HelpType = c_help_fixup THEN
5877      return 'Manually execute ORACLE_HOME/oraolap/admin/catnoamd.sql script to remove OLAP.';
5878    END IF;
5879  END amd_exists_gethelp;
5880  --
5881  PROCEDURE amd_exists_fixup
5882  IS
5883    result   VARCHAR2(1000);
5884    status   NUMBER;
5885    tSqlcode  NUMBER;
5886  BEGIN
5887    -- Call fixup and throw away the result
5888    status := amd_exists_fixup (result, tSqlcode);
5889  END amd_exists_fixup;
5890  
5891  FUNCTION amd_exists_fixup (
5892           result_txt IN OUT VARCHAR2,
5893           pSqlcode    IN OUT NUMBER) RETURN number
5894  IS
5895  BEGIN
5896     result_txt := amd_exists_gethelp(c_help_overview);
5897     pSqlcode := 0;
5898     return c_fixup_status_info;
5899  END amd_exists_fixup;
5900  
5901  
5902  -- *****************************************************************
5903  --     AUDIT_ADMIN_ROLE_PRESENT Section
5904  -- *****************************************************************
5905  FUNCTION AAR_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
5906  IS
5907    roll_exists NUMBER := 1;
5908    t_null      CHAR(1);
5909    status      NUMBER;
5910  BEGIN
5911    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
5912      return c_status_not_for_this_version;
5913    END IF;
5914  
5915    BEGIN
5916      EXECUTE IMMEDIATE
5917       'SELECT NULL FROM sys.user$ WHERE name=''AUDIT_ADMIN'''
5918        INTO t_null;
5919      EXCEPTION
5920        WHEN NO_DATA_FOUND then roll_exists := 0;
5921    END;
5922  
5923    IF (roll_exists = 0 AND pDBGFailCheck = FALSE)
5924    THEN
5925      RETURN c_status_success;
5926    ELSE
5927      IF pOutputType = c_output_xml THEN
5928        result_txt:= genDBUAXMLCheck('AUDIT_ADMIN_ROLE_PRESENT',
5929          c_check_level_error,
5930          'A user or role named "AUDIT_ADMIN" found in the database.',
5931          'A user or role named "AUDIT_ADMIN" found in the database.',
5932          '"AUDIT_ADMIN" role or user must be dropped prior to upgrading.',
5933           c_dbua_detail_type_text,
5934          'To drop the role "AUDIT_ADMIN", use the command: '||
5935          ' DROP ROLE AUDIT_ADMIN,' || ' and To drop user "AUDIT_ADMIN"'||
5936          ' use the command: DROP USER AUDIT_ADMIN CASCADE',
5937          c_dbua_fixup_type_manual,
5938          c_dbua_fixup_stage_pre );
5939      ELSE
5940        result_txt := AAR_PRESENT_gethelp(c_help_overview);
5941      END IF;
5942      IF pOutputtingScripts THEN
5943        genFixup ('AUDIT_ADMIN_ROLE_PRESENT');
5944      END IF;
5945      RETURN c_status_failure;
5946     END IF;
5947  END AAR_PRESENT_check;
5948  
5949  FUNCTION AAR_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
5950  IS
5951  BEGIN
5952    IF HelpType = c_help_overview THEN
5953      return 'ERROR: --> A user or role with the name "AUDIT_ADMIN" found in the database.' || crlf
5954        || crlf || '     This is an Oracle defined role.'
5955        || crlf || '     You must drop this role or user prior to upgrading.';
5956    ELSIF HelpType = c_help_fixup THEN
5957      return 'The AUDIT_ADMIN roll must be dropped prior to upgrading.';
5958    END IF;
5959  END AAR_PRESENT_gethelp;
5960  --
5961  -- Fixup (Procedure and function)
5962  --
5963  PROCEDURE AAR_PRESENT_fixup
5964  IS
5965    result  VARCHAR2(1000);
5966    status  NUMBER;
5967    tSqlcode NUMBER;
5968  BEGIN
5969    -- Call fixup and throw away the result
5970    status := AAR_PRESENT_fixup (result, tSqlcode);
5971  END AAR_PRESENT_fixup;
5972  
5973  FUNCTION AAR_PRESENT_fixup (
5974           result_txt IN OUT VARCHAR2,
5975           pSqlcode    IN OUT NUMBER) RETURN number
5976  IS
5977  BEGIN
5978    result_txt :=  AAR_PRESENT_gethelp(c_help_overview);
5979    pSqlcode := 0;
5980    return c_fixup_status_info;
5981  END AAR_PRESENT_fixup;
5982  -- *****************************************************************
5983  --     APPQOSSYS_USER_PRESENT Section
5984  -- *****************************************************************
5985  FUNCTION APPQOSSYS_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
5986  IS
5987    user_exists BOOLEAN;
5988    tmp_num1    NUMBER;
5989    t_null      CHAR(1);
5990    status      NUMBER;
5991  
5992  BEGIN
5993    user_exists := TRUE;  -- Assume its around
5994  
5995    IF (db_n_version NOT IN (102) AND pDBGFailCheck = FALSE) THEN
5996      return c_status_not_for_this_version;
5997    END IF;
5998  
5999    BEGIN
6000      EXECUTE IMMEDIATE 'SELECT user# FROM sys.user$ WHERE name=''APPQOSSYS'''
6001        INTO tmp_num1;
6002      EXCEPTION
6003        WHEN NO_DATA_FOUND then user_exists := FALSE;
6004    END;
6005  
6006    IF user_exists THEN
6007      BEGIN
6008        EXECUTE IMMEDIATE
6009         'SELECT NULL FROM sys.obj$ WHERE owner# = (SELECT user# from SYS.USER$
6010           WHERE name=''APPQOSSYS'') AND
6011             name =''WLM_METRICS_STREAM'' AND  type# = 2'
6012        INTO t_null;
6013      EXCEPTION
6014        WHEN NO_DATA_FOUND then user_exists := TRUE;
6015      END;
6016    END IF;
6017  
6018    IF user_exists = FALSE AND pDBGFailCheck = FALSE
6019    THEN
6020     RETURN c_status_success; -- No issue
6021    ELSE
6022      IF pOutputType = c_output_xml THEN
6023        result_txt:= genDBUAXMLCheck('APPQOSSYS_USER_PRESENT',
6024          c_check_level_warning,
6025          'User APPQOSSYS present in database',
6026          'User APPQOSSYS present in database',
6027          'Remove APPQOSYS user from database.',
6028           c_dbua_detail_type_text,
6029          'The APPQOSSYS user exists in the database.'
6030            || ' This is an internal account and should be '
6031            || ' removed prior to upgrading your database',
6032          c_dbua_fixup_type_auto,
6033          c_dbua_fixup_stage_pre);
6034      ELSE
6035        result_txt := appqossys_user_present_gethelp (c_help_overview);
6036      END IF;
6037      IF pOutputtingScripts THEN
6038        genFixup ('APPQOSSYS_USER_PRESENT');
6039      END IF;
6040      RETURN c_status_failure;
6041     END IF;
6042  END APPQOSSYS_USER_PRESENT_check;
6043  
6044  FUNCTION APPQOSSYS_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6045  IS
6046  BEGIN
6047    IF HelpType = c_help_overview THEN
6048      return 'WARNING: --> "APPQOSSYS" user found in database.' || crlf
6049        || crlf || '     This is an internal account used by '
6050        || crlf || '     Oracle Application Quality of Service Management. '
6051        || crlf || '     Please drop this user prior to upgrading.';
6052    ELSIF HelpType = c_help_fixup THEN
6053      return 'The APPQOSSYS user will will be dropped.';
6054    END IF;
6055  END APPQOSSYS_USER_PRESENT_gethelp;
6056  --
6057  -- Fixup (Procedure and function)
6058  --
6059  PROCEDURE APPQOSSYS_USER_PRESENT_fixup
6060  IS
6061    result  VARCHAR2(1000);
6062    status  NUMBER;
6063    tSqlcode NUMBER;
6064  BEGIN
6065    -- Call fixup and throw away the result
6066    status := APPQOSSYS_USER_PRESENT_fixup (result, tSqlcode);
6067  END APPQOSSYS_USER_PRESENT_fixup;
6068  
6069  FUNCTION APPQOSSYS_USER_PRESENT_fixup (
6070           result_txt IN OUT VARCHAR2,
6071           pSqlcode    IN OUT NUMBER) RETURN number
6072  IS
6073  BEGIN
6074     return execute_sql_statement ('DROP USER APPQOSSYS CASCADE', result_txt, pSqlcode);
6075  END APPQOSSYS_USER_PRESENT_fixup;
6076  -- *****************************************************************
6077  --     AUDSYS_USER_PRESENT Section
6078  -- *****************************************************************
6079  FUNCTION AUDSYS_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
6080  IS
6081    user_exists NUMBER := 1;
6082    t_null      CHAR(1);
6083    status      NUMBER;
6084  BEGIN
6085    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
6086      return c_status_not_for_this_version;
6087    END IF;
6088  
6089    BEGIN
6090      EXECUTE IMMEDIATE
6091       'SELECT NULL FROM sys.user$ WHERE name = ''AUDSYS'''
6092        INTO t_null;
6093      EXCEPTION
6094        WHEN NO_DATA_FOUND then user_exists := 0;
6095    END;
6096    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
6097    THEN
6098      RETURN c_status_success;
6099    ELSE
6100      IF pOutputType = c_output_xml THEN
6101        result_txt:= genDBUAXMLCheck('AUDSYS_USER_PRESENT',
6102          c_check_level_error,
6103          'A user or role named "AUDSYS" found in the database.',
6104          'A user or role named "AUDSYS" found in the database.',
6105          '"AUDSYS" user or role must be dropped prior to upgrading.',
6106           c_dbua_detail_type_text,
6107          'To drop the user "AUDSYS", use the command: '||
6108          'DROP USER AUDSYS CASCADE'||', and To drop the role "AUDSYS", use the'||
6109          'command: DROP ROLE AUDSYS',
6110          c_dbua_fixup_type_manual,
6111          c_dbua_fixup_stage_pre );
6112      ELSE
6113        result_txt := AUDSYS_USER_PRESENT_gethelp(c_help_overview);
6114      END IF;
6115      IF pOutputtingScripts THEN
6116        genFixup ('AUDSYS_USER_PRESENT');
6117      END IF;
6118      RETURN c_status_failure;
6119     END IF;
6120  END AUDSYS_USER_PRESENT_check;
6121  
6122  FUNCTION AUDSYS_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6123  IS
6124  BEGIN
6125    IF HelpType = c_help_overview THEN
6126      return 'ERROR: --> A user or role with the name "AUDSYS" found in the database.' || crlf
6127        || crlf || '     This is an internal account used by Oracle Database Auditing.'
6128        || crlf || '     You must drop this user or role prior to upgrading.';
6129    ELSIF HelpType = c_help_fixup THEN
6130      return 'The AUDSYS user or roll must be dropped prior to upgrading.';
6131    END IF;
6132  END AUDSYS_USER_PRESENT_gethelp;
6133  --
6134  -- Fixup (Procedure and function)
6135  --
6136  PROCEDURE AUDSYS_USER_PRESENT_fixup
6137  IS
6138    result  VARCHAR2(1000);
6139    status  NUMBER;
6140    tSqlcode NUMBER;
6141  BEGIN
6142    -- Call fixup and throw away the result
6143    status := AUDSYS_USER_PRESENT_fixup (result, tSqlcode);
6144  END AUDSYS_USER_PRESENT_fixup;
6145  
6146  FUNCTION AUDSYS_USER_PRESENT_fixup (
6147           result_txt IN OUT VARCHAR2,
6148           pSqlcode    IN OUT NUMBER) RETURN number
6149  IS
6150  BEGIN
6151    result_txt  := AUDSYS_USER_PRESENT_gethelp(c_help_overview);
6152    pSqlcode := 0;
6153    return c_fixup_status_info;
6154  END AUDSYS_USER_PRESENT_fixup;
6155  
6156  -- *****************************************************************
6157  --     AUDIT_VIEWER Section
6158  -- *****************************************************************
6159  FUNCTION AUDIT_VIEWER_check (result_txt OUT VARCHAR2) RETURN number
6160  IS
6161    roll_exists NUMBER := 1;
6162    t_null      CHAR(1);
6163    status      NUMBER;
6164  BEGIN
6165  
6166    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
6167      return c_status_not_for_this_version;
6168    END IF;
6169  
6170    BEGIN
6171      EXECUTE IMMEDIATE
6172       'SELECT NULL FROM sys.user$ WHERE NAME = ''AUDIT_VIEWER'''
6173        INTO t_null;
6174      EXCEPTION
6175        WHEN NO_DATA_FOUND then roll_exists := 0;
6176    END;
6177  
6178    IF (roll_exists = 0 AND pDBGFailCheck = FALSE)
6179    THEN
6180      RETURN c_status_success;
6181    ELSE
6182      IF pOutputType = c_output_xml THEN
6183        result_txt:= genDBUAXMLCheck('AUDIT_VIEWER',
6184          c_check_level_error,
6185          'A user or role named "AUDIT_VIEWER" found in the database.',
6186          'A user or role named "AUDIT_VIEWER" found in the database.',
6187          '"AUDIT_VIEWER" role or user must be dropped prior to upgrading.',
6188           c_dbua_detail_type_text,
6189          'To drop the role "AUDIT_VIEWER", use the command:'
6190          || ' DROP ROLE AUDIT_VIEWER' || ', and To drop the user "AUDIT_VIEWER"'
6191          || ' use the command: DROP USER AUDIT_VIEWER CASCADE',
6192          c_dbua_fixup_type_manual,
6193          c_dbua_fixup_stage_pre );
6194      ELSE
6195        result_txt := AUDIT_VIEWER_gethelp(c_help_overview);
6196      END IF;
6197      IF pOutputtingScripts THEN
6198        genFixup ('AUDIT_VIEWER');
6199      END IF;
6200      RETURN c_status_failure;
6201     END IF;
6202  END AUDIT_VIEWER_check;
6203  
6204  FUNCTION AUDIT_VIEWER_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6205  IS
6206  BEGIN
6207    IF HelpType = c_help_overview THEN
6208      return 'ERROR: --> A user or role with the name "AUDIT_VIEWER" found in the database.' || crlf
6209        || crlf || '     This is an Oracle defined role.'
6210        || crlf || '     You must drop this role or user prior to upgrading.';
6211    ELSIF HelpType = c_help_fixup THEN
6212      return 'The AUDIT_VIEWER roll or user must be dropped prior to upgrading.';
6213    END IF;
6214  END AUDIT_VIEWER_gethelp;
6215  --
6216  -- Fixup (Procedure and function)
6217  --
6218  PROCEDURE AUDIT_VIEWER_fixup
6219  IS
6220    result  VARCHAR2(1000);
6221    status  NUMBER;
6222    tSqlcode NUMBER;
6223  BEGIN
6224    -- Call fixup and throw away the result
6225    status := AUDIT_VIEWER_fixup (result, tSqlcode);
6226  END AUDIT_VIEWER_fixup;
6227  
6228  FUNCTION AUDIT_VIEWER_fixup (
6229           result_txt IN OUT VARCHAR2,
6230           pSqlcode    IN OUT NUMBER) RETURN number
6231  IS
6232  BEGIN
6233    result_txt := AUDIT_VIEWER_gethelp(c_help_overview);
6234    pSqlcode := 0;
6235    return c_fixup_status_info;
6236  END AUDIT_VIEWER_fixup;
6237  
6238  -- *****************************************************************
6239  --     SYSBACKUP_USER_PRESENT Section
6240  -- *****************************************************************
6241  FUNCTION SYSBACKUP_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
6242  IS
6243    user_exists NUMBER := 1;
6244    t_null      CHAR(1);
6245    status      NUMBER;
6246  BEGIN
6247  
6248    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
6249      return c_status_not_for_this_version;
6250    END IF;
6251  
6252    BEGIN
6253      EXECUTE IMMEDIATE
6254       'SELECT NULL FROM sys.user$ WHERE NAME = ''SYSBACKUP'''
6255        INTO t_null;
6256      EXCEPTION
6257        WHEN NO_DATA_FOUND then user_exists := 0;
6258    END;
6259  
6260    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
6261    THEN
6262      RETURN c_status_success;
6263    ELSE
6264      IF pOutputType = c_output_xml THEN
6265        result_txt:= genDBUAXMLCheck('SYSBACKUP',
6266          c_check_level_error,
6267          'A user or role named "SYSBACKUP" found in the database.',
6268          'A user or role named "SYSBACKUP" found in the database.',
6269          '"SYSBACKUP" user or role must be dropped prior to upgrading.',
6270           c_dbua_detail_type_text,
6271          'To drop the role "SYSBACKUP", use the command:'
6272          || ' DROP ROLE SYSBACKUP' || ', and To drop the user "SYSBACKUP"'
6273          || ' use the command: DROP USER SYSBACKUP CASCADE',
6274          c_dbua_fixup_type_manual,
6275          c_dbua_fixup_stage_pre );
6276      ELSE
6277        result_txt := SYSBACKUP_USER_PRESENT_gethelp(c_help_overview);
6278      END IF;
6279      IF pOutputtingScripts THEN
6280        genFixup ('SYSBACKUP_USER_PRESENT');
6281      END IF;
6282      RETURN c_status_failure;
6283     END IF;
6284  END SYSBACKUP_USER_PRESENT_check;
6285  
6286  FUNCTION SYSBACKUP_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6287  IS
6288  BEGIN
6289    IF HelpType = c_help_overview THEN
6290      return 'ERROR: --> A user or role with the name "SYSBACKUP" found in the database.' || crlf
6291        || crlf || '     This is an Oracle defined user.'
6292        || crlf || '     You must drop this user or role prior to upgrading.';
6293    ELSIF HelpType = c_help_fixup THEN
6294      return 'The SYSBACKUP user or role must be dropped prior to upgrading.';
6295    END IF;
6296  END SYSBACKUP_USER_PRESENT_gethelp;
6297  --
6298  -- Fixup (Procedure and function)
6299  --
6300  PROCEDURE SYSBACKUP_USER_PRESENT_fixup
6301  IS
6302    result  VARCHAR2(1000);
6303    status  NUMBER;
6304    tSqlcode NUMBER;
6305  BEGIN
6306    -- Call fixup and throw away the result
6307    status := SYSBACKUP_USER_PRESENT_fixup (result, tSqlcode);
6308  END SYSBACKUP_USER_PRESENT_fixup;
6309  
6310  FUNCTION SYSBACKUP_USER_PRESENT_fixup (
6311           result_txt IN OUT VARCHAR2,
6312           pSqlcode    IN OUT NUMBER) RETURN number
6313  IS
6314  BEGIN
6315    result_txt := SYSBACKUP_USER_PRESENT_gethelp(c_help_overview);
6316    pSqlcode := 0;
6317    return c_fixup_status_info;
6318  END SYSBACKUP_USER_PRESENT_fixup;
6319  
6320  -- *****************************************************************
6321  --     SYSDG_USER_PRESENT Section
6322  -- *****************************************************************
6323  FUNCTION SYSDG_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
6324  IS
6325    user_exists NUMBER := 1;
6326    t_null      CHAR(1);
6327    status      NUMBER;
6328  BEGIN
6329  
6330    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
6331      return c_status_not_for_this_version;
6332    END IF;
6333  
6334    BEGIN
6335      EXECUTE IMMEDIATE
6336       'SELECT NULL FROM sys.user$ WHERE NAME = ''SYSDG'''
6337        INTO t_null;
6338      EXCEPTION
6339        WHEN NO_DATA_FOUND then user_exists := 0;
6340    END;
6341  
6342    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
6343    THEN
6344      RETURN c_status_success;
6345    ELSE
6346      IF pOutputType = c_output_xml THEN
6347        result_txt:= genDBUAXMLCheck('SYSDG',
6348          c_check_level_error,
6349          'A user or role named "SYSDG" found in the database.',
6350          'A user or role named "SYSDG" found in the database.',
6351          '"SYSDG" user or role must be dropped prior to upgrading.',
6352           c_dbua_detail_type_text,
6353          'To drop the role "SYSDG", use the command:'
6354          || ' DROP ROLE SYSDG' || ', and To drop the user "SYSDG"'
6355          || ' use the command: DROP USER SYSDG CASCADE',
6356          c_dbua_fixup_type_manual,
6357          c_dbua_fixup_stage_pre );
6358      ELSE
6359        result_txt := SYSDG_USER_PRESENT_gethelp(c_help_overview);
6360      END IF;
6361      IF pOutputtingScripts THEN
6362        genFixup ('SYSDG_USER_PRESENT');
6363      END IF;
6364      RETURN c_status_failure;
6365     END IF;
6366  END SYSDG_USER_PRESENT_check;
6367  
6368  FUNCTION SYSDG_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6369  IS
6370  BEGIN
6371    IF HelpType = c_help_overview THEN
6372      return 'ERROR: --> A user or role with the name "SYSDG" found in the database.' || crlf
6373        || crlf || '     This is an Oracle defined user.'
6374        || crlf || '     You must drop this user or role prior to upgrading.';
6375    ELSIF HelpType = c_help_fixup THEN
6376      return 'The SYSDG role or user must be dropped prior to upgrading.';
6377    END IF;
6378  END SYSDG_USER_PRESENT_gethelp;
6379  --
6380  -- Fixup (Procedure and function)
6381  --
6382  PROCEDURE SYSDG_USER_PRESENT_fixup
6383  IS
6384    result  VARCHAR2(1000);
6385    status  NUMBER;
6386    tSqlcode NUMBER;
6387  BEGIN
6388    -- Call fixup and throw away the result
6389    status := SYSDG_USER_PRESENT_fixup (result, tSqlcode);
6390  END SYSDG_USER_PRESENT_fixup;
6391  
6392  FUNCTION SYSDG_USER_PRESENT_fixup (
6393           result_txt IN OUT VARCHAR2,
6394           pSqlcode    IN OUT NUMBER) RETURN number
6395  IS
6396  BEGIN
6397    result_txt := SYSDG_USER_PRESENT_gethelp(c_help_overview);
6398    pSqlcode := 0;
6399    return c_fixup_status_info;
6400  END SYSDG_USER_PRESENT_fixup;
6401  
6402  -- *****************************************************************
6403  --     SYSKM_USER_PRESENT Section
6404  -- *****************************************************************
6405  FUNCTION SYSKM_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
6406  IS
6407    user_exists NUMBER := 1;
6408    t_null      CHAR(1);
6409    status      NUMBER;
6410  BEGIN
6411  
6412    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
6413      return c_status_not_for_this_version;
6414    END IF;
6415  
6416    BEGIN
6417      EXECUTE IMMEDIATE
6418       'SELECT NULL FROM sys.user$ WHERE NAME = ''SYSKM'''
6419        INTO t_null;
6420      EXCEPTION
6421        WHEN NO_DATA_FOUND then user_exists := 0;
6422    END;
6423  
6424    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
6425    THEN
6426      RETURN c_status_success;
6427    ELSE
6428      IF pOutputType = c_output_xml THEN
6429        result_txt:= genDBUAXMLCheck('SYSKM',
6430          c_check_level_error,
6431          'A user or role named "SYSKM" found in the database.',
6432          'A user or role named "SYSKM" found in the database.',
6433          '"SYSKM" user or role must be dropped prior to upgrading.',
6434           c_dbua_detail_type_text,
6435          'To drop the role "SYSKM", use the command:'
6436          || ' DROP ROLE SYSKM' || ', and To drop the user "SYSKM"'
6437          || ' use the command: DROP USER SYSKM CASCADE',
6438          c_dbua_fixup_type_manual,
6439          c_dbua_fixup_stage_pre );
6440      ELSE
6441        result_txt := SYSKM_USER_PRESENT_gethelp(c_help_overview);
6442      END IF;
6443      IF pOutputtingScripts THEN
6444        genFixup ('SYSKM_USER_PRESENT');
6445      END IF;
6446      RETURN c_status_failure;
6447     END IF;
6448  END SYSKM_USER_PRESENT_check;
6449  
6450  FUNCTION SYSKM_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6451  IS
6452  BEGIN
6453    IF HelpType = c_help_overview THEN
6454      return 'ERROR: --> A user or role with the name "SYSKM" found in the database.' || crlf
6455        || crlf || '     This is an Oracle defined user.'
6456        || crlf || '     You must drop this user or role prior to upgrading.';
6457    ELSIF HelpType = c_help_fixup THEN
6458      return 'The SYSKM user or role must be dropped prior to upgrading.';
6459    END IF;
6460  END SYSKM_USER_PRESENT_gethelp;
6461  --
6462  -- Fixup (Procedure and function)
6463  --
6464  PROCEDURE SYSKM_USER_PRESENT_fixup
6465  IS
6466    result  VARCHAR2(1000);
6467    status  NUMBER;
6468    tSqlcode NUMBER;
6469  BEGIN
6470    -- Call fixup and throw away the result
6471    status := SYSKM_USER_PRESENT_fixup (result, tSqlcode);
6472  END SYSKM_USER_PRESENT_fixup;
6473  
6474  FUNCTION SYSKM_USER_PRESENT_fixup (
6475           result_txt IN OUT VARCHAR2,
6476           pSqlcode    IN OUT NUMBER) RETURN number
6477  IS
6478  BEGIN
6479    result_txt := SYSKM_USER_PRESENT_gethelp(c_help_overview);
6480    pSqlcode := 0;
6481    return c_fixup_status_info;
6482  END SYSKM_USER_PRESENT_fixup;
6483  
6484  -- *****************************************************************
6485  --     CAPT_ADM_ROLE_PRESENT Section
6486  -- *****************************************************************
6487  FUNCTION CAPT_ADM_ROLE_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
6488  IS
6489    role_exists NUMBER := 1;
6490    t_null      CHAR(1);
6491    status      NUMBER;
6492  BEGIN
6493  
6494    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
6495      return c_status_not_for_this_version;
6496    END IF;
6497  
6498    BEGIN
6499      EXECUTE IMMEDIATE
6500       'SELECT NULL FROM sys.user$ WHERE NAME = ''CAPTURE_ADMIN'''
6501        INTO t_null;
6502      EXCEPTION
6503        WHEN NO_DATA_FOUND then role_exists := 0;
6504    END;
6505  
6506    IF (role_exists = 0 AND pDBGFailCheck = FALSE)
6507    THEN
6508      RETURN c_status_success;
6509    ELSE
6510      IF pOutputType = c_output_xml THEN
6511        result_txt:= genDBUAXMLCheck('CAPTURE_ADMIN',
6512          c_check_level_error,
6513          'A user or role named "CAPTURE_ADMIN" found in the database.',
6514          'A user or role named "CAPTURE_ADMIN" found in the database.',
6515          '"CAPTURE_ADMIN" user or role must be dropped prior to upgrading.',
6516           c_dbua_detail_type_text,
6517          'To drop the role "CAPTURE_ADMIN", use the command:'
6518          || ' DROP ROLE CAPTURE_ADMIN' || ', and To drop the user "CAPTURE_ADMIN"'
6519          || ' use the command: DROP USER CAPTURE_ADMIN CASCADE',
6520          c_dbua_fixup_type_manual,
6521          c_dbua_fixup_stage_pre );
6522      ELSE
6523        result_txt := CAPT_ADM_ROLE_PRESENT_gethelp(c_help_overview);
6524      END IF;
6525      IF pOutputtingScripts THEN
6526        genFixup ('CAPT_ADM_ROLE_PRESENT');
6527      END IF;
6528      RETURN c_status_failure;
6529     END IF;
6530  END CAPT_ADM_ROLE_PRESENT_check;
6531  
6532  FUNCTION CAPT_ADM_ROLE_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6533  IS
6534  BEGIN
6535    IF HelpType = c_help_overview THEN
6536      return 'ERROR: --> A user or role with the name "CAPTURE_ADMIN" found in the database.' || crlf
6537        || crlf || '     This is an Oracle defined role.'
6538        || crlf || '     You must drop this user or role prior to upgrading.';
6539    ELSIF HelpType = c_help_fixup THEN
6540      return 'The CAPTURE_ADMIN user or role must be dropped prior to upgrading.';
6541    END IF;
6542  END CAPT_ADM_ROLE_PRESENT_gethelp;
6543  --
6544  -- Fixup (Procedure and function)
6545  --
6546  PROCEDURE CAPT_ADM_ROLE_PRESENT_fixup
6547  IS
6548    result  VARCHAR2(1000);
6549    status  NUMBER;
6550    tSqlcode NUMBER;
6551  BEGIN
6552    -- Call fixup and throw away the result
6553    status := CAPT_ADM_ROLE_PRESENT_fixup (result, tSqlcode);
6554  END CAPT_ADM_ROLE_PRESENT_fixup;
6555  
6556  FUNCTION CAPT_ADM_ROLE_PRESENT_fixup (
6557           result_txt IN OUT VARCHAR2,
6558           pSqlcode    IN OUT NUMBER) RETURN number
6559  IS
6560  BEGIN
6561    result_txt := CAPT_ADM_ROLE_PRESENT_gethelp(c_help_overview);
6562    pSqlcode := 0;
6563    return c_fixup_status_info;
6564  END CAPT_ADM_ROLE_PRESENT_fixup;
6565  
6566  -- *****************************************************************
6567  --     AWR_DBIDS_PRESENT Section
6568  -- *****************************************************************
6569  FUNCTION AWR_DBIDS_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
6570  IS
6571    roll_exists NUMBER := 1;
6572    t_null      CHAR(1);
6573    status      NUMBER;
6574  BEGIN
6575    BEGIN
6576      EXECUTE IMMEDIATE
6577       'SELECT NULL FROM sys.wrm$_wr_control WHERE dbid != (SELECT dbid FROM v$database)'
6578        INTO t_null;
6579      EXCEPTION
6580        WHEN NO_DATA_FOUND then roll_exists := 0;
6581    END;
6582  
6583    IF (roll_exists = 0 AND pDBGFailCheck = FALSE)
6584    THEN
6585      RETURN c_status_success;
6586    ELSE
6587      IF pOutputType = c_output_xml THEN
6588        result_txt:= genDBUAXMLCheck('AWR_DBIDS_PRESENT',
6589          c_check_level_warning,
6590          'Inactive DBIDs found in AWR',
6591          'Inactive DBIDs found in AWR.',
6592          'The inactive DBIDs in AWR may need additional updating after ' ||
6593          'upgrading.',
6594           c_dbua_detail_type_text,
6595          'To update the inactive DBIDs in AWR, run the script awrupd12.sql as SYSDBA',
6596          c_dbua_fixup_type_manual,
6597          c_dbua_fixup_stage_post );
6598      ELSE
6599        result_txt := AWR_DBIDS_PRESENT_gethelp(c_help_overview);
6600      END IF;
6601      IF pOutputtingScripts THEN
6602        genFixup ('AWR_DBIDS_PRESENT');
6603      END IF;
6604      RETURN c_status_failure;
6605     END IF;
6606  END AWR_DBIDS_PRESENT_check;
6607  
6608  FUNCTION AWR_DBIDS_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6609  IS
6610  BEGIN
6611    IF HelpType = c_help_overview THEN
6612      return 'WARNING: --> Inactive DBIDs found in AWR' || crlf
6613        || crlf || '     AWR contains inactive DBIDs which may need additional updating after' || crlf || '     upgrading.';
6614    ELSIF HelpType = c_help_fixup THEN
6615      return 'The inactive DBIDs in AWR may need additional updating after upgrading.';
6616    END IF;
6617  END AWR_DBIDS_PRESENT_gethelp;
6618  
6619  --
6620  -- Fixup (Procedure and function)
6621  --
6622  PROCEDURE AWR_DBIDS_PRESENT_fixup
6623  IS
6624    result  VARCHAR2(1000);
6625    status  NUMBER;
6626    tSqlcode NUMBER;
6627  BEGIN
6628    -- Call fixup and throw away the result
6629    status := AWR_DBIDS_PRESENT_fixup (result, tSqlcode);
6630  END AWR_DBIDS_PRESENT_fixup;
6631  
6632  FUNCTION AWR_DBIDS_PRESENT_fixup (
6633           result_txt IN OUT VARCHAR2,
6634           pSqlcode    IN OUT NUMBER) RETURN number
6635  IS
6636  BEGIN
6637    result_txt := AWR_DBIDS_PRESENT_gethelp(c_help_overview);
6638    pSqlcode := 0;
6639    return c_fixup_status_info;
6640  END AWR_DBIDS_PRESENT_fixup;
6641  
6642  -- *****************************************************************
6643  --     compatible_parameter Section
6644  -- *****************************************************************
6645  FUNCTION compatible_parameter_check (result_txt OUT VARCHAR2) RETURN number
6646  IS
6647    status      NUMBER;
6648  BEGIN
6649    --
6650    -- If we have the correct min compat and not debug and not XML
6651    -- return success.
6652    --
6653    IF ((db_compat_majorver >= c_compat_min_num AND pDBGFailCheck = FALSE)  OR
6654        pOutputType = c_output_xml)  THEN
6655      RETURN c_status_success;
6656    END IF;
6657  
6658    result_txt := compatible_parameter_gethelp(c_help_overview);
6659    IF pOutputtingScripts THEN
6660      genFixup ('COMPATIBLE_PARAMETER');
6661    END IF;
6662    RETURN c_status_failure;
6663  END compatible_parameter_check;
6664  
6665  FUNCTION compatible_parameter_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6666  IS
6667    result_txt VARCHAR2(1500);
6668  BEGIN
6669    IF HelpType = c_help_overview THEN
6670      result_txt := 'ERROR: --> Compatible set too low' || crlf
6671        || crlf || '     "compatible" currently set at ' || db_compat ||    ' and must'
6672        || crlf || '     be set to at least '           || c_compat_min || ' prior to upgrading the database.';
6673  
6674      IF db_n_version = 102 THEN
6675        result_txt := result_txt
6676            || crlf || '     Do not make this change until you are ready to upgrade'
6677            || crlf || '     because a downgrade back to 10.2 is not possible once compatible'
6678            || crlf || '     has been raised.';
6679      END IF;
6680      result_txt := result_txt
6681         || crlf || crlf || '     Update your init.ora or spfile to make this change.';
6682    ELSIF HelpType = c_help_fixup THEN
6683      result_txt := '"compatible" parameter must be increased manually prior to upgrade.';
6684    END IF;
6685    RETURN result_txt;
6686  END compatible_parameter_gethelp;
6687  --
6688  -- Fixup (Procedure and function)
6689  --
6690  PROCEDURE compatible_parameter_fixup
6691  IS
6692    result  VARCHAR2(1000);
6693    status  NUMBER;
6694    tSqlcode NUMBER;
6695  BEGIN
6696    -- Call fixup and throw away the result
6697    status := compatible_parameter_fixup (result, tSqlcode);
6698  END compatible_parameter_fixup;
6699  
6700  FUNCTION compatible_parameter_fixup (
6701           result_txt IN OUT VARCHAR2,
6702           pSqlcode    IN OUT NUMBER) RETURN number
6703  IS
6704  BEGIN
6705     result_txt := compatible_parameter_gethelp(c_help_overview);
6706     pSqlcode := 0;
6707     return c_fixup_status_info;
6708  END compatible_parameter_fixup;
6709  
6710  -- *****************************************************************
6711  --     DBMS_LDAP_DEPENDENCIES_EXIST Section
6712  -- *****************************************************************
6713  FUNCTION DBMS_LDAP_DEP_EXIST_check (result_txt OUT VARCHAR2) RETURN number
6714  IS
6715    t_null      CHAR(1);
6716    status      NUMBER := 0;
6717  BEGIN
6718  
6719    BEGIN
6720      EXECUTE IMMEDIATE 'SELECT NULL FROM dba_dependencies
6721          WHERE referenced_name IN (''DBMS_LDAP'')
6722          AND owner NOT IN (''SYS'',''PUBLIC'',''ORD_PLUGINS'')
6723          AND rownum <= 1'
6724      INTO t_null;
6725        status := 1;
6726      EXCEPTION
6727        WHEN NO_DATA_FOUND THEN NULL;
6728    END;
6729  
6730    IF (status = 0 AND pDBGFailCheck = FALSE)
6731    THEN
6732      RETURN c_status_success;
6733    ELSE
6734      IF pOutputType = c_output_xml THEN
6735        result_txt:= genDBUAXMLCheck('DBMS_LDAP_DEPENDENCIES_EXIST',
6736          c_check_level_warning,
6737          'Database contains schemas with objects dependent on DBMS_LDAP package.'
6738            || ' Refer to the Upgrade Guide for instructions to configure Network ACLs.',
6739          'Database contains schemas with objects dependent on DBMS_LDAP package.',
6740          'Refer to the Upgrade Guide for instructions to configure Network ACLs.',
6741           c_dbua_detail_type_sql,
6742          htmlentities('SELECT name FROM dba_dependencies WHERE'
6743             || ' referenced_name IN (''DBMS_LDAP'') '
6744             || ' AND owner NOT IN (''SYS'',''PUBLIC'',''ORD_PLUGINS'')'
6745             || ' AND rownum <= 1'),
6746          c_dbua_fixup_type_auto,
6747          c_dbua_fixup_stage_pre );
6748      ELSE
6749        result_txt := DBMS_LDAP_DEP_EXIST_gethelp(c_help_overview);
6750      END IF;
6751      IF pOutputtingScripts THEN
6752        genFixup ('DBMS_LDAP_DEPENDENCIES_EXIST');
6753      END IF;
6754      RETURN c_status_failure;
6755     END IF;
6756  END DBMS_LDAP_DEP_EXIST_check;
6757  
6758  FUNCTION DBMS_LDAP_DEP_EXIST_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6759  IS
6760    tmp_cursor   cursor_t;
6761    tmp_varchar1 VARCHAR2(512);
6762    tstr         VARCHAR2(1000);
6763    result_txt   VARCHAR2(1500);
6764  BEGIN
6765    IF HelpType = c_help_overview THEN
6766      result_txt := 'WARNING: --> Existing DBMS_LDAP dependent objects' || crlf
6767        || crlf || '     Database contains schemas with objects dependent on DBMS_LDAP package.'
6768        || crlf || '     Refer to the Upgrade Guide for instructions to configure Network ACLs.';
6769      tstr := '';
6770      OPEN tmp_cursor FOR
6771        'SELECT DISTINCT owner FROM DBA_DEPENDENCIES
6772           WHERE referenced_name IN (''DBMS_LDAP'')
6773               AND owner NOT IN (''SYS'',''PUBLIC'',''ORDPLUGINS'')';
6774      LOOP
6775        FETCH tmp_cursor INTO tmp_varchar1;
6776        EXIT WHEN tmp_cursor%NOTFOUND;
6777        tstr := tstr || crlf || '     USER ' || tmp_varchar1 || ' has dependent objects.';
6778      END LOOP;
6779      IF (tstr IS NOT NULL OR tstr != '' ) THEN
6780        result_txt := result_txt || tstr;
6781      END IF;
6782      CLOSE tmp_cursor;
6783    ELSIF HelpType = c_help_fixup THEN
6784      result_txt := 'Network Objects must be reviewed manually.';
6785    END IF;
6786    RETURN result_txt;
6787  END DBMS_LDAP_DEP_EXIST_gethelp;
6788  --
6789  -- Fixup (Procedure and function)
6790  --
6791  PROCEDURE DBMS_LDAP_DEP_EXIST_fixup
6792  IS
6793    result  VARCHAR2(1000);
6794    status  NUMBER;
6795    tSqlcode NUMBER;
6796  BEGIN
6797    -- Call fixup and throw away the result
6798    status := DBMS_LDAP_DEP_EXIST_fixup (result, tSqlcode);
6799  END DBMS_LDAP_DEP_EXIST_fixup;
6800  
6801  FUNCTION DBMS_LDAP_DEP_EXIST_fixup (
6802           result_txt IN OUT VARCHAR2,
6803           pSqlcode    IN OUT NUMBER) RETURN number
6804  IS
6805  BEGIN
6806     result_txt := DBMS_LDAP_DEP_EXIST_gethelp(c_help_overview);
6807     return c_fixup_status_info;
6808  END DBMS_LDAP_DEP_EXIST_fixup;
6809  
6810  -- *****************************************************************
6811  --     default_process_count Section
6812  -- *****************************************************************
6813  FUNCTION default_process_count_check (result_txt OUT VARCHAR2) RETURN number
6814  IS
6815    processes NUMBER;
6816    status    NUMBER;
6817  BEGIN
6818    EXECUTE IMMEDIATE 'SELECT value FROM V$PARAMETER WHERE NAME=''processes'''
6819      INTO processes;
6820    --
6821    -- Right number of processes (and not debug) or XML
6822    -- output, return success
6823    --
6824    IF ( (processes >= c_max_processes AND  pDBGFailCheck = FALSE) OR
6825        pOutputType = c_output_xml ) THEN
6826      RETURN c_status_success;
6827    END IF;
6828  
6829    result_txt := default_process_count_gethelp(c_help_overview);
6830  
6831    IF pOutputtingScripts THEN
6832      genFixup ('DEFAULT_PROCESS_COUNT');
6833    END IF;
6834    RETURN c_status_failure;
6835  END default_process_count_check;
6836  
6837  FUNCTION default_process_count_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6838  IS
6839    processes NUMBER;
6840  BEGIN
6841    IF HelpType = c_help_overview THEN
6842      EXECUTE IMMEDIATE 'SELECT value FROM V$PARAMETER WHERE NAME=''processes'''
6843        INTO processes;
6844      return 'WARNING: --> Process Count may be too low' || crlf
6845       || crlf || '     Database has a maximum process count of '
6846                      || processes || ' which is lower than the'
6847       || crlf || '     default value of ' || c_max_processes || ' for this release.'
6848       || crlf || '     You should update your processes value prior to the upgrade'
6849       || crlf || '     to a value of at least ' || c_max_processes || '.'
6850       || crlf || '     For example:'
6851       || crlf || '        ALTER SYSTEM SET PROCESSES=' || c_max_processes || ' SCOPE=SPFILE'
6852       || crlf || '     or update your init.ora file.';
6853    ELSIF HelpType = c_help_fixup THEN
6854      return 'Review and increase if needed, your PROCESSES value.';
6855    END IF;
6856  END default_process_count_gethelp;
6857  --
6858  -- Fixup (Procedure and function)
6859  --
6860  PROCEDURE default_process_count_fixup
6861  IS
6862    result  VARCHAR2(1000);
6863    status  NUMBER;
6864    tSqlcode NUMBER;
6865  BEGIN
6866    -- Call fixup and throw away the result
6867    status := default_process_count_fixup (result, tSqlcode);
6868  END default_process_count_fixup;
6869  
6870  FUNCTION default_process_count_fixup (
6871           result_txt IN OUT VARCHAR2,
6872           pSqlcode    IN OUT NUMBER) RETURN number
6873  IS
6874  BEGIN
6875     result_txt := default_process_count_gethelp(c_help_overview);
6876     return c_fixup_status_info;
6877  END default_process_count_fixup;
6878  
6879  -- *****************************************************************
6880  --     DV_ENABLED Section
6881  -- *****************************************************************
6882  FUNCTION DV_ENABLED_check (result_txt OUT VARCHAR2) RETURN number
6883  IS
6884    t_null      CHAR(1);
6885    status      NUMBER;
6886  BEGIN
6887  
6888    IF (db_n_version IN (102,111,112) and pDBGFailCheck = FALSE) THEN
6889      -- 12.1 and above...
6890      return c_status_not_for_this_version;
6891    END IF;
6892  
6893    BEGIN
6894      EXECUTE IMMEDIATE 'SELECT NULL FROM sys.registry$ r, v$option o
6895           WHERE r.cid = ''DV'' and r.cname = o.parameter and
6896            o.value = ''TRUE'''
6897      INTO t_null;
6898      status := 1;
6899     EXCEPTION
6900        WHEN NO_DATA_FOUND THEN
6901          status := 0;
6902    END;
6903  
6904    IF (status = 0 and pDBGFailCheck = FALSE)
6905    THEN
6906      RETURN c_status_success;
6907    ELSE
6908      IF pOutputType = c_output_xml THEN
6909        result_txt:= genDBUAXMLCheck('DV_ENABLED',
6910          c_check_level_info,
6911          'Database Vault option is enabled. Database Vault is disabled during upgrade'
6912           || ' and re-enabled after the upgrade.',
6913          'Database Vault option is enabled.',
6914          'Disable the Database Vault option prior to Upgrade',
6915           c_dbua_detail_type_sql,
6916           htmlentities ('SELECT r.cid FROM sys.registry$ r, v$option o '
6917              || 'WHERE r.cid = ''DV'' and r.cname = o.parameter and '
6918              || 'o.value = ''TRUE'''),
6919          c_dbua_fixup_type_auto,
6920          c_dbua_fixup_stage_pre );
6921      ELSE
6922        result_txt := DV_ENABLED_gethelp(c_help_overview);
6923      END IF;
6924      IF pOutputtingScripts THEN
6925        genFixup ('DV_ENABLED');
6926      END IF;
6927      RETURN c_status_failure;
6928    END IF;
6929  END;
6930  
6931  FUNCTION DV_ENABLED_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
6932  IS
6933  BEGIN
6934    IF HelpType = c_help_overview THEN
6935      return 'WARNING: --> Oracle Database Vault is enabled in this database' || crlf
6936        || crlf || '     Starting with release 12.1, it is REQUIRED that Database Vault be'
6937        || crlf || '     disabled prior to database upgrade. To disable Database Vault, log'
6938        || crlf || '     in as Database Vault administrator and run this operation:'
6939        || crlf || '     DVSYS.DBMS_MACAMD.DISABLE_DV()';
6940    ELSIF HelpType = c_help_fixup THEN
6941      return 'Database Vault must be disabled prior to upgrading.';
6942    END IF;
6943  END DV_ENABLED_gethelp;
6944  --
6945  -- Fixup (Procedure and function)
6946  --
6947  PROCEDURE DV_ENABLED_fixup
6948  IS
6949    result  VARCHAR2(1500);
6950    status  NUMBER;
6951    tSqlcode NUMBER;
6952  BEGIN
6953    -- Call fixup and throw away the result
6954    status := DV_ENABLED_fixup (result, tSqlcode);
6955  END DV_ENABLED_fixup;
6956  
6957  FUNCTION DV_ENABLED_fixup (
6958           result_txt IN OUT VARCHAR2,
6959           pSqlcode    IN OUT NUMBER) RETURN number
6960  IS
6961  BEGIN
6962    -- Dump out the same thing we give for help
6963    result_txt := DV_ENABLED_gethelp(c_help_overview);
6964    return c_fixup_status_info;
6965  END DV_ENABLED_fixup;
6966  
6967  -- *****************************************************************
6968  --     EM_PRESENT Section
6969  -- *****************************************************************
6970  FUNCTION EM_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
6971  IS
6972    t_null      CHAR(1);
6973    status      NUMBER;
6974  BEGIN
6975  
6976    BEGIN
6977      EXECUTE IMMEDIATE  'SELECT NULL FROM sys.registry$ WHERE cid=''EM''
6978        AND status NOT IN (99,8)'
6979      INTO  t_null;
6980        status := 1;
6981      EXCEPTION
6982        WHEN NO_DATA_FOUND THEN
6983        status := 0;
6984    END;
6985  
6986    IF (status = 0 and pDBGFailCheck = FALSE)
6987    THEN
6988      -- EM not here.
6989      RETURN c_status_success;
6990    ELSE
6991      IF pOutputType = c_output_xml THEN
6992        result_txt:= genDBUAXMLCheck('EM_PRESENT',
6993          c_check_level_info,
6994          'Enterprise Manager Database Control repository exists in the database.'
6995           || ' In 12c, the database is managed by MiniGC.'
6996           || ' The Enterprise Manager database Control Repository is removed during the upgrade',
6997          'Enterprise Manager Database Control repository is removed',
6998          'Enterprise Manager data can be migrated.',
6999           c_dbua_detail_type_text,
7000          'The EM Database data can be migrated/removed prior to upgrade.',
7001          c_dbua_fixup_type_auto,
7002          c_dbua_fixup_stage_pre );
7003      ELSE
7004        result_txt := EM_PRESENT_gethelp(c_help_overview);
7005      END IF;
7006      IF pOutputtingScripts THEN
7007        genFixup ('EM_PRESENT');
7008      END IF;
7009     RETURN c_status_failure;
7010     END IF;
7011  END;
7012  
7013  FUNCTION EM_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7014  IS
7015  BEGIN
7016    IF HelpType = c_help_overview THEN
7017      return 'WARNING: --> Enterprise Manager Database Control repository found in the database' || crlf
7018             || crlf || '     In Oracle Database 12c, Database Control is removed during'
7019             || crlf || '     the upgrade. To save time during the Upgrade, this action'
7020             || crlf || '     can be done prior to upgrading using the following steps after'
7021             || crlf || '     copying rdbms/admin/emremove.sql from the new Oracle home'
7022             || crlf || '   - Stop EM Database Control:'
7023             || crlf || '    $> emctl stop dbconsole'
7024             || crlf
7025             || crlf || '   - Connect to the Database using the SYS account AS SYSDBA:'
7026             || crlf
7027             || crlf || '   SET ECHO ON;'
7028             || crlf || '   SET SERVEROUTPUT ON;'
7029             || crlf || '   @emremove.sql'
7030             || crlf || '     Without the set echo and serveroutput commands you will not '
7031             || crlf || '     be able to follow the progress of the script.';
7032    ELSIF HelpType = c_help_fixup THEN
7033      return 'Execute emremove.sql prior to upgrade.';
7034    END IF;
7035  END;
7036  --
7037  -- Fixup (Procedure and function)
7038  --
7039  PROCEDURE EM_PRESENT_fixup
7040  IS
7041    result  VARCHAR2(1000);
7042    status  NUMBER;
7043    tSqlcode NUMBER;
7044  BEGIN
7045    -- Call fixup and throw away the result
7046    status := EM_PRESENT_fixup (result, tSqlcode);
7047  END;
7048  FUNCTION EM_PRESENT_fixup (
7049           result_txt IN OUT VARCHAR2,
7050           pSqlcode    IN OUT NUMBER) RETURN number
7051  IS
7052  BEGIN
7053    -- The removal is done during the upgrade.
7054    -- Dump out the same thing we give for help
7055    result_txt := EM_PRESENT_gethelp(c_help_overview);
7056    return c_fixup_status_info;
7057  END;
7058  
7059  -- *****************************************************************
7060  --     ENABLED_INDEXES_TBL Section
7061  -- *****************************************************************
7062  FUNCTION ENABLED_INDEXES_TBL_check (result_txt OUT VARCHAR2) RETURN number
7063  IS
7064    status  NUMBER := 0;
7065    t_count   INTEGER;
7066  BEGIN
7067    --
7068    -- Check for pre-existing temporary table sys.enabled$indexes.
7069    -- If it exists, then warn the user to DROP SYS.ENABLED$INDEXES.
7070    --
7071    BEGIN
7072      EXECUTE IMMEDIATE 'SELECT COUNT(1) FROM sys.enabled$indexes'
7073      INTO t_count;
7074      IF (t_count >= 0) THEN
7075        status := 1;
7076      END IF;
7077    EXCEPTION
7078      WHEN OTHERS THEN NULL;
7079    END;
7080  
7081    IF (status = 0 AND pDBGFailCheck = FALSE)
7082    THEN
7083      RETURN c_status_success;
7084    ELSE
7085      IF pOutputType = c_output_xml THEN
7086        result_txt:= genDBUAXMLCheck('ENABLED_INDEXES_TBL',
7087          c_check_level_warning,
7088          'Table sys.enabled$indexes exists in the database',
7089          'Table sys.enabled$indexes exists in the database',
7090          'Drop table prior to upgrade.',
7091           c_dbua_detail_type_text,
7092          'To view if enabled indexes execute, execute the following'
7093            || ' query: SELECT COUNT(1) FROM SYS.ENABLED$INDEXES',
7094          c_dbua_fixup_type_auto,
7095          c_dbua_fixup_stage_pre);
7096      ELSE
7097        result_txt := ENABLED_INDEXES_TBL_gethelp(c_help_overview);
7098      END IF;
7099      IF pOutputtingScripts THEN
7100        genFixup ('ENABLED_INDEXES_TBL');
7101      END IF;
7102      RETURN c_status_failure;
7103     END IF;
7104  END ENABLED_INDEXES_TBL_check;
7105  
7106  FUNCTION ENABLED_INDEXES_TBL_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7107  IS
7108  BEGIN
7109    IF HelpType = c_help_overview THEN
7110      return 'WARNING: --> Table sys.enabled$indexes exists in the database' || crlf
7111       || crlf || '     DROP TABLE sys.enabled$indexes prior to upgrading the database.';
7112    ELSIF HelpType = c_help_fixup THEN
7113      return 'Drop table sys.enabled$indexes.';
7114    END IF;
7115  END ENABLED_INDEXES_TBL_gethelp;
7116  --
7117  -- Fixup (Procedure and function)
7118  --
7119  PROCEDURE ENABLED_INDEXES_TBL_fixup
7120  IS
7121    result  VARCHAR2(1000);
7122    status  NUMBER;
7123    tSqlcode NUMBER;
7124  BEGIN
7125    -- Call fixup and throw away the result
7126    status := ENABLED_INDEXES_TBL_fixup (result, tSqlcode);
7127  END ENABLED_INDEXES_TBL_fixup;
7128  
7129  FUNCTION ENABLED_INDEXES_TBL_fixup (
7130           result_txt IN OUT VARCHAR2,
7131           pSqlcode    IN OUT NUMBER) RETURN number
7132  IS
7133  BEGIN
7134     return execute_sql_statement ('DROP TABLE sys.enabled$indexes', result_txt, pSqlcode);
7135  END ENABLED_INDEXES_TBL_fixup;
7136  
7137  -- *****************************************************************
7138  --     EXF_RUL_EXISTS Section
7139  -- *****************************************************************
7140  FUNCTION exf_rul_exists_check (result_txt OUT VARCHAR2) RETURN number
7141  IS
7142    n_status NUMBER := -1;
7143  BEGIN
7144    --
7145    -- See if EXF and/or RUL components exist, they will be
7146    -- removed during the upgrade so let them know they can remove them
7147    -- before the upgrade.
7148    --
7149    BEGIN
7150      EXECUTE IMMEDIATE
7151         'SELECT  status FROM sys.registry$ WHERE (cid=''RUL'' OR cid=''EXF'')
7152            WHERE namespace=''SERVER'''
7153         INTO n_status;
7154    EXCEPTION
7155        WHEN OTHERS THEN NULL; -- EXF or RUL not in registry
7156    END;
7157  
7158    IF n_status = -1 AND pDBGFailCheck = FALSE THEN
7159      --
7160      -- does not exist
7161      --
7162      return c_status_success;
7163    END IF;
7164  
7165    IF pOutputType = c_output_xml THEN
7166      result_txt:= genDBUAXMLCheck('EXF_RUL_EXIST',
7167          c_check_level_info,
7168          'Expression Filter (EXF) or Rules Manager (RUL) exist in database.',
7169          'Expression Filter (EXF) and Rules Manager (RUL) are desupported in 12.1.',
7170          'Expression Filter (EXF) and Rules Manager (RUL) will be removed during the upgrade.',
7171           c_dbua_detail_type_text,
7172          htmlentities('To drop EXF and RUL prior to upgrade'||
7173          ' execute @?/rdbms/admin/catnoexf.sql script'),
7174          c_dbua_fixup_type_auto,
7175          c_dbua_fixup_stage_pre );
7176      ELSE
7177      result_txt := exf_rul_exists_gethelp(c_help_overview);
7178    END IF;
7179  
7180    IF pOutputtingScripts THEN
7181        genFixup ('EXF_RUL_EXISTS');
7182    END IF;
7183    RETURN c_status_failure;
7184  END exf_rul_exists_check ;
7185  
7186  FUNCTION exf_rul_exists_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7187  IS
7188  BEGIN
7189    IF HelpType = c_help_overview THEN
7190      return 'INFORMATION: --> Expression Filter (EXF) or Rules Manager (RUL) exist in database and will be removed during the upgrade.' || crlf
7191       || crlf || '     Starting with Oracle Database release 12.1, the Expression Filter (EXF) and Database Rules Manager (RUL)'
7192       || crlf || '     features are desupported and will be removed during the upgrade process.  To save time during'
7193       || crlf || '     the upgrade, this action can be done prior to upgrading by executing the ORACLE_HOME/rdbms/admin/catnoexf.sql script.';
7194    ELSIF HelpType = c_help_fixup THEN
7195      return 'Manually execute ORACLE_HOME/rdbms/admin/catnoexf.sql script to remove EXF and RUL.';
7196    END IF;
7197  END exf_rul_exists_gethelp;
7198  --
7199  PROCEDURE exf_rul_exists_fixup
7200  IS
7201    result   VARCHAR2(1000);
7202    status   NUMBER;
7203    tSqlcode  NUMBER;
7204  BEGIN
7205    -- Call fixup and throw away the result
7206    status := exf_rul_exists_fixup (result, tSqlcode);
7207  END exf_rul_exists_fixup;
7208  
7209  FUNCTION exf_rul_exists_fixup (
7210           result_txt IN OUT VARCHAR2,
7211           pSqlcode    IN OUT NUMBER) RETURN number
7212  IS
7213  BEGIN
7214     result_txt := exf_rul_exists_gethelp(c_help_overview);
7215     pSqlcode := 0;
7216     return c_fixup_status_info;
7217  END exf_rul_exists_fixup;
7218  
7219  -- *****************************************************************
7220  --     FILES_NEED_RECOVERY Section
7221  -- *****************************************************************
7222  FUNCTION FILES_NEED_RECOVERY_check (result_txt OUT VARCHAR2) RETURN number
7223  IS
7224    t_null      CHAR(1);
7225    status      NUMBER;
7226  BEGIN
7227    BEGIN
7228      EXECUTE IMMEDIATE 'SELECT NULL FROM v$recover_file WHERE rownum <=1'
7229      INTO t_null;
7230      status := 1;
7231     EXCEPTION
7232        WHEN NO_DATA_FOUND THEN status := 0;
7233     END;
7234  
7235    IF (status = 0 and pDBGFailCheck = FALSE)
7236    THEN
7237      RETURN c_status_success;
7238    ELSE
7239      IF pOutputType = c_output_xml THEN
7240        result_txt:= genDBUAXMLCheck('FILES_NEED_RECOVERY',
7241          c_check_level_warning,
7242          'There are files that need media recovery. Ensure no files need media recovery prior to upgrade.',
7243          'There are files that need media recovery.',
7244          'Ensure no files need recovery.',
7245           c_dbua_detail_type_sql,
7246          htmlentities ('SELECT count(*) FROM v$recover_file WHERE rownum <=1'),
7247          c_dbua_fixup_type_manual,
7248          c_dbua_fixup_stage_pre );
7249      ELSE
7250        result_txt := FILES_NEED_RECOVERY_gethelp(c_help_overview);
7251      END IF;
7252      IF pOutputtingScripts THEN
7253        genFixup ('FILES_NEED_RECOVERY');
7254      END IF;
7255      RETURN c_status_failure;
7256     END IF;
7257  END;
7258  
7259  FUNCTION FILES_NEED_RECOVERY_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7260  IS
7261  BEGIN
7262    IF HelpType = c_help_overview THEN
7263      return 'ERROR: --> There are files which need media recovery' || crlf
7264        || crlf || '     Ensure no files need media recovery prior to upgrade.';
7265    ELSIF HelpType = c_help_fixup THEN
7266      return 'Recover or repair these files prior to upgrade.';
7267    END IF;
7268  END FILES_NEED_RECOVERY_gethelp;
7269  --
7270  -- Fixup (Procedure and function)
7271  --
7272  PROCEDURE FILES_NEED_RECOVERY_fixup
7273  IS
7274    result  VARCHAR2(1000);
7275    status  NUMBER;
7276    tSqlcode NUMBER;
7277  BEGIN
7278    -- Call fixup and throw away the result
7279    status := FILES_NEED_RECOVERY_fixup (result, tSqlcode);
7280  END FILES_NEED_RECOVERY_fixup;
7281  
7282  FUNCTION FILES_NEED_RECOVERY_fixup (
7283           result_txt IN OUT VARCHAR2,
7284           pSqlcode    IN OUT NUMBER) RETURN number
7285  IS
7286  BEGIN
7287    -- The removal is done during the upgrade.
7288    -- Dump out the same thing we give for help
7289    result_txt := FILES_NEED_RECOVERY_gethelp(c_help_overview);
7290    return c_fixup_status_info;
7291  END FILES_NEED_RECOVERY_fixup;
7292  
7293  -- *****************************************************************
7294  --     FILES_BACKUP_MODE Section
7295  -- *****************************************************************
7296  FUNCTION FILES_BACKUP_MODE_check (result_txt OUT VARCHAR2) RETURN number
7297  IS
7298    roll_exists NUMBER := 1;
7299    t_null      CHAR(1);
7300    status      NUMBER;
7301  BEGIN
7302  
7303    IF (db_n_version NOT IN (102,111,112) and pDBGFailCheck = FALSE) THEN
7304      return c_status_not_for_this_version;
7305    END IF;
7306  
7307    BEGIN
7308      EXECUTE IMMEDIATE
7309       'SELECT NULL FROM sys.user$ WHERE (name=''FILES_BACKUP_MODE'' and type#=0)'
7310        INTO t_null;
7311      EXCEPTION
7312        WHEN NO_DATA_FOUND then roll_exists := 0;
7313    END;
7314  
7315    IF (roll_exists = 0 and pDBGFailCheck = FALSE)
7316    THEN
7317      RETURN c_status_success;
7318    ELSE
7319      IF pOutputType = c_output_xml THEN
7320        result_txt:= genDBUAXMLCheck('FILES_BACKUP_MODE',
7321          c_check_level_warning,
7322          'There are files in backup mode. Ensure no files are in backup mode prior to upgrade.',
7323          'Ensure no files are in backup mode prior to upgrade.',
7324          'Ensure no files are in backup mode prior to upgrade.',
7325           c_dbua_detail_type_sql,
7326          'SELECT name FROM sys.user$ WHERE (name=''FILES_BACKUP_MODE'' and type#=0)',
7327          c_dbua_fixup_type_manual,
7328          c_dbua_fixup_stage_pre);
7329      ELSE
7330        result_txt := FILES_BACKUP_MODE_gethelp(c_help_overview);
7331      END IF;
7332      IF pOutputtingScripts THEN
7333        genFixup ('FILES_BACKUP_MODE');
7334      END IF;
7335      RETURN c_status_failure;
7336     END IF;
7337  END FILES_BACKUP_MODE_check;
7338  
7339  FUNCTION FILES_BACKUP_MODE_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7340  IS
7341  BEGIN
7342    IF HelpType = c_help_overview THEN
7343      return 'ERROR: --> There are files in backup mode' || crlf
7344        || crlf || '     Ensure no files are in backup mode prior to upgrade.';
7345    ELSIF HelpType = c_help_fixup THEN
7346      return 'Verify that no files are in backup mode prior to upgrade.';
7347    END IF;
7348  END FILES_BACKUP_MODE_gethelp;
7349  --
7350  -- Fixup (Procedure and function)
7351  --
7352  PROCEDURE FILES_BACKUP_MODE_fixup
7353  IS
7354    result  VARCHAR2(1000);
7355    status  NUMBER;
7356    tSqlcode NUMBER;
7357  BEGIN
7358    -- Call fixup and throw away the result
7359    status := FILES_BACKUP_MODE_fixup (result, tSqlcode);
7360  END FILES_BACKUP_MODE_fixup;
7361  
7362  FUNCTION FILES_BACKUP_MODE_fixup (
7363           result_txt IN OUT VARCHAR2,
7364           pSqlcode    IN OUT NUMBER) RETURN number
7365  IS
7366  BEGIN
7367    -- Dump out the same thing we give for help
7368    result_txt := FILES_BACKUP_MODE_gethelp(c_help_overview);
7369    return c_fixup_status_info;
7370  END FILES_BACKUP_MODE_fixup;
7371  
7372  -- *****************************************************************
7373  --     INVALID_LOG_ARCHIVE_FORMAT Section
7374  -- *****************************************************************
7375  FUNCTION INVALID_LAF_check (result_txt OUT VARCHAR2) RETURN number
7376  IS
7377    laf_format   VARCHAR2(4000);
7378    tmp_varchar1 VARCHAR2(512);
7379    t_null       CHAR(1);
7380    status       NUMBER := 0;
7381  BEGIN
7382  
7383     --
7384     -- invalid log_archive_format check
7385     --
7386     -- for 9.x, RDBMS set a default value which did not include %r,
7387     -- which is required by 11.2.
7388     -- Grab the format string, and if its defaulted or not,
7389     -- Only report an error if its NOT defaulted (user set) and it is
7390     -- missing the %r.
7391     --
7392     BEGIN
7393       EXECUTE IMMEDIATE
7394          'SELECT value, isdefault FROM v$parameter WHERE name = ''log_archive_format'''
7395       INTO laf_format, tmp_varchar1;
7396     EXCEPTION WHEN OTHERS THEN NULL;
7397     END;
7398  
7399     IF (tmp_varchar1 = 'FALSE') AND
7400        (instr (LOWER(laf_format), '%r') = 0) THEN
7401       --
7402       -- no %[r|R] and we are not defaulted by the system - we have to report something...
7403       --
7404       status := 1;
7405     END IF;
7406  
7407    IF (status = 0 AND pDBGFailCheck = FALSE)
7408    THEN
7409      RETURN c_status_success;
7410    ELSE
7411      IF pOutputType = c_output_xml THEN
7412        --
7413        -- DBUA will fix this up by changing the param
7414        -- so its an INFO
7415        --
7416        result_txt:= genDBUAXMLCheck('INVALID_LOG_ARCHIVE_FORMAT',
7417          c_check_level_info,
7418          'Initialization parameter log_archive_format must contain %s, %t and %r.'
7419            || ' Database Upgrade Assistant will update this parameter to database'
7420            || ' default value. This value can be customized after the upgrade.',
7421          'log_archive_format is invalid',
7422          'Update your initialization parameter to a valid value.',
7423           c_dbua_detail_type_sql,
7424          htmlentities('select value from v$parameter where name = ''log_archive_format'''),
7425          c_dbua_fixup_type_manual,
7426          c_dbua_fixup_stage_pre );
7427      ELSE
7428        result_txt  := INVALID_LAF_gethelp(c_help_overview);
7429      END IF;
7430      IF pOutputtingScripts THEN
7431        genFixup ('INVALID_LOG_ARCHIVE_FORMAT');
7432      END IF;
7433      RETURN c_status_failure;
7434     END IF;
7435  END INVALID_LAF_check;
7436  
7437  FUNCTION INVALID_LAF_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7438  IS
7439    format    VARCHAR2(4000);
7440    log_mode  VARCHAR2(30);
7441    result_txt VARCHAR2(4000);
7442  BEGIN
7443    IF HelpType = c_help_overview THEN
7444      EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE name = ''log_archive_format'''
7445       INTO format;
7446      EXECUTE IMMEDIATE 'SELECT LOG_MODE from v$database'
7447         INTO log_mode;
7448      result_txt := 'ERROR: --> log_archive_format must be updated' || crlf
7449        || crlf || '     As of 10.1, log_archive_format requires a %r format qualifier'
7450        || crlf || '     be present in its format string.  Your current setting is:'
7451        || crlf || '     log_archive_format=''' || format || '''.';
7452      IF log_mode = 'NOARCHIVELOG' THEN
7453        result_txt := result_txt
7454          || crlf || '     Archive Logging is currently OFF, but failure to add the %r to the'
7455          || crlf || '     format string will still prevent the upgraded database from starting up.';
7456      ELSE
7457        result_txt := result_txt
7458          || crlf || '     Archive Logging is currently ON, and failure to add the %r to the'
7459          || crlf || '     format string will prevent the upgraded database from starting up.';
7460      END IF;
7461    ELSIF HelpType = c_help_fixup THEN
7462      result_txt := 'Update log_archive_format prior to upgrade.';
7463    END IF;
7464    RETURN result_txt;
7465  END INVALID_LAF_gethelp;
7466  --
7467  -- Fixup (Procedure and function)
7468  --
7469  PROCEDURE INVALID_LAF_fixup
7470  IS
7471    result  VARCHAR2(1000);
7472    status  NUMBER;
7473    tSqlcode NUMBER;
7474  BEGIN
7475    -- Call fixup and throw away the result
7476    status := INVALID_LAF_fixup (result, tSqlcode);
7477  END INVALID_LAF_fixup;
7478  
7479  FUNCTION INVALID_LAF_fixup (
7480           result_txt IN OUT VARCHAR2,
7481           pSqlcode    IN OUT NUMBER) RETURN number
7482  IS
7483  BEGIN
7484    -- Dump out the same thing we give for help
7485    result_txt := INVALID_LAF_gethelp(c_help_overview);
7486    return c_fixup_status_info;
7487  END INVALID_LAF_fixup;
7488  
7489  -- *****************************************************************
7490  --     INVALID_OBJECTS_EXIST Section
7491  -- *****************************************************************
7492  FUNCTION INVALID_OBJ_EXIST_check (result_txt OUT VARCHAR2) RETURN number
7493  IS
7494    t_null              CHAR(1);
7495    invalid_objs        BOOLEAN := FALSE;
7496    status              NUMBER;
7497    tbl_exists          NUMBER;
7498    nonsys_invalid_objs NUMBER;
7499  BEGIN
7500    --
7501    -- Check for INVALID objects
7502    -- For "inplace" upgrades check for invalid objects that can be excluded
7503    -- as they may have changed between releases and don't need to be reported.
7504    --
7505    -- For all other types of upgrades, use the simple query below to
7506    -- eliminate running the intricate queries except when they are needed.
7507    --
7508    BEGIN
7509      IF NOT db_inplace_upgrade  THEN
7510        EXECUTE IMMEDIATE 'SELECT NULL FROM sys.dba_objects
7511            WHERE status = ''INVALID'' AND object_name NOT LIKE ''BIN$%'' AND
7512               rownum <=1'
7513        INTO t_null;
7514        -- For patch release - update the objects in the query below
7515      ELSE
7516        -- V_$ROLLNAME special cased because of references  to x$ tables
7517        EXECUTE IMMEDIATE 'SELECT NULL FROM SYS.DBA_OBJECTS
7518             WHERE status = ''INVALID'' AND object_name NOT LIKE ''BIN$%'' AND
7519                rownum <=1 AND
7520                object_name NOT IN
7521                   (SELECT name FROM SYS.dba_dependencies
7522                      START WITH referenced_name IN (
7523                           ''V$LOGMNR_SESSION'', ''V$ACTIVE_SESSION_HISTORY'',
7524                           ''V$BUFFERED_SUBSCRIBERS'',  ''GV$FLASH_RECOVERY_AREA_USAGE'',
7525                           ''GV$ACTIVE_SESSION_HISTORY'', ''GV$BUFFERED_SUBSCRIBERS'',
7526                           ''V$RSRC_PLAN'', ''V$SUBSCR_REGISTRATION_STATS'',
7527                           ''GV$STREAMS_APPLY_READER'',''GV$ARCHIVE_DEST'',
7528                           ''GV$LOCK'',''DBMS_STATS_INTERNAL'',''V$STREAMS_MESSAGE_TRACKING'',
7529                           ''GV$SQL_SHARED_CURSOR'',''V$RMAN_COMPRESSION_ALGORITHM'',
7530                           ''V$RSRC_CONS_GROUP_HISTORY'',''V$PERSISTENT_SUBSCRIBERS'',''V$RMAN_STATUS'',
7531                           ''GV$RSRC_CONSUMER_GROUP'',''V$ARCHIVE_DEST'',''GV$RSRCMGRMETRIC'',
7532                           ''GV$RSRCMGRMETRIC_HISTORY'',''V$PERSISTENT_QUEUES'',''GV$CPOOL_CONN_INFO'',
7533                           ''GV$RMAN_COMPRESSION_ALGORITHM'',''DBA_BLOCKERS'',''V$STREAMS_TRANSACTION'',
7534                           ''V$STREAMS_APPLY_READER'',''GV$SGA_DYNAMIC_FREE_MEMORY'',''GV$BUFFERED_QUEUES'',
7535                           ''GV$RSRC_PLAN_HISTORY'',''GV$ENCRYPTED_TABLESPACES'',''V$ENCRYPTED_TABLESPACES'',
7536                           ''GV$RSRC_CONS_GROUP_HISTORY'',''GV$RSRC_PLAN'',
7537                           ''GV$RSRC_SESSION_INFO'',''V$RSRCMGRMETRIC'',''V$STREAMS_CAPTURE'',
7538                           ''V$RSRCMGRMETRIC_HISTORY'',''GV$STREAMS_TRANSACTION'',''DBMS_LOGREP_UTIL'',
7539                           ''V$RSRC_SESSION_INFO'',''GV$STREAMS_CAPTURE'',''V$RSRC_PLAN_HISTORY'',
7540                           ''GV$FLASHBACK_DATABASE_LOGFILE'',''V$BUFFERED_QUEUES'',
7541                           ''GV$PERSISTENT_SUBSCRIBERS'',''GV$FILESTAT'',''GV$STREAMS_MESSAGE_TRACKING'',
7542                           ''V$RSRC_CONSUMER_GROUP'',''V$CPOOL_CONN_INFO'',''DBA_DML_LOCKS'',
7543                           ''V$FLASHBACK_DATABASE_LOGFILE'',''GV$HM_RECOMMENDATION'',
7544                           ''V$SQL_SHARED_CURSOR'',''GV$PERSISTENT_QUEUES'',''GV$FILE_HISTOGRAM'',
7545                           ''DBA_WAITERS'',''GV$SUBSCR_REGISTRATION_STATS'')
7546                                  AND referenced_type in (''VIEW'',''PACKAGE'') OR
7547                            name = ''V_$ROLLNAME''
7548                               CONNECT BY
7549                                 PRIOR name = referenced_name and
7550                                 PRIOR type = referenced_type)'
7551        INTO t_null;
7552      END IF;
7553      invalid_objs := TRUE;
7554      EXCEPTION
7555        WHEN NO_DATA_FOUND THEN NULL;
7556    END;
7557  
7558    -- create a table to store invalid objects (create it if necessary)
7559    IF NOT db_readonly THEN
7560      tbl_exists := 0;
7561      EXECUTE IMMEDIATE
7562        'SELECT count(*) FROM dba_tables
7563           WHERE table_name = ''REGISTRY$SYS_INV_OBJS'''
7564      INTO tbl_exists;
7565  
7566      IF tbl_exists != 0 -- if registry$sys_inv_objs table exists
7567      THEN
7568        -- Truncate table first
7569        EXECUTE IMMEDIATE 'TRUNCATE TABLE registry$sys_inv_objs';
7570  
7571        -- Insert into table
7572        EXECUTE IMMEDIATE
7573          'INSERT INTO registry$sys_inv_objs
7574           SELECT owner,object_name,object_type
7575             FROM sys.dba_objects
7576             WHERE status !=''VALID'' AND owner in (''SYS'',''SYSTEM'')
7577             ORDER BY owner';
7578      ELSE
7579        -- Create invalid objects table and populate with all SYS and SYSTEM
7580        -- invalid objects
7581        EXECUTE IMMEDIATE
7582          'CREATE TABLE registry$sys_inv_objs AS
7583            SELECT owner,object_name,object_type
7584              FROM sys.dba_objects
7585              WHERE status !=''VALID'' AND owner in (''SYS'',''SYSTEM'')
7586              ORDER BY owner';
7587      END IF;  -- IF/ELSE registry$sys_inv_objs exists
7588  
7589      -- If there are less than 5000 non-sys invalid objects then create
7590      -- another table with non-SYS/SYSTEM owned objects.
7591      -- If there are more than 5000 total then that is too many
7592      -- for utluiobj.sql to handle so output a message.
7593      EXECUTE IMMEDIATE 'SELECT count(*) FROM sys.dba_objects
7594              WHERE status !=''VALID'' AND owner NOT in (''SYS'',''SYSTEM'')'
7595      INTO nonsys_invalid_objs;
7596  
7597      IF nonsys_invalid_objs < 5000 THEN
7598        tbl_exists := 0;
7599        EXECUTE IMMEDIATE
7600          'SELECT count(*) FROM dba_tables
7601             WHERE table_name = ''REGISTRY$NONSYS_INV_OBJS'''
7602        INTO tbl_exists;
7603  
7604        IF tbl_exists != 0 -- if registry$nonsys_inv_objs table exists
7605        THEN
7606          -- Truncate table first
7607          EXECUTE IMMEDIATE 'TRUNCATE TABLE registry$nonsys_inv_objs';
7608  
7609          -- Insert into table next
7610          EXECUTE IMMEDIATE
7611            'INSERT INTO registry$nonsys_inv_objs
7612             SELECT owner,object_name,object_type
7613               FROM sys.dba_objects
7614               WHERE status !=''VALID'' AND owner NOT in (''SYS'',''SYSTEM'')
7615               ORDER BY owner';
7616        ELSE  -- if table does not exist
7617          -- Create invalid objects table and populate with non-SYS and
7618          -- non-SYSTEM invalid objects
7619          EXECUTE IMMEDIATE
7620             'CREATE TABLE registry$nonsys_inv_objs
7621                AS
7622              SELECT owner,object_name,object_type
7623                FROM sys.dba_objects
7624                WHERE status !=''VALID'' AND owner NOT in (''SYS'',''SYSTEM'')
7625                ORDER BY owner';
7626        END IF;  -- IF/ELSE registry$nonsys_inv_objs exists
7627      END IF;  -- IF/ELSE nonsys_invalid_objs > 5000
7628      COMMIT;
7629    END IF; -- db NOT readonly
7630  
7631    --
7632    -- Now get back to reporting the issue if we need to.
7633    --
7634    IF invalid_objs = FALSE AND pDBGFailCheck = FALSE THEN
7635      RETURN c_status_success;
7636    ELSE
7637      IF pOutputType = c_output_xml THEN
7638        result_txt:= genDBUAXMLCheck('INVALID_OBJECTS_EXIST',
7639          c_check_level_warning,
7640            'There are INVALID objects in the database.  Invalid SYS/SYSTEM objects'
7641            || ' was written to REGISTRY$SYS_INV_OBJS.  Invalid non-SYS/SYSTEM objects'
7642            || ' was written to REGISTRY$NONSYS_INV_OBJS.  Use utluiobj.sql after the'
7643            || ' upgrade to identify any new invalid objects due to the upgrade.',
7644          'Invalid object found in the database.',
7645          'It is recommended that utlprp.sql be run to attempt to validate objects',
7646           c_dbua_detail_type_sql,
7647           'SELECT owner,object_name,object_type from registry$sys_inv_objs',
7648          c_dbua_fixup_type_manual,
7649          c_dbua_fixup_stage_pre);
7650      ELSE
7651        result_txt := INVALID_OBJ_EXIST_gethelp(c_help_overview);
7652      END IF;
7653      IF pOutputtingScripts THEN
7654        genFixup ('INVALID_OBJECTS_EXIST');
7655      END IF;
7656      RETURN c_status_failure;
7657    END IF;
7658  END INVALID_OBJ_EXIST_check;
7659  
7660  FUNCTION INVALID_OBJ_EXIST_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7661  IS
7662  BEGIN
7663    IF HelpType = c_help_overview THEN
7664      return 'WARNING: --> Database contains INVALID objects prior to upgrade' || crlf
7665        || crlf || '     The list of invalid SYS/SYSTEM objects was written to'
7666        || crlf || '     registry$sys_inv_objs.'
7667        || crlf || '     The list of non-SYS/SYSTEM objects was written to'
7668        || crlf || '     registry$nonsys_inv_objs unless there were over 5000.'
7669        || crlf || '     Use utluiobj.sql after the upgrade to identify any new invalid'
7670        || crlf || '     objects due to the upgrade.';
7671    ELSIF HelpType = c_help_fixup THEN
7672      return 'Invalid objects are displayed and must be reviewed.';
7673    END IF;
7674  END INVALID_OBJ_EXIST_gethelp;
7675  --
7676  -- Fixup (Procedure and function)
7677  --
7678  PROCEDURE INVALID_OBJ_EXIST_fixup
7679  IS
7680    result  VARCHAR2(1000);
7681    status  NUMBER;
7682    tSqlcode NUMBER;
7683  BEGIN
7684    -- Call fixup and throw away the result
7685    status := INVALID_OBJ_EXIST_fixup (result, tSqlcode);
7686  END INVALID_OBJ_EXIST_fixup;
7687  
7688  FUNCTION INVALID_OBJ_EXIST_fixup (
7689           result_txt IN OUT VARCHAR2,
7690           pSqlcode    IN OUT NUMBER) RETURN number
7691  IS
7692  BEGIN
7693    result_txt := INVALID_OBJ_EXIST_gethelp(c_help_overview);
7694    pSqlcode := 0;
7695    return c_fixup_status_info;
7696    --
7697    -- This could be executed by post-fixup
7698     --   return execute_sql_statement ('@?/rdbms/admin/utlprp.sql', result_txt, pSqlcode);
7699  END INVALID_OBJ_EXIST_fixup;
7700  
7701  FUNCTION invalid_obj_exclude RETURN VARCHAR2
7702  --
7703  -- The list of invalid objects to 'accept' as invalid
7704  --
7705  IS
7706  BEGIN
7707    return '''V$LOGMNR_SESSION'', ''V$ACTIVE_SESSION_HISTORY'', ''V$BUFFERED_SUBSCRIBERS'','
7708       || '''GV$FLASH_RECOVERY_AREA_USAGE'', ''GV$ACTIVE_SESSION_HISTORY'','
7709       || '''GV$BUFFERED_SUBSCRIBERS'', ''V$RSRC_PLAN'', ''V$SUBSCR_REGISTRATION_STATS'','
7710       || '''GV$STREAMS_APPLY_READER'',''GV$ARCHIVE_DEST'', ''GV$LOCK'',''DBMS_STATS_INTERNAL'','
7711       || '''V$STREAMS_MESSAGE_TRACKING'', ''GV$SQL_SHARED_CURSOR'',''V$RMAN_COMPRESSION_ALGORITHM'','
7712       || '''V$RSRC_CONS_GROUP_HISTORY'',''V$PERSISTENT_SUBSCRIBERS'',''V$RMAN_STATUS'','
7713       || '''GV$RSRC_CONSUMER_GROUP'',''V$ARCHIVE_DEST'',''GV$RSRCMGRMETRIC'','
7714       || '''GV$RSRCMGRMETRIC_HISTORY'',''V$PERSISTENT_QUEUES'',''GV$CPOOL_CONN_INFO'','
7715       || '''GV$RMAN_COMPRESSION_ALGORITHM'',''DBA_BLOCKERS'',''V$STREAMS_TRANSACTION'','
7716       || '''V$STREAMS_APPLY_READER'',''GV$SGA_DYNAMIC_FREE_MEMORY'',''GV$BUFFERED_QUEUES'','
7717       || '''GV$RSRC_PLAN_HISTORY'',''GV$ENCRYPTED_TABLESPACES'',''V$ENCRYPTED_TABLESPACES'','
7718       || '''GV$RSRC_CONS_GROUP_HISTORY'',''GV$RSRC_PLAN'',''GV$RSRC_SESSION_INFO'','
7719       || '''V$RSRCMGRMETRIC'',''V$STREAMS_CAPTURE'',''V$RSRCMGRMETRIC_HISTORY'','
7720       || '''GV$STREAMS_TRANSACTION'',''DBMS_LOGREP_UTIL'',''V$RSRC_SESSION_INFO'','
7721       || '''GV$STREAMS_CAPTURE'',''V$RSRC_PLAN_HISTORY'',''GV$FLASHBACK_DATABASE_LOGFILE'','
7722       || '''V$BUFFERED_QUEUES'',''GV$PERSISTENT_SUBSCRIBERS'',''GV$FILESTAT'','
7723       || '''GV$STREAMS_MESSAGE_TRACKING'',''V$RSRC_CONSUMER_GROUP'',''V$CPOOL_CONN_INFO'','
7724       || '''DBA_DML_LOCKS'', ''V$FLASHBACK_DATABASE_LOGFILE'',''GV$HM_RECOMMENDATION'','
7725       || '''V$SQL_SHARED_CURSOR'',''GV$PERSISTENT_QUEUES'',''GV$FILE_HISTOGRAM'','
7726       || '''DBA_WAITERS'',''GV$SUBSCR_REGISTRATION_STATS'', ''DBA_KGLLOCK''';
7727  END invalid_obj_exclude;
7728  
7729  -- *****************************************************************
7730  --     INVALID_SYS_TABLEDATA Section
7731  -- *****************************************************************
7732  FUNCTION INVALID_SYS_TABLEDATA_check (result_txt OUT VARCHAR2) RETURN number
7733  IS
7734    t_count  NUMBER;
7735    status   NUMBER;
7736  BEGIN
7737    --
7738    BEGIN
7739      EXECUTE IMMEDIATE  'SELECT COUNT(*) '                         ||
7740        'FROM SYS.OBJ$ o, SYS.COL$ c, SYS.COLTYPE$ t, SYS.USER$ u ' ||
7741        'WHERE o.OBJ# = t.OBJ# AND c.OBJ# = t.OBJ# '                ||
7742          'AND c.COL# = t.COL# AND t.INTCOL# = c.INTCOL# '          ||
7743          'AND BITAND(t.FLAGS, 256) = 256 AND o.OWNER# = u.USER# '  ||
7744          'AND o.OWNER# in '                                        ||
7745           '(SELECT r.schema# FROM SYS.REGISTRY$ r '                ||
7746             'WHERE r.NAMESPACE = ''SERVER'')'
7747       INTO t_count;
7748      EXCEPTION
7749        WHEN NO_DATA_FOUND THEN t_count := 0;
7750    END;
7751  
7752    IF (t_count <= 0 and pDBGFailCheck = FALSE)
7753    THEN
7754      -- Nothing to do.
7755      RETURN c_status_success;
7756  
7757    ELSE
7758      IF pOutputType = c_output_xml THEN
7759        result_txt:= genDBUAXMLCheck('INVALID_SYS_TABLEDATA',
7760          c_check_level_error,
7761          'Database contains table data which has not been upgraded. Proceeding'
7762           || ' with an Upgrade before upgrading the table data can lead to'
7763           || ' data loss. ',
7764          'Invalid table data found in database.',
7765          'Use "ALTER TABLE ... UPGRADE INCLUDING DATA" prior to upgrade.',
7766           c_dbua_detail_type_text,
7767          'Use "ALTER TABLE ... UPGRADE INCLUDING DATA" prior to upgrade.',
7768          c_dbua_fixup_type_auto,
7769          c_dbua_fixup_stage_validation );
7770      ELSE
7771        result_txt := INVALID_SYS_TABLEDATA_gethelp(c_help_overview);
7772      END IF;
7773      IF pOutputtingScripts THEN
7774        genFixup ('INVALID_SYS_TABLEDATA');
7775      END IF;
7776     RETURN c_status_failure;
7777     END IF;
7778  END;
7779  
7780  FUNCTION INVALID_SYS_TABLEDATA_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7781  IS
7782  BEGIN
7783    IF HelpType = c_help_overview THEN
7784      return 'ERROR: --> Invalid Oracle supplied table data found in your database.' || crlf
7785             || crlf || '     Invalid data can be seen prior to the database upgrade'
7786             || crlf || '     or during PDB plug in.  This table data must be made'
7787             || crlf || '     valid BEFORE upgrade or plug in.'
7788             || crlf
7789             || crlf || '   - To fix the data, load the Preupgrade package and execute'
7790             || crlf || '     the fixup routine.'
7791             || crlf || '     For plug in, execute the fix up routine in the PDB.'
7792             || crlf
7793             || crlf || '    @?/rdbms/admin/utluppkg.sql'
7794             || crlf || '    SET SERVEROUTPUT ON;'
7795             || crlf || '    exec dbms_preup.run_fixup_and_report(''INVALID_SYS_TABLEDATA'')'
7796             || crlf || '    SET SERVEROUTPUT OFF;';
7797    ELSIF HelpType = c_help_fixup THEN
7798      return 'UPGRADE Oracle supplied table data prior to the database upgrade.';
7799    END IF;
7800  END;
7801  --
7802  -- Fixup (Procedure and function)
7803  --
7804  PROCEDURE INVALID_SYS_TABLEDATA_fixup
7805  IS
7806    result  VARCHAR2(1000);
7807    status  NUMBER;
7808    tSqlcode NUMBER;
7809  BEGIN
7810    -- Call fixup and throw away the result
7811    status := INVALID_SYS_TABLEDATA_fixup (result, tSqlcode);
7812  END;
7813  FUNCTION INVALID_SYS_TABLEDATA_fixup (
7814           result_txt IN OUT VARCHAR2,
7815           pSqlcode    IN OUT NUMBER) RETURN number
7816  IS
7817    t_cursor     cursor_t;
7818    t_tabname    sys.obj$.name%TYPE;
7819    t_schema     sys.user$.name%TYPE;
7820    t_full_name  VARCHAR2(261); -- extra for quotes and .
7821    t_sqltxt     VARCHAR2(4000);
7822    t_new_err    VARCHAR2(500);
7823    t_error      BOOLEAN := FALSE;
7824    t_took_error BOOLEAN := FALSE;
7825    t_sqlcode    NUMBER;  -- The last sql error we took
7826    t_len        NUMBER;
7827  
7828  BEGIN
7829    result_txt := '';
7830  
7831    OPEN t_cursor FOR 'SELECT DISTINCT (o.NAME), u.NAME '          ||
7832      'FROM SYS.OBJ$ o, SYS.COL$ c, SYS.COLTYPE$ t, SYS.USER$ u '  ||
7833      'WHERE o.OBJ# = t.OBJ# AND c.OBJ# = t.OBJ# '                 ||
7834         'AND c.COL# = t.COL# AND t.INTCOL# = c.INTCOL# '          ||
7835         'AND BITAND(t.FLAGS, 256) = 256 AND o.OWNER# = u.USER# '  ||
7836         'AND o.OWNER# in (SELECT r.schema# FROM SYS.REGISTRY$ r ' ||
7837                'WHERE r.NAMESPACE = ''SERVER'')';
7838    LOOP
7839      FETCH t_cursor INTO t_tabname,t_schema;
7840      EXIT WHEN t_cursor%NOTFOUND;
7841      --
7842      -- Put quotes around the schema and table name
7843      --
7844      t_full_name :=  dbms_assert.enquote_name(t_schema, FALSE) || '.' ||
7845                      dbms_assert.enquote_name(t_tabname,FALSE);
7846     BEGIN
7847        EXECUTE IMMEDIATE 'ALTER TABLE ' || t_full_name
7848                  || ' UPGRADE INCLUDING DATA';
7849        EXCEPTION WHEN OTHERS THEN
7850          t_error  := TRUE;
7851          t_sqltxt := SQLERRM;
7852          t_sqlcode  := SQLCODE;
7853          t_took_error := TRUE;
7854      END;
7855  
7856      IF t_error THEN
7857        IF result_txt != '' THEN
7858          -- If not the first, add a crlf
7859          result_txt := result_txt || crlf;
7860        END IF;
7861  
7862        t_new_err :=
7863              '  Error upgrading: ' || t_full_name || crlf ||
7864              '  Error Text:      ' || t_sqltxt || crlf;
7865  
7866        --
7867        --  length returns NULL (and not zero) for null varchar2's
7868        --
7869        t_len := NVL(length(result_txt), 0);
7870  
7871        IF (t_len + length (t_new_err) <= c_str_max) THEN
7872          --
7873          -- will fit into our buffer
7874          --
7875          result_txt := result_txt || t_new_err;
7876        ELSE
7877          t_new_err := crlf ||
7878             '  *** Too Many Tables ***' || crlf ||
7879             '  *** Cleanup and re-execute to see more tables *** ';
7880          --
7881          -- see if this will fit on the end (should be
7882          -- shorter than the actual error)
7883          --
7884          IF (t_len + length (t_new_err) < c_str_max) THEN
7885            -- Fits
7886            result_txt := result_txt || t_new_err;
7887          ELSE
7888            --
7889            -- Won't fit, cut some off and add the above error
7890            --
7891            result_txt := substr (result_txt, 1, t_len -
7892                                length(t_new_err) - 1);
7893            result_txt := result_txt || t_new_err;
7894          END IF;
7895          -- We are done.
7896          EXIT;   -- Out of the loop
7897        END IF;
7898        t_error := FALSE;  -- Reset error
7899      END IF;
7900    END LOOP;
7901  
7902    IF t_took_error THEN
7903      pSqlcode := t_sqlcode;  -- Return the last failure code
7904      return c_fixup_status_failure;
7905    ELSE
7906      return c_fixup_status_success;
7907    END IF;
7908  END;
7909  
7910  -- *****************************************************************
7911  --     INVALID_USR_TABLEDATA Section
7912  -- *****************************************************************
7913  FUNCTION INVALID_USR_TABLEDATA_check (result_txt OUT VARCHAR2) RETURN number
7914  IS
7915    t_count  NUMBER;
7916    status   NUMBER;
7917  BEGIN
7918    --
7919    -- Exclude tables returned in the _sys_tabledata version
7920    -- by using NOT IN clause
7921    --
7922    BEGIN
7923      EXECUTE IMMEDIATE  'SELECT COUNT(*) '                         ||
7924        'FROM SYS.OBJ$ o, SYS.COL$ c, SYS.COLTYPE$ t, SYS.USER$ u ' ||
7925        'WHERE o.OBJ# = t.OBJ# AND c.OBJ# = t.OBJ# '                ||
7926          'AND c.COL# = t.COL# AND t.INTCOL# = c.INTCOL# '          ||
7927          'AND BITAND(t.FLAGS, 256) = 256 AND o.OWNER# = u.USER# '  ||
7928          'AND o.OWNER# NOT IN '                                    ||
7929             '(SELECT UNIQUE (d.USER_ID) FROM SYS.DBA_USERS d, '    ||
7930               'SYS.REGISTRY$ r WHERE d.USER_ID = r.SCHEMA# '       ||
7931               'AND r.NAMESPACE=''SERVER'')'
7932       INTO t_count;
7933      EXCEPTION
7934        WHEN NO_DATA_FOUND THEN t_count := 0;
7935    END;
7936  
7937    IF (t_count <= 0 and pDBGFailCheck = FALSE)
7938    THEN
7939      -- Nothing to do.
7940      RETURN c_status_success;
7941  
7942    ELSE
7943      IF pOutputType = c_output_xml THEN
7944        result_txt:= genDBUAXMLCheck('INVALID_USR_TABLEDATA',
7945          c_check_level_error,
7946          'Database contains user table data which has not been upgraded. Proceeding'
7947           || ' with an Upgrade of the database before upgrading the table data can lead to'
7948           || ' data loss.',
7949          'Invalid user table data found in database.',
7950          'Use "ALTER TABLE ... UPGRADE INCLUDING DATA prior to upgrade.',
7951           c_dbua_detail_type_text,
7952          'Use "ALTER TABLE ... UPGRADE INCLUDING DATA" prior to upgrade.',
7953          c_dbua_fixup_type_auto,
7954          c_dbua_fixup_stage_validation );
7955      ELSE
7956        result_txt := INVALID_USR_TABLEDATA_gethelp(c_help_overview);
7957      END IF;
7958      IF pOutputtingScripts THEN
7959        genFixup ('INVALID_USR_TABLEDATA');
7960      END IF;
7961     RETURN c_status_failure;
7962     END IF;
7963  END;
7964  
7965  FUNCTION INVALID_USR_TABLEDATA_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
7966  IS
7967  BEGIN
7968    IF HelpType = c_help_overview THEN
7969      return 'ERROR: --> Invalid user table data found in your database.' || crlf
7970             || crlf || '     Invalid data can be seen prior to the database upgrade'
7971             || crlf || '     or during PDB plug in.  This table data must be made'
7972             || crlf || '     valid BEFORE upgrade or plug in.'
7973             || crlf
7974             || crlf || '   - To fix the data, load the Preupgrade package and execute'
7975             || crlf || '     the fixup routine.'
7976             || crlf || '     For plug in, execute the fix up routine in the PDB.'
7977             || crlf
7978             || crlf || '    @?/rdbms/admin/utluppkg.sql'
7979             || crlf || '    SET SERVEROUTPUT ON;'
7980             || crlf || '    exec dbms_preup.run_fixup_and_report(''INVALID_USR_TABLEDATA'');'
7981             || crlf || '    SET SERVEROUTPUT OFF;';
7982    ELSIF HelpType = c_help_fixup THEN
7983      return 'UPGRADE user table data prior to the database upgrade.';
7984    END IF;
7985  END;
7986  --
7987  -- Fixup (Procedure and function)
7988  --
7989  PROCEDURE INVALID_USR_TABLEDATA_fixup
7990  IS
7991    result  VARCHAR2(1000);
7992    status  NUMBER;
7993    tSqlcode NUMBER;
7994  BEGIN
7995    -- Call fixup and throw away the result
7996    status := INVALID_USR_TABLEDATA_fixup (result, tSqlcode);
7997  END;
7998  FUNCTION INVALID_USR_TABLEDATA_fixup (
7999           result_txt IN OUT VARCHAR2,
8000           pSqlcode    IN OUT NUMBER) RETURN number
8001  IS
8002    t_cursor     cursor_t;
8003    t_tabname    sys.obj$.name%TYPE;
8004    t_schema     sys.user$.name%TYPE;
8005    t_full_name  VARCHAR2(256);
8006    t_sqltxt     VARCHAR2(4000);
8007    t_new_err    VARCHAR2(500);
8008    t_error      BOOLEAN := FALSE;
8009    t_took_error BOOLEAN := FALSE;
8010    t_sqlcode    NUMBER;  -- The last sql error we took
8011    t_len        NUMBER;
8012  
8013  BEGIN
8014    result_txt := '';
8015  
8016    OPEN t_cursor FOR 'SELECT DISTINCT (o.NAME), u.NAME '          ||
8017      'FROM SYS.OBJ$ o, SYS.COL$ c, SYS.COLTYPE$ t, SYS.USER$ u '  ||
8018      'WHERE o.OBJ# = t.OBJ# AND c.OBJ# = t.OBJ# '                 ||
8019         'AND c.COL# = t.COL# AND t.INTCOL# = c.INTCOL# '          ||
8020         'AND BITAND(t.FLAGS, 256) = 256 AND o.OWNER# = u.USER# '  ||
8021         'AND o.OWNER# NOT IN (SELECT UNIQUE (d.USER_ID) FROM '    ||
8022           'SYS.DBA_USERS d, SYS.REGISTRY$ r WHERE '                ||
8023             'd.USER_ID = r.SCHEMA# AND r.NAMESPACE=''SERVER'')';
8024    LOOP
8025      FETCH t_cursor INTO t_tabname,t_schema;
8026      EXIT WHEN t_cursor%NOTFOUND;
8027      --
8028      -- Put quotes around the schema and table name
8029      --
8030      t_full_name :=  dbms_assert.enquote_name(t_schema, FALSE) || '.' ||
8031                      dbms_assert.enquote_name(t_tabname,FALSE);
8032      BEGIN
8033        EXECUTE IMMEDIATE 'ALTER TABLE ' || t_full_name
8034                  || ' UPGRADE INCLUDING DATA';
8035        EXCEPTION WHEN OTHERS THEN
8036          t_error  := TRUE;
8037          t_sqltxt := SQLERRM;
8038          t_sqlcode  := SQLCODE;
8039          t_took_error := TRUE;
8040      END;
8041  
8042      IF t_error THEN
8043        IF result_txt != '' THEN
8044          -- If not the first, add a crlf
8045          result_txt := result_txt || crlf;
8046        END IF;
8047  
8048        t_new_err :=
8049              '  Error upgrading: ' || t_full_name || crlf ||
8050              '  Error Text:      ' || t_sqltxt || crlf;
8051  
8052        --
8053        --  length returns NULL (and not zero) for null varchar2's
8054        --
8055        t_len := NVL(length(result_txt), 0);
8056  
8057        IF (t_len + length (t_new_err) <= c_str_max) THEN
8058          --
8059          -- will fit into our buffer
8060          --
8061          result_txt := result_txt || t_new_err;
8062        ELSE
8063          t_new_err := crlf ||
8064             '  *** Too Many Tables ***' || crlf ||
8065             '  *** Cleanup and re-execute to see more tables *** ';
8066          --
8067          -- see if this will fit on the end (should be
8068          -- shorter than the actual error)
8069          --
8070          IF (t_len + length (t_new_err) < c_str_max) THEN
8071            -- Fits
8072            result_txt := result_txt || t_new_err;
8073          ELSE
8074            --
8075            -- Won't fit, cut some off and add the above error
8076            --
8077            result_txt := substr (result_txt, 1, t_len -
8078                                      length(t_new_err));
8079            result_txt := result_txt || t_new_err;
8080          END IF;
8081          -- We are done.
8082          EXIT;   -- Out of the loop
8083        END IF;
8084        t_error := FALSE;  -- Reset error
8085      END IF;
8086    END LOOP;
8087  
8088    IF t_took_error THEN
8089      pSqlcode := t_sqlcode;  -- Return the last failure code
8090      return c_fixup_status_failure;
8091    ELSE
8092      return c_fixup_status_success;
8093    END IF;
8094  END;
8095  
8096  
8097  -- *****************************************************************
8098  --     job_queue_process Section
8099  -- *****************************************************************
8100  FUNCTION job_queue_process_check (result_txt OUT VARCHAR2) RETURN number
8101  IS
8102    p_count  NUMBER := -1;
8103    status   NUMBER;
8104    idx      NUMBER;
8105    p_lowest NUMBER;
8106    edetails VARCHAR2(500);
8107  
8108  BEGIN
8109    BEGIN
8110      EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE
8111            name=''job_queue_processes'''
8112      INTO p_count;
8113    EXCEPTION WHEN NO_DATA_FOUND THEN NULL;
8114    END;
8115  
8116    p_lowest := db_cpus * db_cpu_threads;
8117  
8118    --
8119    -- If we failed to grab the count (not set),
8120    -- or the count is > the number of cpu*threads then
8121    -- there is no error
8122    --
8123    IF ( (p_count = -1) OR (p_count > p_lowest)
8124      AND pDBGFailCheck = FALSE) THEN
8125      RETURN c_status_success;
8126    END IF;
8127    --
8128    -- Find the index of this routine in the check_array
8129    --
8130    idx := check_names('JOB_QUEUE_PROCESS').idx;
8131  
8132    IF (p_count = 0) THEN
8133      check_table(idx).level := c_check_level_error;
8134      edetails := 'JOB_QUEUE_PROCESSES is set at zero which will cause both '
8135          || 'DBMS_SCHEDULER and DBMS_JOB jobs to not run.';
8136    ELSE
8137      --
8138      -- We know at this point the count is under db_cpus * db_cpu_threads
8139      -- (or debug is on)
8140      --
8141      check_table(idx).level := c_check_level_warning;
8142      edetails := 'JOB_QUEUE_PROCESSES is set at ' || p_count || ' which may cause '
8143          || 'the upgrade to take significantly longer to complete.';
8144    END IF;
8145  
8146    IF pOutputType = c_output_xml THEN
8147        result_txt:= genDBUAXMLCheck('JOB_QUEUE_PROCESS',
8148          check_table(idx).level,
8149          'JOB_QUEUE_PROCESSES value must be updated.',
8150          edetails,
8151          'Either remove setting of JOB_QUEUE_PROCESSES value ' ||
8152          'or set it to a value greater than ' || to_char(p_lowest) ||
8153          '.',
8154          c_dbua_detail_type_text,
8155          'Either remove setting of JOB_QUEUE_PROCESSES value ' ||
8156          'or set it to a value greater than ' || to_char(p_lowest) ||
8157          '.',
8158          c_dbua_fixup_type_manual,
8159          c_dbua_fixup_stage_pre );
8160    ELSE
8161      result_txt := JOB_QUEUE_PROCESS_gethelp(c_help_overview);
8162    END IF;
8163    IF pOutputtingScripts THEN
8164      genFixup ('JOB_QUEUE_PROCESS');
8165    END IF;
8166    RETURN c_status_failure;
8167  END job_queue_process_check;
8168  
8169  FUNCTION job_queue_process_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8170  IS
8171    p_count     NUMBER := -1;
8172    error_level NUMBER;
8173    status      NUMBER;
8174    result_txt  VARCHAR2(1500);
8175  
8176  BEGIN
8177    IF HelpType = c_help_overview THEN
8178      BEGIN
8179        EXECUTE IMMEDIATE 'SELECT value FROM v$parameter WHERE
8180              name=''job_queue_processes'''
8181        INTO p_count;
8182      EXCEPTION WHEN NO_DATA_FOUND THEN NULL;
8183      END;
8184      --
8185      -- Note:  We are going to assume the caller knows there is
8186      -- an issue, so if the count is non-zero, its going to be below
8187      -- cpu*threads which is a warning.
8188      --
8189      IF p_count = 0 THEN
8190        result_txt := 'ERROR: --> job_queue_processes set to zero' || crlf
8191          || crlf || '     Starting with Oracle Database 11g Release 2 (11.2), setting'
8192          || crlf || '     JOB_QUEUE_PROCESSES to 0 causes both DBMS_SCHEDULER and'
8193          || crlf || '     DBMS_JOB jobs to not run. Previously, setting JOB_QUEUE_PROCESSES'
8194          || crlf || '     to 0 caused DBMS_JOB jobs to not run, but DBMS_SCHEDULER jobs were'
8195          || crlf || '     unaffected and would still run.';
8196      ELSE
8197        result_txt := 'WARNING: --> job_queue_processes set too low' || crlf;
8198      END IF;
8199      -- Now add the rest
8200      result_txt := result_txt
8201        || crlf || '     This parameter must be removed or updated to a value greater'
8202        || crlf || '     than ' || to_char(db_cpus*db_cpu_threads)
8203                || ' (default value if not defined is 1000) prior to upgrade.'
8204        || crlf || '     Not doing so will affect the running of utlrp.sql after the upgrade'
8205        || crlf || crlf || '     Update your init.ora or spfile to make this change.';
8206    ELSIF HelpType = c_help_fixup THEN
8207      result_txt := 'Review and increase or remove the setting of job_queue_processes';
8208    END IF;
8209    RETURN result_txt;
8210  END job_queue_process_gethelp;
8211  --
8212  -- Fixup (Procedure and function)
8213  --
8214  PROCEDURE job_queue_process_fixup
8215  IS
8216    result  VARCHAR2(1000);
8217    status  NUMBER;
8218    tSqlcode NUMBER;
8219  BEGIN
8220    -- Call fixup and throw away the result
8221    status := job_queue_process_fixup (result, tSqlcode);
8222  END job_queue_process_fixup;
8223  
8224  FUNCTION job_queue_process_fixup (
8225           result_txt IN OUT VARCHAR2,
8226           pSqlcode    IN OUT NUMBER) RETURN number
8227  IS
8228  BEGIN
8229     result_txt := job_queue_process_gethelp(c_help_overview);
8230     return c_fixup_status_info;
8231  END job_queue_process_fixup;
8232  
8233  -- *****************************************************************
8234  --     NACL_OBJECTS_EXIST Section
8235  -- *****************************************************************
8236  FUNCTION nacl_objects_exist_check (result_txt OUT VARCHAR2) RETURN number
8237  IS
8238    t_null      CHAR(1);
8239    status      NUMBER := 0;
8240  BEGIN
8241  
8242    IF (db_n_version NOT IN (102) AND pDBGFailCheck = FALSE) THEN
8243      -- Only valid for 10.2 upgrades
8244      return c_status_not_for_this_version;
8245    END IF;
8246  
8247    BEGIN
8248      EXECUTE IMMEDIATE 'SELECT NULL FROM sys.user$ WHERE name=''DMSYS'''
8249        INTO t_null;
8250      status := 1;
8251      EXCEPTION
8252         WHEN NO_DATA_FOUND THEN NULL;
8253    END;
8254  
8255    IF (status = 0 AND pDBGFailCheck = FALSE)
8256    THEN
8257      RETURN c_status_passed;
8258    END IF;
8259  
8260    IF pOutputType = c_output_xml THEN
8261      result_txt:= genDBUAXMLCheck('NACL_OBJECTS_EXIST',
8262        c_check_level_warning,
8263        'Database contains schemas with objects dependent on network packages.',
8264        'Database contains schemas with objects dependent on network packages.',
8265        'Refer to the 11g Upgrade Guide for instructions to configure Network ACLs',
8266        c_dbua_detail_type_text,
8267        'Refer to the 11g Upgrade Guide for instructions on how to re-configure Network ACLs.',
8268         c_dbua_fixup_type_manual,
8269         c_dbua_fixup_stage_pre );
8270    ELSE
8271      result_txt := nacl_objects_exist_gethelp(c_help_overview);
8272    END IF;
8273    IF pOutputtingScripts THEN
8274      genFixup ('NACL_OBJECTS_EXIST');
8275    END IF;
8276    RETURN c_status_failure;
8277  END nacl_objects_exist_check;
8278  
8279  FUNCTION nacl_objects_exist_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8280  IS
8281    owner       VARCHAR2(128);
8282    tstr        VARCHAR2(1000); -- Because of loop issues, use temp str
8283    tmp_cursor  cursor_t;
8284    result_txt  VARCHAR2(1500);
8285  BEGIN
8286    IF HelpType = c_help_overview THEN
8287      result_txt := 'WARNING: --> Existing schemas with network ACLs exist' || crlf
8288         || crlf || '     Database contains schemas with objects dependent on network packages.'
8289         || crlf || '     Refer to the Upgrade Guide for instructions to configure Network ACLs.';
8290  
8291      tstr := '';
8292      OPEN tmp_cursor FOR
8293        'SELECT DISTINCT owner FROM DBA_DEPENDENCIES'
8294            || ' WHERE referenced_name IN'
8295            || ' (''UTL_TCP'',''UTL_SMTP'',''UTL_MAIL'',''UTL_HTTP'',''UTL_INADDR'')'
8296            || ' AND owner NOT IN (''SYS'',''PUBLIC'',''ORDPLUGINS'')';
8297      LOOP
8298        FETCH tmp_cursor INTO owner;
8299        EXIT WHEN tmp_cursor%NOTFOUND;
8300        tstr := tstr
8301          || crlf || '     USER ' || owner || ' has dependent objects.';
8302      END LOOP;
8303      CLOSE tmp_cursor;
8304      IF (tstr IS NOT NULL OR tstr != '' ) THEN
8305        result_txt := result_txt || tstr;
8306      END IF;
8307  
8308      tstr := '';
8309      OPEN tmp_cursor FOR
8310         'SELECT DISTINCT owner FROM all_tab_columns'
8311            || ' WHERE data_type IN'
8312            || ' (''ORDIMAGE'', ''ORDAUDIO'', ''ORDVIDEO'', ''ORDDOC'','
8313            || '  ''ORDSOURCE'', ''ORDDICOM'') AND'
8314            || '    (data_type_owner = ''ORDSYS'' OR'
8315            || '       data_type_owner = owner) AND'
8316            || '         (owner != ''PM'')';
8317      LOOP
8318        FETCH tmp_cursor INTO owner;
8319        EXIT WHEN tmp_cursor%NOTFOUND;
8320        tstr := tstr
8321           || crlf || '     USER ' || owner || ' uses interMedia and may have dependent objects.';
8322      END LOOP;
8323      CLOSE tmp_cursor;
8324      IF (tstr IS NOT NULL OR tstr != '' ) THEN
8325        result_txt := result_txt || tstr;
8326      END IF;
8327    ELSIF HelpType = c_help_fixup THEN
8328      result_txt := 'Objects with network acls are displayed and need to be reviewed.';
8329    END IF;
8330    RETURN result_txt;
8331  END nacl_objects_exist_gethelp;
8332  --
8333  -- Fixup (Procedure and function)
8334  --
8335  PROCEDURE nacl_objects_exist_fixup
8336  IS
8337    result  VARCHAR2(1500);
8338    status  NUMBER;
8339    tSqlcode NUMBER;
8340  BEGIN
8341    -- Call fixup and throw away the result
8342    status := nacl_objects_exist_fixup (result, tSqlcode);
8343  END nacl_objects_exist_fixup;
8344  
8345  FUNCTION nacl_objects_exist_fixup (
8346           result_txt IN OUT VARCHAR2,
8347           pSqlcode    IN OUT NUMBER) RETURN number
8348  IS
8349  BEGIN
8350    -- Dump out the same thing we give for help
8351    result_txt := nacl_objects_exist_gethelp(c_help_overview);
8352    return c_fixup_status_info;
8353  END nacl_objects_exist_fixup;
8354  
8355  -- *****************************************************************
8356  --     NEW_TIME_ZONES_EXIST Section
8357  -- *****************************************************************
8358  FUNCTION NEW_TIME_ZONES_EXIST_check (result_txt OUT VARCHAR2) RETURN number
8359  IS
8360    status NUMBER;
8361  BEGIN
8362    IF db_tz_version <= c_tz_version AND pDBGFailCheck = FALSE
8363    THEN
8364      RETURN c_status_success; -- success
8365    ELSE
8366      IF pOutputType = c_output_xml THEN
8367        result_txt:= genDBUAXMLCheck('NEW_TIME_ZONES_EXIST',
8368          c_check_level_error,
8369          'Your database contains a time zone file newer than that of the new Oracle software.',
8370          'Your database contains a time zone file newer than that of the new Oracle software.',
8371          'Patch new oracle home with time zone file equivilant to existing Oracle database.',
8372           c_dbua_detail_type_text,
8373          'SELECT version from v$timezone_file',
8374          c_dbua_fixup_type_manual,
8375          c_dbua_fixup_stage_pre );
8376      ELSE
8377        result_txt := NEW_TIME_ZONES_EXIST_gethelp(c_help_overview);
8378      END IF;
8379      IF pOutputtingScripts THEN
8380        genFixup ('NEW_TIME_ZONES_EXIST');
8381      END IF;
8382      RETURN c_status_failure;
8383     END IF;
8384  END NEW_TIME_ZONES_EXIST_check;
8385  
8386  FUNCTION NEW_TIME_ZONES_EXIST_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8387  IS
8388  BEGIN
8389    IF HelpType = c_help_overview THEN
8390      return 'ERROR: --> New Timezone File in use' || crlf
8391         || crlf || '     Database is using a time zone file newer than version '
8392                         || c_tz_version  || '.'
8393         || crlf || '     BEFORE upgrading the database, patch the new '
8394         || crlf || '     ORACLE_HOME/oracore/zoneinfo/ with a time zone data file of the'
8395         || crlf || '     same version as the one used in the ' || db_version
8396         || ' release database.';
8397    ELSIF HelpType = c_help_fixup THEN
8398      return 'Time zone data file must be updated in the new ORACLE_HOME.';
8399    END IF;
8400  END NEW_TIME_ZONES_EXIST_gethelp;
8401  --
8402  -- Fixup (Procedure and function)
8403  --
8404  PROCEDURE NEW_TIME_ZONES_EXIST_fixup
8405  IS
8406    result  VARCHAR2(1000);
8407    status  NUMBER;
8408    tSqlcode NUMBER;
8409  BEGIN
8410    -- Call fixup and throw away the result
8411    status := NEW_TIME_ZONES_EXIST_fixup (result, tSqlcode);
8412  END NEW_TIME_ZONES_EXIST_fixup;
8413  
8414  FUNCTION NEW_TIME_ZONES_EXIST_fixup (
8415           result_txt IN OUT VARCHAR2,
8416           pSqlcode    IN OUT NUMBER) RETURN number
8417  IS
8418  BEGIN
8419    -- Dump out the same thing we give for help
8420    result_txt := NEW_TIME_ZONES_EXIST_gethelp(c_help_overview);
8421    return c_fixup_status_info;
8422  END NEW_TIME_ZONES_EXIST_fixup;
8423  -- *****************************************************************
8424  --     OCM_USER_PRESENT Section
8425  -- *****************************************************************
8426  FUNCTION OCM_USER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
8427  IS
8428    user_exists BOOLEAN;
8429    tmp_num1    NUMBER;
8430    status      NUMBER;
8431    t_null      CHAR(1);
8432  BEGIN
8433  
8434    IF (db_n_version NOT IN (102) AND pDBGFailCheck = FALSE) THEN
8435      return c_status_not_for_this_version;
8436    END IF;
8437  
8438    user_exists := TRUE;
8439    BEGIN
8440      EXECUTE IMMEDIATE
8441       'SELECT user# from SYS.USER$ WHERE name=''ORACLE_OCM'''
8442       INTO tmp_num1;
8443      EXCEPTION WHEN NO_DATA_FOUND then user_exists := FALSE;
8444    END;
8445  
8446    IF user_exists THEN
8447      BEGIN
8448        EXECUTE IMMEDIATE
8449         'SELECT NULL FROM sys.obj$ WHERE owner# = (SELECT user# from SYS.USER$
8450             WHERE name=''ORACLE_OCM'') AND
8451               name =''MGMT_DB_LL_METRICS'' AND  type# = 9'
8452          INTO t_null;
8453        EXCEPTION
8454          WHEN NO_DATA_FOUND then user_exists := TRUE;
8455      END;
8456    END IF;
8457  
8458    IF user_exists = FALSE AND pDBGFailCheck = FALSE
8459    THEN
8460      RETURN c_status_success;   -- No user, not debug
8461    ELSE
8462      IF pOutputType = c_output_xml THEN
8463        result_txt:= genDBUAXMLCheck('OCM_USER_PRESENT',
8464          c_check_level_warning,
8465          'User OCM present in database',
8466          'User OCM present in database',
8467          'Remove OCM user from the database prior to Upgrade',
8468           c_dbua_detail_type_text,
8469          'The OCM internal account is present in your database'
8470            || ' and should be dropped prior to upgrading',
8471          c_dbua_fixup_type_auto,
8472          c_dbua_fixup_stage_pre);
8473      ELSE
8474        result_txt := ocm_user_present_gethelp(c_help_overview);
8475      END IF;
8476      IF pOutputtingScripts THEN
8477        genFixup ('OCM_USER_PRESENT');
8478      END IF;
8479      RETURN c_status_failure;
8480     END IF;
8481  END OCM_USER_PRESENT_check;
8482  
8483  FUNCTION OCM_USER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8484  IS
8485  BEGIN
8486    IF HelpType = c_help_overview THEN
8487      return 'WARNING: --> "ORACLE_OCM" user found in database' || crlf
8488       || crlf || '     This is an internal account used by Oracle Configuration Manager. '
8489       || crlf || '     Please drop this user prior to upgrading.';
8490    ELSIF HelpType = c_help_fixup THEN
8491      return 'Drop the ORACLE_OCM user.';
8492    END IF;
8493  END OCM_USER_PRESENT_gethelp;
8494  --
8495  -- Fixup (Procedure and function)
8496  --
8497  PROCEDURE OCM_USER_PRESENT_fixup
8498  IS
8499    result  VARCHAR2(1000);
8500    status  NUMBER;
8501    tSqlcode NUMBER;
8502  BEGIN
8503    -- Call fixup and throw away the result
8504    status := OCM_USER_PRESENT_fixup (result, tSqlcode);
8505  END OCM_USER_PRESENT_fixup;
8506  
8507  FUNCTION OCM_USER_PRESENT_fixup (
8508           result_txt IN OUT VARCHAR2,
8509           pSqlcode    IN OUT NUMBER) RETURN number
8510  IS
8511  BEGIN
8512     return execute_sql_statement ('DROP USER ORACLE_OCM CASCADE', result_txt, pSqlcode);
8513  END OCM_USER_PRESENT_fixup;
8514  
8515  -- *****************************************************************
8516  --     OLD_TIME_ZONES_EXISTS Section
8517  -- *****************************************************************
8518  FUNCTION old_time_zones_exist_check (result_txt OUT VARCHAR2) RETURN number
8519  IS
8520    status  NUMBER;
8521  BEGIN
8522    --
8523    -- Do we have a valid time zone for an upgrade
8524    --
8525    IF db_tz_version < c_tz_version OR pDBGFailCheck THEN
8526      IF pOutputType = c_output_xml THEN
8527        result_txt:= genDBUAXMLCheck('OLD_TIME_ZONES_EXIST',
8528          c_check_level_warning,
8529          'Database is using a time zone file older than shipped with the new Oracle Software',
8530          'Your time zone file must be updated, this can be done after the Upgrade is executed.',
8531          'Execute the dbms_dst package after your database is upgraded.',
8532          c_dbua_detail_type_text,
8533          'Execute the dbms_dst package after your database is upgraded.',
8534          c_dbua_fixup_type_auto,
8535          c_dbua_fixup_stage_pre);
8536      ELSE
8537        result_txt := old_time_zones_exist_gethelp(c_help_overview);
8538      END IF;
8539      IF pOutputtingScripts THEN
8540        genFixup ('OLD_TIME_ZONES_EXIST');
8541      END IF;
8542      RETURN c_status_failure;
8543    END IF;
8544    RETURN c_status_success;
8545  END old_time_zones_exist_check ;
8546  
8547  FUNCTION old_time_zones_exist_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8548  IS
8549  BEGIN
8550    IF HelpType = c_help_overview THEN
8551      return 'INFORMATION: --> Older Timezone in use' || crlf
8552        || crlf || '     Database is using a time zone file older than version '
8553                         || c_tz_version || '.'
8554        || crlf || '     After the upgrade, it is recommended that DBMS_DST package'
8555        || crlf || '     be used to upgrade the ' || db_version || ' database time zone version'
8556        || crlf || '     to the latest version which comes with the new release.'
8557        || crlf || '     Please refer to My Oracle Support note number 977512.1 for details.';
8558    ELSIF HelpType = c_help_fixup THEN
8559      return 'Update the timezone using the DBMS_DST package after upgrade is complete.';
8560    END IF;
8561  END old_time_zones_exist_gethelp;
8562  --
8563  PROCEDURE old_time_zones_exist_fixup
8564  IS
8565    result   VARCHAR2(1000);
8566    status   NUMBER;
8567    tSqlcode  NUMBER;
8568  BEGIN
8569    -- Call fixup and throw away the result
8570    status := old_time_zones_exist_fixup (result, tSqlcode);
8571  END old_time_zones_exist_fixup;
8572  
8573  FUNCTION old_time_zones_exist_fixup (
8574           result_txt IN OUT VARCHAR2,
8575           pSqlcode    IN OUT NUMBER) RETURN number
8576  IS
8577  BEGIN
8578     result_txt := old_time_zones_exist_gethelp(c_help_overview);
8579     pSqlcode := 0;
8580     return c_fixup_status_info;
8581  END old_time_zones_exist_fixup;
8582  -- *****************************************************************
8583  --     ols_sys_move Section
8584  -- *****************************************************************
8585  FUNCTION ols_sys_move_check (result_txt OUT VARCHAR2) RETURN number
8586  IS
8587    usernum          INTEGER := 0;
8588    preaud_cnt       INTEGER := 0;
8589    status           NUMBER;
8590    condition_exists BOOLEAN := FALSE;
8591  BEGIN
8592    BEGIN
8593      EXECUTE IMMEDIATE 'SELECT user# FROM sys.user$ WHERE name=''LBACSYS'''
8594         INTO usernum;
8595      EXCEPTION WHEN OTHERS THEN NULL;
8596    END;
8597  
8598    IF (usernum != 0) THEN
8599      BEGIN
8600        --
8601        -- This check means the ols script has not been executed
8602        --
8603        EXECUTE IMMEDIATE 'SELECT count(*) FROM dba_tables where OWNER=''SYS'' AND table_name=''PREUPG_AUD$'''
8604          into preaud_cnt;
8605        IF preaud_cnt = 0 THEN
8606          condition_exists := TRUE;
8607        END IF;
8608      END;
8609    END IF;
8610  
8611    IF (condition_exists = FALSE AND
8612        pDBGFailCheck = FALSE) THEN
8613      RETURN c_status_success;
8614    END IF;
8615  
8616    IF pOutputType = c_output_xml THEN
8617      result_txt:= genDBUAXMLCheck('OLS_SYS_MOVE',
8618        c_check_level_error,
8619        'olspreupgrade.sql has not been executed on this database',
8620        'Oracle requires that olspreupgrade.sql be executed to move audit records into the correct table.',
8621        'The script rdbms/admin/olspreupgrade.sql must be executed to move records over prior to the upgrade.',
8622        c_dbua_detail_type_text,
8623        'To view the number of records that will be moved use the command: SELECT count(*) from system.aud$',
8624        c_dbua_fixup_type_manual,
8625        c_dbua_fixup_stage_pre);
8626    ELSE
8627      result_txt := ols_sys_move_gethelp (c_help_overview);
8628    END IF;
8629    IF pOutputtingScripts THEN
8630      genFixup ('OLS_SYS_MOVE');
8631    END IF;
8632    RETURN c_status_failure;
8633  END ols_sys_move_check;
8634  
8635  FUNCTION ols_sys_move_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8636  IS
8637    aud_rowcnt  INTEGER := -1;
8638    result_txt  VARCHAR2(1500);
8639  BEGIN
8640    IF HelpType = c_help_overview THEN
8641      BEGIN
8642        EXECUTE IMMEDIATE 'SELECT count(*) FROM SYSTEM.aud$'
8643          INTO aud_rowcnt;
8644        EXCEPTION
8645          WHEN OTHERS THEN NULL;
8646      END;
8647  
8648      --
8649      -- In debug mode we want both messages to come out.
8650      --
8651      IF aud_rowcnt = -1 OR pDBGFailCheck = TRUE THEN
8652        result_txt := 'ERROR: --> SYSTEM.AUD$ (audit records) Move'
8653          || crlf || crlf || '    An error occured retrieving a count from SYSTEM.AUD$'
8654          || crlf ||         '    This can happen when the table has already been cleaned up.'
8655          || crlf ||         '    The olspreupgrade.sql script should be re-executed.';
8656      END IF;
8657  
8658      IF aud_rowcnt != -1 OR pDBGFailCheck = TRUE THEN
8659        result_txt := 'ERROR: --> SYSTEM.AUD$ (audit records) Move'
8660          || crlf || crlf || '     Oracle requires that records in the audit table SYSTEM.AUD$ be moved'
8661          || crlf ||         '     to SYS.AUD$ prior to upgrading..'
8662          || crlf || crlf || '     The Database has ' || aud_rowcnt || ' rows in SYSTEM.AUD$ which'
8663          || crlf ||         '     will be moved during the upgrade.'
8664          || crlf || crlf || '     The downtime during the upgrade will be affected if there are a'
8665          || crlf ||         '     large number of rows to be moved.'
8666          || crlf || crlf || '     The audit data can be moved manually prior to the upgrade by using'
8667          || crlf ||         '     the script: rdbms/admin/olspreupgrade.sql which is part of the'
8668          || crlf ||         '     Oracle Database 12c software.'
8669          || crlf ||         '     Please refer to the Label Security Administrator guide or'
8670          || crlf ||         '     the Database Upgrade guide.';
8671      END IF;
8672    ELSIF HelpType = c_help_fixup THEN
8673      result_txt := 'Execute olspreupgrade.sql script prior to upgrade.';
8674    END IF;
8675    RETURN result_txt;
8676  END ols_sys_move_gethelp;
8677  --
8678  -- Fixup (Procedure and function)
8679  --
8680  PROCEDURE ols_sys_move_fixup
8681  IS
8682    result  VARCHAR2(1000);
8683    status  NUMBER;
8684    tSqlcode NUMBER;
8685  BEGIN
8686    -- Call fixup and throw away the result
8687    status := ols_sys_move_fixup (result, tSqlcode);
8688  END ols_sys_move_fixup;
8689  
8690  FUNCTION ols_sys_move_fixup (
8691           result_txt IN OUT VARCHAR2,
8692           pSqlcode    IN OUT NUMBER) RETURN number
8693  IS
8694  BEGIN
8695     result_txt := ols_sys_move_gethelp(c_help_overview);
8696     return c_fixup_status_info;
8697  END ols_sys_move_fixup;
8698  
8699  -- *****************************************************************
8700  --     ORDIMAGEINDEX Section
8701  -- *****************************************************************
8702  FUNCTION ORDIMAGEINDEX_check (result_txt OUT VARCHAR2) RETURN number
8703  IS
8704    t_count NUMBER := 0;
8705    status  NUMBER;
8706  BEGIN
8707    --
8708    -- The upgrade will remove them, so the misc warning section will
8709    -- let them know.
8710    --
8711    BEGIN
8712      EXECUTE IMMEDIATE
8713       'SELECT COUNT(*) FROM sys.dba_indexes WHERE index_type = ''DOMAIN''
8714           and ityp_name = ''ORDIMAGEINDEX'''
8715     INTO t_count;
8716    EXCEPTION
8717       WHEN OTHERS THEN NULL;
8718    END;
8719  
8720    IF (t_count = 0 AND pDBGFailCheck = FALSE) THEN
8721      RETURN c_status_success;
8722    ELSE
8723      IF pOutputType = c_output_xml THEN
8724        result_txt:= genDBUAXMLCheck('ORDIMAGEINDEX',
8725          c_check_level_info,
8726          'Ordsys.OrdImageIndex is in use.  These images are dropped as part of the upgrade',
8727          'Ordsys.OrdImageIndex is in use',
8728          'Images are cleaned up as part of the upgrade process.',
8729          c_dbua_detail_type_sql,
8730          htmlentities('SELECT COUNT(*) FROM sys.dba_indexes WHERE index_type'
8731            || ' = ''DOMAIN'' and ityp_name = ''ORDIMAGEINDEX'''),
8732          c_dbua_fixup_type_auto,
8733          c_dbua_fixup_stage_pre );
8734      ELSE
8735        result_txt := ORDIMAGEINDEX_gethelp(c_help_overview);
8736      END IF;
8737      IF pOutputtingScripts THEN
8738        genFixup ('ORDIMAGEINDEX');
8739      END IF;
8740      RETURN c_status_failure;
8741     END IF;
8742  END ORDIMAGEINDEX_check;
8743  
8744  FUNCTION ORDIMAGEINDEX_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8745  IS
8746    tmp_cursor   cursor_t;
8747    tmp_varchar1 VARCHAR2(512);
8748    tmp_varchar2 VARCHAR2(512);
8749    tstr         VARCHAR2(1000);
8750    result_txt   VARCHAR2(1500);
8751  BEGIN
8752    IF HelpType = c_help_overview THEN
8753      result_txt := 'INFORMATION: --> ORDSYS.OrdImageIndex in use' || crlf
8754        || crlf || '     The previously desupported Oracle Multimedia image domain index,'
8755        || crlf || '     ORDSYS.OrdImageIndex, is no longer supported and has been removed in '
8756        || crlf || '     Oracle Database 11g Release 2 (11.2). '
8757        || crlf || '     Following is the list of affected indexes that are dropped'
8758        || crlf || '     during the upgrade.';
8759      OPEN tmp_cursor FOR
8760         'SELECT dbai.index_name, dbai.owner FROM SYS.DBA_INDEXES dbai
8761            WHERE dbai.index_type = ''DOMAIN'' AND
8762              dbai.ityp_name  = ''ORDIMAGEINDEX''
8763           ORDER BY dbai.owner';
8764      tstr := '';
8765      LOOP
8766        FETCH tmp_cursor INTO tmp_varchar1, tmp_varchar2;
8767        EXIT WHEN tmp_cursor%NOTFOUND;
8768        tstr := tstr || crlf || '     USER: ' || RPAD(tmp_varchar2, 32) ||
8769                       ' Index: ' || RPAD(tmp_varchar1,32);
8770      END LOOP;
8771      CLOSE tmp_cursor;
8772      IF (tstr IS NOT NULL OR tstr != '' ) THEN
8773        result_txt := result_txt || tstr;
8774      END IF;
8775    ELSIF HelpType = c_help_fixup THEN
8776      result_txt := 'Cleanup of ordimageIndexes is performed during the upgrade';
8777    END IF;
8778    RETURN result_txt;
8779  END ORDIMAGEINDEX_gethelp;
8780  --
8781  -- Fixup (Procedure and function)
8782  --
8783  PROCEDURE ORDIMAGEINDEX_fixup
8784  IS
8785    result  VARCHAR2(1000);
8786    status  NUMBER;
8787    tSqlcode NUMBER;
8788  BEGIN
8789    -- Call fixup and throw away the result
8790    status := ORDIMAGEINDEX_fixup (result, tSqlcode);
8791  END ORDIMAGEINDEX_fixup;
8792  
8793  FUNCTION ORDIMAGEINDEX_fixup (
8794           result_txt IN OUT VARCHAR2,
8795           pSqlcode    IN OUT NUMBER) RETURN number
8796  IS
8797  BEGIN
8798     result_txt :=
8799       'OrdimageIndexes are cleaned up as part of the upgrade';
8800     pSqlcode := 1;
8801     return c_fixup_status_info;
8802  END ORDIMAGEINDEX_fixup;
8803  -- *****************************************************************
8804  --     2PC_TXN_EXIST Section
8805  -- *****************************************************************
8806  FUNCTION PENDING_2PC_TXN_check (result_txt OUT VARCHAR2) RETURN number
8807  IS
8808    t_null      CHAR(1);
8809    status      NUMBER;
8810  BEGIN
8811  
8812    BEGIN
8813      EXECUTE IMMEDIATE 'SELECT NULL FROM sys.dba_2pc_pending WHERE rownum <=1'
8814      INTO t_null;
8815        status := 1;
8816    EXCEPTION
8817      WHEN NO_DATA_FOUND THEN status := 0;
8818    END;
8819  
8820    IF (status = 0 AND pDBGFailCheck = FALSE)
8821    THEN
8822      RETURN c_status_success;
8823    ELSE
8824      IF pOutputType = c_output_xml THEN
8825        result_txt:= genDBUAXMLCheck('2PC_TXN_EXIST',
8826          c_check_level_warning,
8827          'There are outstanding unresolved distributed transactions. Resolve outstanding distributed transactions prior to upgrade.',
8828          'Resolve outstanding distributed transactions prior to upgrade.',
8829          'Resolve outstanding distributed transactions prior to upgrade.',
8830           c_dbua_detail_type_sql,
8831          htmlentities('SELECT count(*) FROM sys.dba_2pc_pending WHERE rownum <=1'),
8832          c_dbua_fixup_type_manual,
8833          c_dbua_fixup_stage_pre);
8834      ELSE
8835        result_txt := PENDING_2PC_TXN_gethelp(c_help_overview);
8836      END IF;
8837      IF pOutputtingScripts THEN
8838        genFixup ('2PC_TXN_EXIST');
8839      END IF;
8840      RETURN c_status_failure;
8841     END IF;
8842  END PENDING_2PC_TXN_check;
8843  
8844  FUNCTION PENDING_2PC_TXN_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8845  IS
8846  BEGIN
8847    IF HelpType = c_help_overview THEN
8848      return 'ERROR: --> Unresolved distributed transactions' || crlf
8849        || crlf || '     There are outstanding unresolved distributed transactions.'
8850        || crlf || '     Resolve all outstanding distributed transactions prior to upgrade.';
8851    ELSIF HelpType = c_help_fixup THEN
8852      return 'Distributed transactions must be resolved prior to upgrade.';
8853    END IF;
8854  END PENDING_2PC_TXN_gethelp;
8855  --
8856  -- Fixup (Procedure and function)
8857  --
8858  PROCEDURE PENDING_2PC_TXN_fixup
8859  IS
8860    result  VARCHAR2(1000);
8861    status  NUMBER;
8862    tSqlcode NUMBER;
8863  BEGIN
8864    -- Call fixup and throw away the result
8865    status := PENDING_2PC_TXN_fixup (result, tSqlcode);
8866  END PENDING_2PC_TXN_fixup;
8867  
8868  FUNCTION PENDING_2PC_TXN_fixup (
8869           result_txt IN OUT VARCHAR2,
8870           pSqlcode    IN OUT NUMBER) RETURN number
8871  IS
8872  BEGIN
8873    -- Dump out the same thing we give for help
8874    result_txt := PENDING_2PC_TXN_gethelp(c_help_overview);
8875    return c_fixup_status_info;
8876  END PENDING_2PC_TXN_fixup;
8877  
8878  -- *****************************************************************
8879  --     Recycle Bin Section
8880  -- *****************************************************************
8881  FUNCTION purge_recyclebin_check (result_txt OUT VARCHAR2) RETURN number
8882  IS
8883    obj_count NUMBER;
8884  BEGIN
8885     EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM sys.recyclebin$'
8886       INTO obj_count;
8887    IF (obj_count > 0 OR pDBGFailCheck)
8888    THEN
8889  
8890      IF (pDBGFailCheck AND obj_count = 0) THEN
8891        obj_count := 10;  -- Give it some non-zero number
8892      END IF;
8893  
8894      IF pOutputType = c_output_xml THEN
8895        result_txt:= genDBUAXMLCheck('PURGE_RECYCLEBIN', c_check_level_error,
8896          'Recycle Bin is not empty',
8897          'Recycle bin is not empty',
8898          'BEGIN dbms_preup.purge_recyclebin_fixup; END;',
8899          c_dbua_detail_type_sql,
8900          'select count(*) from sys.recyclebin$',
8901          c_dbua_fixup_type_auto,
8902          c_dbua_fixup_stage_validation);
8903      ELSE
8904        result_txt :=  'ERROR: --> RECYCLE_BIN not empty.'
8905             || crlf || '     Your recycle bin contains ' || TO_CHAR(obj_count) || ' object(s). '
8906             || crlf || '     It is REQUIRED that the recycle bin is empty prior to upgrading.'
8907             || crlf || '     Immediately before performing the upgrade, execute the following'
8908             || crlf || '     command:'
8909             || crlf || '       EXECUTE dbms_preup.purge_recyclebin_fixup;';
8910      END IF;
8911      IF pOutputtingScripts THEN
8912        genFixup ('PURGE_RECYCLEBIN');
8913      END IF;
8914      RETURN c_status_failure;
8915    ELSE
8916      RETURN c_status_success; -- success
8917    END IF;
8918  END purge_recyclebin_check;
8919  
8920  FUNCTION purge_recyclebin_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
8921  IS
8922    obj_count  NUMBER;
8923    result_txt VARCHAR2(1500);
8924  BEGIN
8925    IF HelpType = c_help_overview THEN
8926      EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM sys.recyclebin$'
8927        INTO obj_count;
8928      IF (pDBGFailCheck AND obj_count = 0) THEN
8929        obj_count := 10;  -- Give it some non-zero number
8930      END IF;
8931  
8932      result_txt :=  'ERROR: --> Recycle Bin not empty' || crlf
8933          || crlf || '     Your recycle bin contains ' || TO_CHAR(obj_count) || ' object(s).'
8934          || crlf || '     It is REQUIRED that the recycle bin is empty prior to upgrading'
8935          || crlf || '     your database.  The command:'
8936          || crlf || '         execute dbms_preup.purge_recyclebin_fixup;'
8937          || crlf || '     must be executed immediately prior to executing your upgrade.';
8938    ELSIF HelpType = c_help_fixup THEN
8939      result_txt := 'The recycle bin will be purged.';
8940    END IF;
8941    RETURN result_txt;
8942  END purge_recyclebin_gethelp;
8943  --
8944  -- Fixup
8945  --
8946  PROCEDURE purge_recyclebin_fixup
8947  IS
8948    result  VARCHAR2(1000);
8949    status  NUMBER;
8950    tSqlcode NUMBER;
8951  BEGIN
8952    -- Call fixup and throw away the result
8953    status := purge_recyclebin_fixup (result, tSqlcode);
8954  END purge_recyclebin_fixup;
8955  
8956  FUNCTION purge_recyclebin_fixup (
8957           result_txt IN OUT VARCHAR2,
8958           pSqlcode    IN OUT NUMBER) RETURN number
8959  IS
8960  BEGIN
8961     return execute_sql_statement ('PURGE DBA_RECYCLEBIN',
8962          result_txt, pSqlcode);
8963  END purge_recyclebin_fixup;
8964  
8965  -- *****************************************************************
8966  --     REMOVE_DMSYS Section
8967  -- *****************************************************************
8968  FUNCTION REMOVE_DMSYS_check (result_txt OUT VARCHAR2) RETURN number
8969  IS
8970    t_null      CHAR(1);
8971    status      NUMBER := 0;
8972  BEGIN
8973  
8974    IF (db_n_version NOT IN (102,111,112,121) AND pDBGFailCheck = FALSE) THEN
8975      RETURN c_status_success;
8976    END IF;
8977  
8978    BEGIN
8979      EXECUTE IMMEDIATE 'SELECT NULL FROM sys.user$ WHERE name=''DMSYS'''
8980        INTO t_null;
8981      status := 1;
8982      EXCEPTION
8983         WHEN NO_DATA_FOUND THEN NULL;
8984    END;
8985  
8986    IF (status = 0 AND pDBGFailCheck = FALSE)
8987    THEN
8988      RETURN c_status_success;
8989    ELSE
8990      IF pOutputType = c_output_xml THEN
8991        result_txt:= genDBUAXMLCheck('REMOVE_DMSYS',
8992          c_check_level_info,
8993          'The DMSYS schema exists in the database and will be '
8994            || 'removed during the upgrade. '
8995            || 'Refer to the Oracle Data Mining User''s Guide for '
8996            || 'instructions on how to perform this task.',
8997          'The DMSYS schema exists in the database.',
8998          'Refer to the Oracle Data Mining User''s Guide for '
8999            || 'instructions on how to perform this task.',
9000           c_dbua_detail_type_sql,
9001          'select name from sys.user$ where name=''DMSYS''',
9002          c_dbua_fixup_type_manual,
9003          c_dbua_fixup_stage_pre );
9004      ELSE
9005        result_txt := REMOVE_DMSYS_gethelp(c_help_overview);
9006      END IF;
9007      IF pOutputtingScripts THEN
9008        genFixup ('REMOVE_DMSYS');
9009      END IF;
9010      RETURN c_status_failure;
9011     END IF;
9012  END REMOVE_DMSYS_check;
9013  
9014  FUNCTION REMOVE_DMSYS_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9015  IS
9016  BEGIN
9017    IF HelpType = c_help_overview THEN
9018      return 'WARNING: --> "DMSYS" schema exists in the database' || crlf
9019        || crlf || '     The DMSYS schema (Oracle Data Mining) will be removed'
9020        || crlf || '     from the database during the database upgrade.'
9021        || crlf || '     All data in DMSYS will be preserved under the SYS schema.'
9022        || crlf || '     Refer to the Oracle Data Mining User''s Guide for details.';
9023    ELSIF HelpType = c_help_fixup THEN
9024      return 'The DMSYS schema is removed as part of the upgrade.';
9025    END IF;
9026  END REMOVE_DMSYS_gethelp;
9027  --
9028  -- Fixup (Procedure and function)
9029  --
9030  PROCEDURE REMOVE_DMSYS_fixup
9031  IS
9032    result  VARCHAR2(1000);
9033    status  NUMBER;
9034    tSqlcode NUMBER;
9035  BEGIN
9036    -- Call fixup and throw away the result
9037    status := REMOVE_DMSYS_fixup (result, tSqlcode);
9038  END REMOVE_DMSYS_fixup;
9039  
9040  FUNCTION REMOVE_DMSYS_fixup (
9041           result_txt IN OUT VARCHAR2,
9042           pSqlcode    IN OUT NUMBER) RETURN number
9043  IS
9044  BEGIN
9045    -- Dump out the same thing we give for help
9046    result_txt := REMOVE_DMSYS_gethelp(c_help_overview);
9047    return c_fixup_status_info;
9048  END REMOVE_DMSYS_fixup;
9049  
9050  -- *****************************************************************
9051  --     REMOTE_REDO Section
9052  -- *****************************************************************
9053  FUNCTION REMOTE_REDO_check (result_txt OUT VARCHAR2) RETURN number
9054  IS
9055    tmp_varchar1 VARCHAR2(100);
9056    t_count      INTEGER;
9057    status       NUMBER := 0;
9058  BEGIN
9059  
9060    IF (db_n_version NOT IN (102,111) AND pDBGFailCheck = FALSE) THEN
9061      return c_status_not_for_this_version;
9062    END IF;
9063    --
9064    -- Check to detect if REDO configuration is supported with beyond
9065    -- 11.2
9066    --
9067    --  For 11.2, REDO has changed its maximum number of remote redo transport
9068    --  destinations from 9 to 30, we need to see if 10 is being used, and what
9069    --  its default is, if its local, there is an error.
9070    --
9071    -- Condition 1) Archiving of log files is enabled
9072    --
9073    -- Condition 2) DB_RECOVERY_FILE_DEST is defined
9074    --
9075    -- Condition 3) No local destinations are defined
9076    --
9077    -- Condition 4) LOG_ARCHIVE_DEST_1 is in use, and is a remote destition
9078    --
9079    --
9080    -- Only continue if archive logging is on
9081    --
9082  
9083    BEGIN
9084      EXECUTE IMMEDIATE
9085        'SELECT LOG_MODE FROM v$database'
9086        INTO tmp_varchar1;
9087      EXCEPTION
9088         WHEN NO_DATA_FOUND THEN tmp_varchar1 := 'NOARCHIVELOG';
9089    END;
9090  
9091    IF tmp_varchar1 != 'ARCHIVELOG' AND pDBGFailCheck = FALSE THEN
9092      RETURN c_status_success;
9093    END IF;
9094  
9095    --
9096    -- Check for db_recovery_file_dest
9097    --
9098    tmp_varchar1 := NULL;
9099    BEGIN
9100      EXECUTE IMMEDIATE 'SELECT vp.value FROM v$parameter vp WHERE
9101                 UPPER(vp.NAME) = ''DB_RECOVERY_FILE_DEST'''
9102      INTO tmp_varchar1;
9103  
9104      EXCEPTION
9105        WHEN NO_DATA_FOUND THEN NULL;
9106    END;
9107  
9108    IF tmp_varchar1 IS NOT NULL OR tmp_varchar1 != '' THEN
9109      --
9110      -- See if there are any local destinations defined
9111      -- Note the regexp_like
9112      --
9113      EXECUTE IMMEDIATE '
9114        SELECT count(*) FROM v$parameter v
9115          WHERE v.NAME  LIKE ''log_archive_dest_%'' AND
9116          REGEXP_LIKE(v.VALUE,''*[ ^]?location([ ])?=([ ])?*'')'
9117      INTO t_count;
9118  
9119      IF t_count > 0 THEN
9120        --
9121        -- Next is _1 in use, and remote
9122        --
9123        EXECUTE IMMEDIATE '
9124          SELECT count(*) FROM v$archive_dest ad
9125          WHERE ad.status=''VALID'' AND ad.dest_id=1 AND
9126                   ad.target=''STANDBY'''
9127        INTO t_count;
9128  
9129        IF t_count = 1 THEN
9130          --
9131          -- There is an issue to report.
9132          --
9133          status := 1;
9134        END IF;
9135      END IF; -- t_count = 1
9136    END IF;  -- having local dest values set
9137  
9138    IF (status = 0 AND pDBGFailCheck = FALSE)
9139    THEN
9140      RETURN c_status_success;
9141    ELSE
9142      IF pOutputType = c_output_xml THEN
9143        result_txt:= genDBUAXMLCheck('REMOTE_REDO',
9144          c_check_level_warning,
9145          'Starting with 11.2, only LOG_ARCHIVE_DEST_1 is used for defaulting local'
9146            || 'archival of redo data.'
9147            || ' You must specify a destination for local archiving since '
9148            || 'LOG_ARCHIVE_DEST_1 is not available.',
9149          'You must specify a destination for local archiving since '
9150            || 'LOG_ARCHIVE_DEST_1 is not available.',
9151          'BEGIN dbms_preup.REMOTE_REDO_fixup; END',
9152          c_dbua_detail_type_text,
9153          'You must specify a destination for local archiving since '
9154            || 'LOG_ARCHIVE_DEST_1 is not available.',
9155          c_dbua_fixup_type_manual,
9156          c_dbua_fixup_stage_pre );
9157      ELSE
9158        result_txt := REMOTE_REDO_gethelp(c_help_overview);
9159      END IF;
9160      IF pOutputtingScripts THEN
9161        genFixup ('REMOTE_REDO');
9162      END IF;
9163      RETURN c_status_failure;
9164     END IF;
9165  END REMOTE_REDO_check;
9166  
9167  FUNCTION REMOTE_REDO_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9168  IS
9169  BEGIN
9170    IF HelpType = c_help_overview THEN
9171      return 'ERROR: --> REDO Configuration not supported in 11.2' || crlf
9172          || crlf || '     Your REDO configuration is defaulting the use of'
9173          || crlf || '     LOG_ARCHIVE_DEST_10 for local archiving of redo data to'
9174          || crlf || '     the recovery area and has also defined'
9175          || crlf || '     LOG_ARCHIVE_DEST_1 for remote use.'
9176          || crlf || '     Starting with 11.2, only LOG_ARCHIVE_DEST_1 is used for defaulting local'
9177          || crlf || '     archival of redo data.'
9178          || crlf || '     You must specify a destination for local archiving since'
9179          || crlf || '     LOG_ARCHIVE_DEST_1 is not available.';
9180    ELSIF HelpType = c_help_fixup THEN
9181      return 'Manually specify a destination for local archiving.';
9182    END IF;
9183  END REMOTE_REDO_gethelp;
9184  --
9185  -- Fixup (Procedure and function)
9186  --
9187  PROCEDURE REMOTE_REDO_fixup
9188  IS
9189    result  VARCHAR2(1000);
9190    status  NUMBER;
9191    tSqlcode NUMBER;
9192  BEGIN
9193    -- Call fixup and throw away the result
9194    status := REMOTE_REDO_fixup (result, tSqlcode);
9195  END REMOTE_REDO_fixup;
9196  
9197  FUNCTION REMOTE_REDO_fixup (
9198           result_txt IN OUT VARCHAR2,
9199           pSqlcode    IN OUT NUMBER) RETURN number
9200  IS
9201  BEGIN
9202    -- Dump out the same thing we give for help
9203    result_txt := REMOTE_REDO_gethelp(c_help_overview);
9204    return c_fixup_status_info;
9205  END REMOTE_REDO_fixup;
9206  
9207  -- *****************************************************************
9208  --     SYNC_STANDBY_DB Section
9209  -- *****************************************************************
9210  FUNCTION SYNC_STANDBY_DB_check (result_txt OUT VARCHAR2) RETURN number
9211  IS
9212    t_null      CHAR(1);
9213    status      NUMBER;
9214  BEGIN
9215    BEGIN
9216      EXECUTE IMMEDIATE 'SELECT NULL FROM v$parameter WHERE
9217         name LIKE ''log_archive_dest%'' AND upper(value) LIKE ''SERVICE%''
9218         AND rownum <=1'
9219      INTO t_null;
9220         status := 1;
9221    EXCEPTION
9222        WHEN NO_DATA_FOUND THEN status := 0;
9223    END;
9224  
9225    IF (status = 0 AND pDBGFailCheck = FALSE)
9226    THEN
9227      RETURN c_status_success;
9228    ELSE
9229      IF pOutputType = c_output_xml THEN
9230        result_txt:= genDBUAXMLCheck('SYNC_STANDBY_DB',
9231          c_check_level_warning,
9232          'Sync standby database prior to upgrade.',
9233          'Sync standby database prior to upgrade.',
9234          'Sync standby database prior to upgrade.',
9235          c_dbua_detail_type_sql,
9236          htmlentities('SELECT name FROM v$parameter WHERE'
9237             || ' name LIKE ''log_archive_dest%'' AND'
9238             || ' upper(value) LIKE ''SERVICE%'' AND rownum <=1'),
9239          c_dbua_fixup_type_manual,
9240          c_dbua_fixup_stage_pre );
9241      ELSE
9242        result_txt := SYNC_STANDBY_DB_gethelp(c_help_overview);
9243      END IF;
9244      IF pOutputtingScripts THEN
9245        genFixup ('SYNC_STANDBY_DB');
9246      END IF;
9247      RETURN c_status_failure;
9248     END IF;
9249  END SYNC_STANDBY_DB_check;
9250  
9251  FUNCTION SYNC_STANDBY_DB_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9252  IS
9253  BEGIN
9254    IF HelpType = c_help_overview THEN
9255      return 'WARNING: --> Standby database not synced' || crlf
9256        || crlf || '     Sync standby database prior to upgrade.'
9257        || crlf || '     Your standby databases should be synched prior to upgrading.';
9258    ELSIF HelpType = c_help_fixup THEN
9259      return 'Standby databases should be synced prior to upgrade.';
9260    END IF;
9261  END SYNC_STANDBY_DB_gethelp;
9262  --
9263  -- Fixup (Procedure and function)
9264  --
9265  PROCEDURE SYNC_STANDBY_DB_fixup
9266  IS
9267    result  VARCHAR2(1000);
9268    status  NUMBER;
9269    tSqlcode NUMBER;
9270  BEGIN
9271    -- Call fixup and throw away the result
9272    status := SYNC_STANDBY_DB_fixup (result, tSqlcode);
9273  END SYNC_STANDBY_DB_fixup;
9274  
9275  FUNCTION SYNC_STANDBY_DB_fixup (
9276           result_txt IN OUT VARCHAR2,
9277           pSqlcode    IN OUT NUMBER) RETURN number
9278  IS
9279  BEGIN
9280    -- Dump out the same thing we give for help
9281    result_txt := SYNC_STANDBY_DB_gethelp(c_help_overview);
9282    return c_fixup_status_info;
9283  END SYNC_STANDBY_DB_fixup;
9284  -- *****************************************************************
9285  --     SYS_DEFAULT_TABLESPACE Section
9286  -- *****************************************************************
9287  FUNCTION SYS_DEF_TABLESPACE_check (result_txt OUT VARCHAR2) RETURN number
9288  IS
9289    t_ts1       VARCHAR2(30);
9290    t_ts2       VARCHAR2(30);
9291    status      NUMBER;
9292  BEGIN
9293  
9294    EXECUTE IMMEDIATE 'SELECT default_tablespace FROM sys.dba_users WHERE username = ''SYS'''
9295    INTO t_ts1;
9296    EXECUTE IMMEDIATE 'SELECT default_tablespace FROM sys.dba_users WHERE username = ''SYSTEM'''
9297    INTO t_ts2;
9298  
9299    IF (t_ts1 = 'SYSTEM') AND (t_ts2 = 'SYSTEM') AND (pDBGFailCheck = FALSE) THEN
9300      -- Everything is fine.
9301      RETURN c_status_success;
9302    ELSE
9303      IF pOutputType = c_output_xml THEN
9304        result_txt:= genDBUAXMLCheck('SYS_DEFAULT_TABLESPACE',
9305          c_check_level_warning,
9306          'The SYSTEM or SYS schemas have been altered so their default tablespace'
9307             || ' is no longer SYSTEM.  Prior to upgrading, the schema default'
9308             || ' tablespace must be reset to the SYSTEM tablespace',
9309          'The SYSTEM or SYS schemas have been altered so their default tablespace',
9310          'BEGIN dbms_preup.SYS_DEF_TABLESPACE_fixup; END;',
9311           c_dbua_detail_type_sql,
9312          htmlentities('select username,default_tablespace from sys.dba_users'
9313            || ' where username IN (''SYS'',''SYSTEM'')'),
9314          c_dbua_fixup_type_auto,
9315          c_dbua_fixup_stage_pre );
9316      ELSE
9317        result_txt := SYS_DEF_TABLESPACE_gethelp(c_help_overview);
9318      END IF;
9319      IF pOutputtingScripts THEN
9320        genFixup ('SYS_DEFAULT_TABLESPACE');
9321      END IF;
9322      RETURN c_status_failure;
9323     END IF;
9324  END SYS_DEF_TABLESPACE_check;
9325  
9326  FUNCTION SYS_DEF_TABLESPACE_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9327  IS
9328  BEGIN
9329    IF HelpType = c_help_overview THEN
9330      return 'WARNING: --> SYS and SYSTEM schema default tablespace has been altered' || crlf
9331       || crlf || '     Prior to upgrading your database, please ensure both'
9332       || crlf || '     the SYS and SYSTEM schema default their tablespace to SYSTEM.'
9333       || crlf || '       Execute: execute dbms_preup.SYS_DEF_TABLESPACE_fixup; ';
9334    ELSIF HelpType = c_help_fixup THEN
9335      return 'SYSTEM account default tablespace is altered to be SYSTEM.';
9336    END IF;
9337  END SYS_DEF_TABLESPACE_gethelp;
9338  --
9339  -- Fixup (Procedure and function)
9340  --
9341  PROCEDURE SYS_DEF_TABLESPACE_fixup
9342  IS
9343    result  VARCHAR2(1000);
9344    status  NUMBER;
9345    tSqlcode NUMBER;
9346  BEGIN
9347    -- Call fixup and throw away the result
9348    status := SYS_DEF_TABLESPACE_fixup (result, tSqlcode);
9349  END SYS_DEF_TABLESPACE_fixup;
9350  
9351  FUNCTION SYS_DEF_TABLESPACE_fixup (
9352           result_txt IN OUT VARCHAR2,
9353           pSqlcode    IN OUT NUMBER) RETURN number
9354  IS
9355    t_result_txt VARCHAR2(1000);
9356    t_ts1        VARCHAR2(128);
9357    rval         NUMBER := 1;
9358  BEGIN
9359    --
9360    --  Check both SYS and SYSTEM and reset if needed
9361    --
9362    result_txt := '';
9363    pSqlcode := 1;
9364    EXECUTE IMMEDIATE 'SELECT default_tablespace FROM sys.dba_users WHERE username = ''SYS'''
9365    INTO t_ts1;
9366    IF (t_ts1 != 'SYSTEM') THEN
9367      result_txt := 'Altering SYS schema default tablespace.  Result: ';
9368      rval := execute_sql_statement ('ALTER USER SYS DEFAULT TABLESPACE SYSTEM', t_result_txt, pSqlcode);
9369      result_txt := result_txt || TO_CHAR(pSqlcode);
9370    END IF;
9371  
9372    EXECUTE IMMEDIATE 'SELECT default_tablespace FROM sys.dba_users WHERE username = ''SYSTEM'''
9373    INTO t_ts1;
9374    IF (t_ts1 != 'SYSTEM') THEN
9375      result_txt := result_txt || crlf || 'Altering SYSTEM schema default tablespace Result: ';
9376      rval := execute_sql_statement ('ALTER USER SYSTEM DEFAULT TABLESPACE SYSTEM', t_result_txt, pSqlcode);
9377      result_txt := result_txt || TO_CHAR(pSqlcode);
9378    END IF;
9379    --
9380    -- If both were executed, only the last status is returned.
9381    --
9382    RETURN rval;
9383  END SYS_DEF_TABLESPACE_fixup;
9384  
9385  -- *****************************************************************
9386  --     ULTRASEARCH_DATA Section
9387  -- *****************************************************************
9388  FUNCTION ULTRASEARCH_DATA_check (result_txt OUT VARCHAR2) RETURN number
9389  IS
9390    status  NUMBER := 0;
9391    i_count INTEGER;
9392  BEGIN
9393    -- Once Ultra Search instance is created, wk$instance table is populated.
9394    -- The logic determines if Ultra Search has data or not by looking up
9395    -- wk$instance table. WKSYS.WK$INSTANCE table exists when Ultra Search is
9396    -- installed. If it's not installed, WKSYS.WK$INSTANCE doesn't exist and the
9397    -- pl/sql block raises exception.
9398    --
9399    BEGIN
9400      EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM wksys.wk$instance'
9401        INTO i_count;
9402      -- count will be 0 when there are no rows in wksys.wk$instance
9403      -- Otherwise there is at least one row in
9404      -- and an ultra search warning should be displayed
9405      IF (i_count != 0) THEN
9406         status := 1;
9407      END IF;
9408      EXCEPTION WHEN OTHERS THEN NULL;
9409    END;
9410  
9411    IF (status = 0 AND pDBGFailCheck = FALSE)
9412    THEN
9413      RETURN c_status_success;
9414    ELSE
9415      IF pOutputType = c_output_xml THEN
9416        result_txt:= genDBUAXMLCheck('ULTRASEARCH_DATA',
9417          c_check_level_warning,
9418          'Ultra Search is not supported beyond 11.2 and is removed automatically during upgrade.'
9419           || ' If you need to preserve Ultra Search data please perform a manual cold backup prior to upgrade.',
9420          'Ultra Search data is present in the Database',
9421          'Optionally backup Ultra Search',
9422           c_dbua_detail_type_text,
9423          'To verify that Ultrasearch data exists, execute'
9424            || ' the following query: SELECT COUNT(*) FROM wksys.wk$instance',
9425          c_dbua_fixup_type_manual,
9426          c_dbua_fixup_stage_pre );
9427      ELSE
9428        result_txt := ULTRASEARCH_DATA_gethelp(c_help_overview);
9429      END IF;
9430      IF pOutputtingScripts THEN
9431        genFixup ('ULTRASEARCH_DATA');
9432      END IF;
9433      RETURN c_status_failure;
9434     END IF;
9435  END ULTRASEARCH_DATA_check;
9436  
9437  FUNCTION ULTRASEARCH_DATA_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9438  IS
9439  BEGIN
9440    IF HelpType = c_help_overview THEN
9441      return 'WARNING: --> Ultra Search not supported' || crlf
9442        || crlf || '     Ultra Search is not supported as of 11.2 and is removed during the upgrade.'
9443        || crlf || '     You may perform this task prior to the upgrade by  using wkremov.sql '
9444        || crlf || '     located in the rdbms/admin directory of the new software installation.'
9445        || crlf || '     If you wish to preserve the Ultra Search data please perform a manual'
9446        || crlf || '     cold backup prior to upgrade.';
9447    ELSIF HelpType = c_help_fixup THEN
9448      return 'Ultra Search data may be backed up prior upgrade as it will be removed during the upgrade.';
9449    END IF;
9450  END ULTRASEARCH_DATA_gethelp;
9451  --
9452  -- Fixup (Procedure and function)
9453  --
9454  PROCEDURE ULTRASEARCH_DATA_fixup
9455  IS
9456    result  VARCHAR2(1000);
9457    status  NUMBER;
9458    tSqlcode NUMBER;
9459  BEGIN
9460    -- Call fixup and throw away the result
9461    status := ULTRASEARCH_DATA_fixup (result, tSqlcode);
9462  END ULTRASEARCH_DATA_fixup;
9463  
9464  FUNCTION ULTRASEARCH_DATA_fixup (
9465           result_txt IN OUT VARCHAR2,
9466           pSqlcode    IN OUT NUMBER) RETURN number
9467  IS
9468  BEGIN
9469    -- Dump out the same thing we give for help
9470    result_txt := ULTRASEARCH_DATA_gethelp(c_help_overview);
9471    return c_fixup_status_info;
9472  END ULTRASEARCH_DATA_fixup;
9473  
9474  -- *****************************************************************
9475  --     unsupported_version Section
9476  -- *****************************************************************
9477  FUNCTION unsupported_version_check (result_txt OUT VARCHAR2) RETURN number
9478  IS
9479    status      NUMBER;
9480  BEGIN
9481    --
9482    -- If the major (does not include fifth digit) is in the supported list
9483    -- we're good (if we are not failing all the checks)
9484    -- Also return SUCCESS if we are in XML because this is a manual
9485    -- only test.
9486    --
9487    -- Same check is done in init routine to set pUnsupportedUpgrade
9488    -- Using substr of c_version instead of hard-coding, for example
9489    -- '121' avoids errors while versions are updated.
9490    --
9491  
9492    IF ( ( ( (instr (c_supported_versions, db_patch_vers) > 0) -- Supported ver found
9493            OR (db_major_vers = SUBSTR(c_version, 1,6))  -- DB is same version
9494           )  AND pDBGFailCheck = FALSE                  -- We want to fail all checks
9495         ) OR pOutputType = c_output_xml ) THEN       -- Output XML
9496      RETURN c_status_success;
9497    END IF;
9498  
9499    --
9500    -- The DBUA has its own check, this is for text version only
9501    --
9502    result_txt := unsupported_version_gethelp(c_help_overview);
9503  
9504    IF pOutputtingScripts THEN
9505      genFixup ('UNSUPPORTED_VERSION');
9506    END IF;
9507    RETURN c_status_failure;
9508  END unsupported_version_check;
9509  
9510  FUNCTION unsupported_version_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9511  IS
9512  BEGIN
9513    IF HelpType = c_help_overview THEN
9514      return 'ERROR: --> Unsupported Version Upgrade' || crlf
9515        || crlf || pStarHeader
9516        || crlf || CenterLine('**** YOU CANNOT UPGRADE THIS DATABASE TO THIS RELEASE ****')
9517        || crlf || pStarHeader
9518        || crlf || '     Direct upgrade from ' || db_patch_vers || ' is not supported.'
9519        || crlf || '     Please refer to Chapter 2 of the Oracle Database Upgrade Guide for'
9520        || crlf || '     the matrix of releases supported for direct upgrade.';
9521    ELSIF HelpType = c_help_fixup THEN
9522      return 'Database must be first upgraded to a supported release prior to upgrading to this release.';
9523    END IF;
9524  END unsupported_version_gethelp;
9525  --
9526  -- Fixup (Procedure and function)
9527  --
9528  PROCEDURE unsupported_version_fixup
9529  IS
9530    result  VARCHAR2(1000);
9531    status  NUMBER;
9532    tSqlcode NUMBER;
9533  BEGIN
9534    -- Call fixup and throw away the result
9535    status := unsupported_version_fixup (result, tSqlcode);
9536  END unsupported_version_fixup;
9537  
9538  FUNCTION unsupported_version_fixup (
9539           result_txt IN OUT VARCHAR2,
9540           pSqlcode    IN OUT NUMBER) RETURN number
9541  IS
9542  BEGIN
9543     result_txt := unsupported_version_gethelp(c_help_overview);
9544     return c_fixup_status_info;
9545  END unsupported_version_fixup;
9546  
9547  -- *****************************************************************
9548  --     PROVISIONER_PRESENT Section
9549  -- *****************************************************************
9550  FUNCTION PROVISIONER_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
9551  IS
9552    user_exists NUMBER := 1;
9553    t_null      CHAR(1);
9554    status      NUMBER;
9555  BEGIN
9556    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
9557      return c_status_not_for_this_version;
9558    END IF;
9559  
9560    BEGIN
9561      EXECUTE IMMEDIATE
9562       'SELECT NULL FROM sys.user$ WHERE name = ''PROVISIONER'''
9563        INTO t_null;
9564      EXCEPTION
9565        WHEN NO_DATA_FOUND then user_exists := 0;
9566    END;
9567    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
9568    THEN
9569      RETURN c_status_success;
9570    ELSE
9571      IF pOutputType = c_output_xml THEN
9572        result_txt:= genDBUAXMLCheck('PROVISIONER_PRESENT',
9573          c_check_level_error,
9574          'A user or role named "PROVISIONER" found in the database.',
9575          'A user or role named "PROVISIONER" found in the database.',
9576          '"PROVISIONER" user or role must be dropped prior to upgrading.',
9577           c_dbua_detail_type_text,
9578          'To drop the user "PROVISIONER", use the command: '||
9579          'DROP USER PROVISIONER CASCADE'||', and To drop the role "PROVISIONER", use the'||
9580          'command: DROP ROLE PROVISIONER',
9581          c_dbua_fixup_type_manual,
9582          c_dbua_fixup_stage_pre );
9583      ELSE
9584        result_txt := PROVISIONER_PRESENT_gethelp(c_help_overview);
9585      END IF;
9586      IF pOutputtingScripts THEN
9587        genFixup ('PROVISIONER_PRESENT');
9588      END IF;
9589      RETURN c_status_failure;
9590     END IF;
9591  END PROVISIONER_PRESENT_check;
9592  
9593  FUNCTION PROVISIONER_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9594  IS
9595  BEGIN
9596    IF HelpType = c_help_overview THEN
9597      return 'ERROR: --> A user or role with the name "PROVISIONER" found in the database.' || crlf
9598        || crlf || '     This is an Oracle defined role.'
9599        || crlf || '     You must drop this user or role prior to upgrading.';
9600    ELSIF HelpType = c_help_fixup THEN
9601      return 'The PROVISIONER user or role must be dropped prior to upgrading.';
9602    END IF;
9603  END PROVISIONER_PRESENT_gethelp;
9604  --
9605  -- Fixup (Procedure and function)
9606  --
9607  PROCEDURE PROVISIONER_PRESENT_fixup
9608  IS
9609    result  VARCHAR2(1000);
9610    status  NUMBER;
9611    tSqlcode NUMBER;
9612  BEGIN
9613    -- Call fixup and throw away the result
9614    status := PROVISIONER_PRESENT_fixup (result, tSqlcode);
9615  END PROVISIONER_PRESENT_fixup;
9616  
9617  FUNCTION PROVISIONER_PRESENT_fixup (
9618           result_txt IN OUT VARCHAR2,
9619           pSqlcode    IN OUT NUMBER) RETURN number
9620  IS
9621  BEGIN
9622    result_txt  := PROVISIONER_PRESENT_gethelp(c_help_overview);
9623    pSqlcode := 0;
9624    return c_fixup_status_info;
9625  END PROVISIONER_PRESENT_fixup;
9626  
9627  -- *****************************************************************
9628  --     XS_RESOURCE_PRESENT Section
9629  -- *****************************************************************
9630  FUNCTION XS_RESOURCE_PRESENT_check (result_txt OUT VARCHAR2) RETURN number
9631  IS
9632    user_exists NUMBER := 1;
9633    t_null      CHAR(1);
9634    status      NUMBER;
9635  BEGIN
9636    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
9637      return c_status_not_for_this_version;
9638    END IF;
9639  
9640    BEGIN
9641      EXECUTE IMMEDIATE
9642       'SELECT NULL FROM sys.user$ WHERE name = ''XS_RESOURCE'''
9643        INTO t_null;
9644      EXCEPTION
9645        WHEN NO_DATA_FOUND then user_exists := 0;
9646    END;
9647    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
9648    THEN
9649      RETURN c_status_success;
9650    ELSE
9651      IF pOutputType = c_output_xml THEN
9652        result_txt:= genDBUAXMLCheck('XS_RESOURCE_PRESENT',
9653          c_check_level_error,
9654          'A user or role named "XS_RESOURCE" found in the database.',
9655          'A user or role named "XS_RESOURCE" found in the database.',
9656          '"XS_RESOURCE" user or role must be dropped prior to upgrading.',
9657           c_dbua_detail_type_text,
9658          'To drop the user "XS_RESOURCE", use the command: '||
9659          'DROP USER XS_RESOURCE CASCADE'||', and To drop the role "XS_RESOURCE", use the'||
9660          'command: DROP ROLE XS_RESOURCE',
9661          c_dbua_fixup_type_manual,
9662          c_dbua_fixup_stage_pre );
9663      ELSE
9664        result_txt := XS_RESOURCE_PRESENT_gethelp(c_help_overview);
9665      END IF;
9666      IF pOutputtingScripts THEN
9667        genFixup ('XS_RESOURCE_PRESENT');
9668      END IF;
9669      RETURN c_status_failure;
9670     END IF;
9671  END XS_RESOURCE_PRESENT_check;
9672  
9673  FUNCTION XS_RESOURCE_PRESENT_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9674  IS
9675  BEGIN
9676    IF HelpType = c_help_overview THEN
9677      return 'ERROR: --> A user or role with the name "XS_RESOURCE" found in the database.' || crlf
9678        || crlf || '     This is an Oracle defined role.'
9679        || crlf || '     You must drop this user or role prior to upgrading.';
9680    ELSIF HelpType = c_help_fixup THEN
9681      return 'The XS_RESOURCE user or role must be dropped prior to upgrading.';
9682    END IF;
9683  END XS_RESOURCE_PRESENT_gethelp;
9684  --
9685  -- Fixup (Procedure and function)
9686  --
9687  PROCEDURE XS_RESOURCE_PRESENT_fixup
9688  IS
9689    result  VARCHAR2(1000);
9690    status  NUMBER;
9691    tSqlcode NUMBER;
9692  BEGIN
9693    -- Call fixup and throw away the result
9694    status := XS_RESOURCE_PRESENT_fixup (result, tSqlcode);
9695  END XS_RESOURCE_PRESENT_fixup;
9696  
9697  FUNCTION XS_RESOURCE_PRESENT_fixup (
9698           result_txt IN OUT VARCHAR2,
9699           pSqlcode    IN OUT NUMBER) RETURN number
9700  IS
9701  BEGIN
9702    result_txt  := XS_RESOURCE_PRESENT_gethelp(c_help_overview);
9703    pSqlcode := 0;
9704    return c_fixup_status_info;
9705  END XS_RESOURCE_PRESENT_fixup;
9706  
9707  -- *****************************************************************
9708  --     XS_SESSION_ADMIN Section
9709  -- *****************************************************************
9710  FUNCTION XS_SESSION_ADMIN_check (result_txt OUT VARCHAR2) RETURN number
9711  IS
9712    user_exists NUMBER := 1;
9713    t_null      CHAR(1);
9714    status      NUMBER;
9715  BEGIN
9716    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
9717      return c_status_not_for_this_version;
9718    END IF;
9719  
9720    BEGIN
9721      EXECUTE IMMEDIATE
9722       'SELECT NULL FROM sys.user$ WHERE name = ''XS_SESSION_ADMIN'''
9723        INTO t_null;
9724      EXCEPTION
9725        WHEN NO_DATA_FOUND then user_exists := 0;
9726    END;
9727    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
9728    THEN
9729      RETURN c_status_success;
9730    ELSE
9731      IF pOutputType = c_output_xml THEN
9732        result_txt:= genDBUAXMLCheck('XS_SESSION_ADMIN',
9733          c_check_level_error,
9734          'A user or role named "XS_SESSION_ADMIN" found in the database.',
9735          'A user or role named "XS_SESSION_ADMIN" found in the database.',
9736          '"XS_SESSION_ADMIN" user or role must be dropped prior to upgrading.',
9737           c_dbua_detail_type_text,
9738          'To drop the user "XS_SESSION_ADMIN", use the command: '||
9739          'DROP USER XS_SESSION_ADMIN CASCADE'||
9740          ', and To drop the role "XS_SESSION_ADMIN", use the'||
9741          'command: DROP ROLE XS_SESSION_ADMIN',
9742          c_dbua_fixup_type_manual,
9743          c_dbua_fixup_stage_pre );
9744      ELSE
9745        result_txt := XS_SESSION_ADMIN_gethelp(c_help_overview);
9746      END IF;
9747      IF pOutputtingScripts THEN
9748        genFixup ('XS_SESSION_ADMIN');
9749      END IF;
9750      RETURN c_status_failure;
9751     END IF;
9752  END XS_SESSION_ADMIN_check;
9753  
9754  FUNCTION XS_SESSION_ADMIN_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9755  IS
9756  BEGIN
9757    IF HelpType = c_help_overview THEN
9758      return 'ERROR: --> A user or role with the name "XS_SESSION_ADMIN" found in the database.' || crlf
9759        || crlf || '     This is an Oracle defined role.'
9760        || crlf || '     You must drop this user or role prior to upgrading.';
9761    ELSIF HelpType = c_help_fixup THEN
9762      return 'The XS_SESSION_ADMIN user or role must be dropped prior to upgrading.';
9763    END IF;
9764  END XS_SESSION_ADMIN_gethelp;
9765  --
9766  -- Fixup (Procedure and function)
9767  --
9768  PROCEDURE XS_SESSION_ADMIN_fixup
9769  IS
9770    result  VARCHAR2(1000);
9771    status  NUMBER;
9772    tSqlcode NUMBER;
9773  BEGIN
9774    -- Call fixup and throw away the result
9775    status := XS_SESSION_ADMIN_fixup (result, tSqlcode);
9776  END XS_SESSION_ADMIN_fixup;
9777  
9778  FUNCTION XS_SESSION_ADMIN_fixup (
9779           result_txt IN OUT VARCHAR2,
9780           pSqlcode    IN OUT NUMBER) RETURN number
9781  IS
9782  BEGIN
9783    result_txt  := XS_SESSION_ADMIN_gethelp(c_help_overview);
9784    pSqlcode := 0;
9785    return c_fixup_status_info;
9786  END XS_SESSION_ADMIN_fixup;
9787  
9788  -- *****************************************************************
9789  --     XS_NAMESPACE_ADMIN Section
9790  -- *****************************************************************
9791  FUNCTION XS_NAMESPACE_ADMIN_check (result_txt OUT VARCHAR2) RETURN number
9792  IS
9793    user_exists NUMBER := 1;
9794    t_null      CHAR(1);
9795    status      NUMBER;
9796  BEGIN
9797    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
9798      return c_status_not_for_this_version;
9799    END IF;
9800  
9801    BEGIN
9802      EXECUTE IMMEDIATE
9803       'SELECT NULL FROM sys.user$ WHERE name = ''XS_NAMESPACE_ADMIN'''
9804        INTO t_null;
9805      EXCEPTION
9806        WHEN NO_DATA_FOUND then user_exists := 0;
9807    END;
9808    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
9809    THEN
9810      RETURN c_status_success;
9811    ELSE
9812      IF pOutputType = c_output_xml THEN
9813        result_txt:= genDBUAXMLCheck('XS_NAMESPACE_ADMIN',
9814          c_check_level_error,
9815          'A user or role named "XS_NAMESPACE_ADMIN" found in the database.',
9816          'A user or role named "XS_NAMESPACE_ADMIN" found in the database.',
9817          '"XS_NAMESPACE_ADMIN" user or role must be dropped prior to upgrading.',
9818           c_dbua_detail_type_text,
9819          'To drop the user "XS_NAMESPACE_ADMIN", use the command: '||
9820          'DROP USER XS_NAMESPACE_ADMIN CASCADE'||
9821          ', and To drop the role "XS_NAMESPACE_ADMIN", use the'||
9822          'command: DROP ROLE XS_NAMESPACE_ADMIN',
9823          c_dbua_fixup_type_manual,
9824          c_dbua_fixup_stage_pre );
9825      ELSE
9826        result_txt := XS_NAMESPACE_ADMIN_gethelp(c_help_overview);
9827      END IF;
9828      IF pOutputtingScripts THEN
9829        genFixup ('XS_NAMESPACE_ADMIN');
9830      END IF;
9831      RETURN c_status_failure;
9832     END IF;
9833  END XS_NAMESPACE_ADMIN_check;
9834  
9835  FUNCTION XS_NAMESPACE_ADMIN_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9836  IS
9837  BEGIN
9838    IF HelpType = c_help_overview THEN
9839      return 'ERROR: --> A user or role with the name "XS_NAMESPACE_ADMIN" found in the database.' || crlf
9840        || crlf || '     This is an Oracle defined role.'
9841        || crlf || '     You must drop this user or role prior to upgrading.';
9842    ELSIF HelpType = c_help_fixup THEN
9843      return 'The XS_NAMESPACE_ADMIN user or role must be dropped prior to upgrading.';
9844    END IF;
9845  END XS_NAMESPACE_ADMIN_gethelp;
9846  --
9847  -- Fixup (Procedure and function)
9848  --
9849  PROCEDURE XS_NAMESPACE_ADMIN_fixup
9850  IS
9851    result  VARCHAR2(1000);
9852    status  NUMBER;
9853    tSqlcode NUMBER;
9854  BEGIN
9855    -- Call fixup and throw away the result
9856    status := XS_NAMESPACE_ADMIN_fixup (result, tSqlcode);
9857  END XS_NAMESPACE_ADMIN_fixup;
9858  
9859  FUNCTION XS_NAMESPACE_ADMIN_fixup (
9860           result_txt IN OUT VARCHAR2,
9861           pSqlcode    IN OUT NUMBER) RETURN number
9862  IS
9863  BEGIN
9864    result_txt  := XS_NAMESPACE_ADMIN_gethelp(c_help_overview);
9865    pSqlcode := 0;
9866    return c_fixup_status_info;
9867  END XS_NAMESPACE_ADMIN_fixup;
9868  
9869  -- *****************************************************************
9870  --     XS_CACHE_ADMIN Section
9871  -- *****************************************************************
9872  FUNCTION XS_CACHE_ADMIN_check (result_txt OUT VARCHAR2) RETURN number
9873  IS
9874    user_exists NUMBER := 1;
9875    t_null      CHAR(1);
9876    status      NUMBER;
9877  BEGIN
9878    IF (db_n_version NOT IN (102,111,112) AND pDBGFailCheck = FALSE) THEN
9879      return c_status_not_for_this_version;
9880    END IF;
9881  
9882    BEGIN
9883      EXECUTE IMMEDIATE
9884       'SELECT NULL FROM sys.user$ WHERE name = ''XS_CACHE_ADMIN'''
9885        INTO t_null;
9886      EXCEPTION
9887        WHEN NO_DATA_FOUND then user_exists := 0;
9888    END;
9889    IF (user_exists = 0 AND pDBGFailCheck = FALSE)
9890    THEN
9891      RETURN c_status_success;
9892    ELSE
9893      IF pOutputType = c_output_xml THEN
9894        result_txt:= genDBUAXMLCheck('XS_CACHE_ADMIN',
9895          c_check_level_error,
9896          'A user or role named "XS_CACHE_ADMIN" found in the database.',
9897          'A user or role named "XS_CACHE_ADMIN" found in the database.',
9898          '"XS_CACHE_ADMIN" user or role must be dropped prior to upgrading.',
9899           c_dbua_detail_type_text,
9900          'To drop the user "XS_CACHE_ADMIN", use the command: '||
9901          'DROP USER XS_CACHE_ADMIN CASCADE'||
9902          ', and To drop the role "XS_CACHE_ADMIN", use the'||
9903          'command: DROP ROLE XS_CACHE_ADMIN',
9904          c_dbua_fixup_type_manual,
9905          c_dbua_fixup_stage_pre );
9906      ELSE
9907        result_txt := XS_CACHE_ADMIN_gethelp(c_help_overview);
9908      END IF;
9909      IF pOutputtingScripts THEN
9910        genFixup ('XS_CACHE_ADMIN');
9911      END IF;
9912      RETURN c_status_failure;
9913     END IF;
9914  END XS_CACHE_ADMIN_check;
9915  
9916  FUNCTION XS_CACHE_ADMIN_gethelp (HelpType IN NUMBER) RETURN VARCHAR2
9917  IS
9918  BEGIN
9919    IF HelpType = c_help_overview THEN
9920      return 'ERROR: --> A user or role with the name "XS_CACHE_ADMIN" found in the database.' || crlf
9921        || crlf || '     This is an Oracle defined role.'
9922        || crlf || '     You must drop this user or role prior to upgrading.';
9923    ELSIF HelpType = c_help_fixup THEN
9924      return 'The XS_CACHE_ADMIN user or role must be dropped prior to upgrading.';
9925    END IF;
9926  END XS_CACHE_ADMIN_gethelp;
9927  --
9928  -- Fixup (Procedure and function)
9929  --
9930  PROCEDURE XS_CACHE_ADMIN_fixup
9931  IS
9932    result  VARCHAR2(1000);
9933    status  NUMBER;
9934    tSqlcode NUMBER;
9935  BEGIN
9936    -- Call fixup and throw away the result
9937    status := XS_CACHE_ADMIN_fixup (result, tSqlcode);
9938  END XS_CACHE_ADMIN_fixup;
9939  
9940  FUNCTION XS_CACHE_ADMIN_fixup (
9941           result_txt IN OUT VARCHAR2,
9942           pSqlcode    IN OUT NUMBER) RETURN number
9943  IS
9944  BEGIN
9945    result_txt  := XS_CACHE_ADMIN_gethelp(c_help_overview);
9946    pSqlcode := 0;
9947    return c_fixup_status_info;
9948  END XS_CACHE_ADMIN_fixup;
9949  
9950  -- ****************************************************************************
9951  --                             Specific Recommendation Area
9952  -- ****************************************************************************
9953  --
9954  -- "check-name"_recommend()
9955  --   These checks are usually just dumping out text either to the log or to
9956  --   the scripts
9957  --
9958  PROCEDURE dictionary_stats_recommend
9959  IS
9960  BEGIN
9961    IF pOutputType = c_output_text THEN
9962      --
9963      -- Stale Stats
9964      --
9965      DisplayLine(pPreScriptUFT,'BEGIN');
9966      DisplayCenter(pPreScriptUFT,pStarHeader);
9967      DisplayCenter(pPreScriptUFT,CenterLine('********* Dictionary Statistics *********'));
9968      DisplayCenter(pPreScriptUFT,pStarHeader);
9969      DisplayLineBoth(pPreScriptUFT, '');
9970      DisplayLineBoth(pPreScriptUFT, 'Please gather dictionary statistics 24 hours prior to');
9971      DisplayLineBoth(pPreScriptUFT, 'upgrading the database.');
9972      DisplayLineBoth(pPreScriptUFT, 'To gather dictionary statistics execute the following command');
9973      DisplayLineBoth(pPreScriptUFT, 'while connected as SYSDBA:');
9974      DisplayLineBoth(pPreScriptUFT, '    EXECUTE dbms_stats.gather_dictionary_stats;');
9975      DisplayLineBoth(pPreScriptUFT, '');
9976      DisplayLineBoth(pPreScriptUFT, pActionSuggested);
9977      DisplayLineBoth(pPreScriptUFT, '');
9978      DisplayLine(pPreScriptUFT,'END;');
9979      DisplayLine(pPreScriptUFT,'/');
9980    END IF;
9981  END dictionary_stats_recommend;
9982  
9983  PROCEDURE hidden_params_recommend
9984  IS
9985    t_boolean BOOLEAN;
9986    t_status  NUMBER;
9987  BEGIN
9988    IF pOutputType = c_output_text THEN
9989      --
9990      -- If there are no hidden params set, no need to recommend review.
9991      --
9992      t_boolean := FALSE;
9993      BEGIN
9994         EXECUTE IMMEDIATE 'SELECT COUNT(1) FROM sys.v$parameter WHERE name LIKE ''\_%'' ESCAPE ''\'''
9995         INTO t_status;
9996         IF (t_status >= 1) THEN
9997           t_boolean := TRUE;
9998         END IF;
9999      EXCEPTION
10000          WHEN OTHERS THEN NULL;
10001      END;
10002      IF t_boolean THEN
10003        DisplayLine(pPreScriptUFT,'BEGIN');
10004        DisplayLineBoth(pPreScriptUFT, '');
10005        DisplayCenter(pPreScriptUFT,pStarHeader);
10006        DisplayCenter(pPreScriptUFT,CenterLine('*********** Hidden Parameters ***********'));
10007        DisplayCenter(pPreScriptUFT,pStarHeader);
10008        DisplayLineBoth(pPreScriptUFT, '');
10009        DisplayLineBoth(pPreScriptUFT, 'Please remove all hidden parameters prior to upgrading.');
10010        DisplayLineBoth(pPreScriptUFT, 'To view existing hidden parameters execute the following command');
10011        DisplayLineBoth(pPreScriptUFT, 'while connected AS SYSDBA:');
10012        DisplayLineBoth(pPreScriptUFT, '');
10013        DisplayLineBoth(pPreScriptUFT, '    SELECT name,description from SYS.V$PARAMETER WHERE name');
10014        DisplayLineBoth(pPreScriptUFT, q'!        LIKE ''\_%'' ESCAPE ''\''!');
10015        DisplayLineBoth(pPreScriptUFT, '');
10016        DisplayLineBoth(pPreScriptUFT, 'Changes will need to be made in the init.ora or spfile.');
10017        DisplayLineBoth(pPreScriptUFT, '');
10018        DisplayLineBoth(pPreScriptUFT, pActionSuggested);
10019        DisplayLineBoth(pPreScriptUFT, '');
10020        DisplayLine(pPreScriptUFT,'END;');
10021        DisplayLine(pPreScriptUFT,'/');
10022        --
10023        -- These are only if we are dumping out a script - output the command listed above.
10024        --
10025        IF pOutputtingScripts THEN
10026          DisplayLine('');
10027          DisplayLine(' The Pre-Upgrade Fixup Script will display the Hidden Parameters');
10028          DisplayLine(' currently defined');
10029          DisplayLine('');
10030          DisplayLine(pPreScriptUFT,'BEGIN');
10031  
10032          DisplayLine(pPreScriptUFT, q'!dbms_output.put_line ('           ********    Existing Hidden Parameters   ********');!');
10033          DisplayLine(pPreScriptUFT, 'END;');
10034          DisplayLine(pPreScriptUFT, '/');
10035          DisplayLine(pPreScriptUFT, q'!SELECT name,description from SYS.V$PARAMETER WHERE name LIKE '\_%' ESCAPE '\';!');
10036        END IF;
10037      END IF; -- end of hidden_params_in_use
10038    END IF;
10039  END hidden_params_recommend;
10040  
10041  
10042  PROCEDURE underscore_events_recommend
10043  IS
10044    t_boolean BOOLEAN;
10045    t_status  NUMBER;
10046  BEGIN
10047  
10048    IF pOutputType = c_output_text THEN
10049      --
10050      -- underscore events that are set.
10051      --
10052      t_boolean := FALSE;
10053      BEGIN
10054        EXECUTE IMMEDIATE 'SELECT COUNT(1) FROM sys.v$parameter2 WHERE (UPPER(name) = ''EVENT''
10055             OR UPPER(name)=''_TRACE_EVENTS'') AND isdefault=''FALSE'''
10056        INTO t_status;
10057        IF (t_status >= 1) THEN
10058          t_boolean := TRUE;
10059        END IF;
10060      EXCEPTION
10061        WHEN OTHERS THEN NULL;
10062      END;
10063  
10064      IF t_boolean THEN
10065        DisplayLine(pPreScriptUFT, 'BEGIN');
10066        DisplayLineBoth(pPreScriptUFT, '');
10067        DisplayCenter(pPreScriptUFT,pStarHeader);
10068        DisplayCenter(pPreScriptUFT,CenterLine('************ Existing Events ************'));
10069        DisplayCenter(pPreScriptUFT,pStarHeader);
10070        DisplayLineBoth(pPreScriptUFT, '');
10071        DisplayLineBoth(pPreScriptUFT,'Please review any defined events prior to upgrading.');
10072        DisplayLineBoth(pPreScriptUFT, '');
10073        DisplayLineBoth(pPreScriptUFT,'To view existing nondefault events execute the following commands');
10074        DisplayLineBoth(pPreScriptUFT,'while connected AS SYSDBA:');
10075        DisplayLineBoth(pPreScriptUFT,'  Events:');
10076        DisplayLineBoth(pPreScriptUFT,q'!    SELECT (translate(value,chr(13)||chr(10),'' '')) FROM sys.v$parameter2!');
10077        DisplayLineBoth(pPreScriptUFT,q'!      WHERE  UPPER(name) =''EVENT'' AND  isdefault=''FALSE'';!');
10078        DisplayLineBoth(pPreScriptUFT, '');
10079        DisplayLineBoth(pPreScriptUFT,'  Trace Events:');
10080        DisplayLineBoth(pPreScriptUFT,q'!    SELECT (translate(value,chr(13)||chr(10),'' '')) from sys.v$parameter2!');
10081        DisplayLineBoth(pPreScriptUFT,q'!      WHERE (UPPER(name) = ''_TRACE_EVENTS'') AND isdefault=''FALSE'';!');
10082        DisplayLineBoth(pPreScriptUFT, '');
10083        DisplayLineBoth(pPreScriptUFT,'Changes will need to be made in the init.ora or spfile.');
10084        DisplayLineBoth(pPreScriptUFT, '');
10085        DisplayLineBoth(pPreScriptUFT, pActionSuggested);
10086        DisplayLineBoth(pPreScriptUFT, '');
10087        DisplayLine(pPreScriptUFT, 'END;');
10088        DisplayLine(pPreScriptUFT, '/');
10089        --
10090        -- These are only if we are dumping out a script - output the command listed above.
10091        --
10092        IF pOutputtingScripts THEN
10093          DisplayLine('');
10094          DisplayLine(' The Pre-Upgrade Fixup Script will display the Existing Events');
10095          DisplayLine(' currently defined');
10096          DisplayLine('');
10097  
10098          DisplayLine(pPreScriptUFT, 'BEGIN');
10099          DisplayLine(pPreScriptUFT, '');
10100          DisplayLine(pPreScriptUFT,q'!dbms_output.put_line  ('            ********           Existing Events       ********');!');
10101          DisplayLine(pPreScriptUFT,q'!dbms_output.put_line  ('            ********  Query may return no Rows Selected *****');!');
10102          DisplayLine(pPreScriptUFT, 'END;');
10103          DisplayLine(pPreScriptUFT, '/');
10104  
10105          DisplayLine(pPreScriptUFT,q'! SELECT (translate(value,chr(13)||chr(10),' ')) FROM sys.v$parameter2!');
10106          DisplayLine(pPreScriptUFT,q'!   WHERE  UPPER(name) ='EVENT' AND  isdefault='FALSE';!');
10107  
10108          DisplayLine(pPreScriptUFT, 'BEGIN');
10109          DisplayLine(pPreScriptUFT, q'!dbms_output.put_line ('            ********      Existing Trace Events      ********');!');
10110          DisplayLine(pPreScriptUFT,q'!dbms_output.put_line  ('            ********  Query may return no Rows Selected *****');!');
10111          DisplayLine(pPreScriptUFT, 'END;');
10112          DisplayLine(pPreScriptUFT, '/');
10113  
10114          DisplayLine(pPreScriptUFT,q'! SELECT (translate(value,chr(13)||chr(10),' ')) from sys.v$parameter2!');
10115          DisplayLine(pPreScriptUFT,q'!   WHERE (UPPER(name) = '_TRACE_EVENTS') AND isdefault='FALSE';!');
10116  
10117        END IF;
10118      END IF; -- end of non_default_events
10119    END IF;
10120  END underscore_events_recommend;
10121  
10122  PROCEDURE audit_records_recommend
10123  IS
10124    t_boolean BOOLEAN;
10125    t_status  NUMBER;
10126  BEGIN
10127    IF pOutputType = c_output_text THEN
10128      t_boolean := FALSE;
10129      t_status := 0;
10130      -- There are three checks here - for various options of audit records.
10131      BEGIN
10132        EXECUTE IMMEDIATE 'SELECT count(*) FROM sys.aud$ WHERE dbid is null'
10133        INTO t_status;
10134        IF t_status > 250000 THEN
10135          t_boolean := TRUE;
10136        END IF;
10137      EXCEPTION
10138        WHEN OTHERS THEN NULL;
10139      END;
10140      BEGIN
10141        -- Standard Auditing, only when Oracle Label Security (OLS)
10142        -- and/or Database Vault (DV) is installed
10143        EXECUTE IMMEDIATE 'SELECT count(*) FROM system.aud$ WHERE dbid is null'
10144        INTO t_status;
10145        IF t_status > 250000 THEN
10146          t_boolean := TRUE;
10147      END IF;
10148      EXCEPTION
10149        WHEN OTHERS THEN NULL;
10150      END;
10151      BEGIN
10152        -- Fine Grained Auditing
10153        EXECUTE IMMEDIATE 'SELECT count(*) FROM sys.fga_log$ WHERE dbid is null'
10154        INTO t_status;
10155        IF t_status > 250000 THEN
10156          t_boolean := TRUE;
10157        END IF;
10158      EXCEPTION
10159        WHEN OTHERS THEN NULL;
10160      END;
10161  
10162      IF t_boolean THEN
10163        DisplayLine(pPreScriptUFT, 'BEGIN');
10164        DisplayLineBoth(pPreScriptUFT, '');
10165        DisplayCenter(pPreScriptUFT,pStarHeader);
10166        DisplayCenter(pPreScriptUFT,CenterLine('******** Audit Record Pre-Processing ********'));
10167        DisplayCenter(pPreScriptUFT,pStarHeader);
10168        DisplayLineBoth(pPreScriptUFT, '');
10169        DisplayLineBoth(pPreScriptUFT, 'The database contains a large number of Audit records which can slow down');
10170        DisplayLineBoth(pPreScriptUFT, 'an upgrade.  Please review My Oracle Support note number 1329590.1 ');
10171        DisplayLineBoth(pPreScriptUFT, 'for options on processing these records prior to the upgrade to save');
10172        DisplayLineBoth(pPreScriptUFT, 'upgrade down time');
10173        DisplayLineBoth(pPreScriptUFT, '');
10174        DisplayLineBoth(pPreScriptUFT, pActionSuggested);
10175        DisplayLineBoth(pPreScriptUFT, '');
10176        DisplayLine(pPreScriptUFT, 'END;');
10177        DisplayLine(pPreScriptUFT, '/');
10178      END IF;
10179    END IF;
10180  END audit_records_recommend;
10181  
10182  PROCEDURE fixed_objects_recommend
10183  IS
10184  BEGIN
10185    IF pOutputType = c_output_text THEN
10186      DisplayLine(pPostScriptUFT, 'BEGIN');
10187      DisplayCenter(pPostScriptUFT,pStarHeader);
10188      DisplayCenter(pPostScriptUFT,CenterLine('******** Fixed Object Statistics ********'));
10189      DisplayCenter(pPostScriptUFT,pStarHeader);
10190  
10191      DisplayLineBoth(pPostScriptUFT,'');
10192      DisplayLineBoth(pPostScriptUFT,'Please create stats on fixed objects two weeks');
10193      DisplayLineBoth(pPostScriptUFT,'after the upgrade using the command:');
10194      DisplayLineBoth(pPostScriptUFT,'   EXECUTE DBMS_STATS.GATHER_FIXED_OBJECTS_STATS;');
10195      DisplayLineBoth(pPostScriptUFT,'');
10196      DisplayLineBoth(pPostScriptUFT, pActionSuggested);
10197      DisplayLineBoth(pPostScriptUFT, '');
10198      DisplayLine(pPostScriptUFT, 'END;');
10199      DisplayLine(pPostScriptUFT, '/');
10200    END IF;
10201  END fixed_objects_recommend;
10202  
10203  -- bug 16191893 : to be called last by caller/preupgrd.sql.  this will reset
10204  -- global variables (e.g., error msg count) on next run of preupgrade tool.
10205  PROCEDURE reset_init_package
10206  IS
10207  BEGIN
10208    p_package_inited := FALSE;
10209  END reset_init_package;
10210  
10211  
10212  END dbms_preup;
10213  /

Package body created.

SQL> 
SQL> exec dbms_preup.run_fixup_and_report('INVALID_SYS_TABLEDATA')
**********************************************************************
Check Tag:     INVALID_SYS_TABLEDATA
Check Summary: Check for invalid (not converted) table data
Fix Summary:   UPGRADE Oracle supplied table data prior to the database upgrade.
**********************************************************************
Fixup Succeeded
**********************************************************************

PL/SQL procedure successfully completed.

SQL> declare
  2    do_abort boolean := false;
  3  begin
  4    if dbms_preup.condition_exists ('INVALID_SYS_TABLEDATA') then
  5      -- dump out the info
  6      dbms_preup.run_check('INVALID_SYS_TABLEDATA');
  7      dbms_preup.run_fixup_and_report('INVALID_SYS_TABLEDATA');
  8      if dbms_preup.condition_exists ('INVALID_SYS_TABLEDATA') then
  9         do_abort := TRUE;
 10      end if;
 11    end if;
 12    if dbms_preup.condition_exists ('INVALID_USR_TABLEDATA') THEN
 13      -- dump out the info
 14      dbms_preup.run_check('INVALID_USR_TABLEDATA');
 15      do_abort := TRUE;
 16    END IF;
 17    If do_abort THEN
 18      dbms_output.put_line ('Invalid table data.');
 19      dbms_output.put_line ('Non-CDB conversion aborting.');
 20      dbms_output.put_line ('For instructions, look for ORA-01722 in this script.');
 21      dbms_output.put_line ('Please resolve these and rerun noncdb_to_pdb.sql.');
 22      RAISE INVALID_NUMBER;
 23    end if;
 24  end;
 25  /
**********************************************************************
Check Tag:       INVALID_SYS_TABLEDATA
Check Summary:   Check for invalid (not converted) table data
Check Help Text:
ERROR: --> Invalid Oracle supplied table data found in your database.


Invalid data can be seen prior to the database upgrade
     or during PDB plug
in.  This table data must be made
     valid BEFORE upgrade or plug in.

   - To
fix the data, load the Preupgrade package and execute
     the fixup routine.

For plug in, execute the fix up routine in the PDB.


@?/rdbms/admin/utluppkg.sql
    SET SERVEROUTPUT ON;
    exec
dbms_preup.run_fixup_and_report('INVALID_SYS_TABLEDATA')
    SET SERVEROUTPUT
OFF;
Fixup Summary:
UPGRADE Oracle supplied table data prior to the database upgrade.
++++ Check Failed:
ERROR: --> Invalid Oracle supplied table data found in your database.


Invalid data can be seen prior to the database upgrade
     or during PDB plug
in.  This table data must be made
     valid BEFORE upgrade or plug in.

   - To
fix the data, load the Preupgrade package and execute
     the fixup routine.

For plug in, execute the fix up routine in the PDB.


@?/rdbms/admin/utluppkg.sql
    SET SERVEROUTPUT ON;
    exec
dbms_preup.run_fixup_and_report('INVALID_SYS_TABLEDATA')
    SET SERVEROUTPUT
OFF;
**********************************************************************
Check Tag:     INVALID_SYS_TABLEDATA
Check Summary: Check for invalid (not converted) table data
Fix Summary:   UPGRADE Oracle supplied table data prior to the database upgrade.
**********************************************************************
Fixup Succeeded
**********************************************************************
Invalid table data.
Non-CDB conversion aborting.
For instructions, look for ORA-01722 in this script.
Please resolve these and rerun noncdb_to_pdb.sql.
declare
*
ERROR at line 1:
ORA-01722: invalid number
ORA-06512: at line 22


Disconnected from Oracle Database 12c Enterprise Edition Release 12.1.0.1.0 - 64bit Production
With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options
